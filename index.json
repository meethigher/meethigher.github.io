[{"C":"这是一篇带图片的文章\n\u0026quot;英文引号\u0026quot;，“中文引号”\n一、标题层级测试 测试标题 2 测试标题 3 测试标题 4 测试标题 5 测试标题 6（不建议用于正文） 建议：h6 不要小于正文字体大小，更多用于语义而非视觉。\n二、文本样式测试 加粗文本示例 斜体文本示例 加粗 + 斜体文本示例\n删除线文本示例\n行内代码示例\n\u0026quot;英文双引号\u0026quot;\n'英文单引号'\n“中文双引号”\n‘中文单引号’\n引用示例： 这是一段引用文本，用于强调内容或引用说明。\n三、列表测试 无序列表 测试无序 1 测试无序 2 测试无序 3 层级无序列表 测试无序1 测试无序1.1 测试无序1.1.1 测试无序1.2 测试无序2 有序列表 测试有序 1 测试有序 2 测试有序 3 层级有序列表 测试有序1 测试有序1.1 测试有序1.1.1 测试有序1.2 测试有序2 组合测试 无序1 有序1.1 无序1.1.1 有序1.2 无序2 四、链接与图片 测试链接\n五、代码块测试 Java 示例 java\r1 2 3 4 5 6 7 8 9 10 11 12 13 // Person 示例类 public class Person { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } } Shell 示例 bash\r1 2 3 curl -v https://google.com curl -v https://meethigher.top 纯文本示例 text\r1 2 3 curl -v https://google.com curl -v https://meethigher.top 长代码块示例 text\r1 curl -v https://meethigher.to/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 六、表格测试 正常表格\n测试表格 测试表格 测试表格 测试表格 测试表格 测试表格 测试表格 测试表格 测试表格 测试表格 测试表格 测试表格 长表格\n测试表格 测试表格 测试表格 测试表格 测试表格 测试表格 测试表格 测试表格 测试表格 测试表格 测试表格 测试表格aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 七、动态内容（不推荐） 99 年 99 天 99 时 99 分 99 秒\n建议：\n动态内容放到 shortcode / JS 文件 不要直接写在 Markdown 正文中 ","D":"2024-12-01T17:52:33+08:00","P":"https://meethigher.github.io/2024/post-1/","T":"这是一个超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级长的标题"},{"C":"最近我在思考一个问题。在长连接的使用场景中，为了及时释放空闲资源，通常会配置空闲超时机制。\n这种机制应用于单个连接（比如一个 TCP 或 HTTP 连接）时，自然没问题。然而，如果放在一整条通信链路中，链路上的各个节点分别配置了不同的空闲超时参数，会发生什么情况呢？\n我在一次实施中就遇到了类似的情况：当请求在发送后一段时间（大约 1 分钟）再次发起时，系统就会报错。由于我负责的是链路最下游的部分，无法直接查看上游节点的配置，只能推测可能是由于链路中各节点的空闲超时设置不一致所致。最终，我尝试将我这边的 idleTimeout 设置为永不超时，问题随之消失。我猜测，是上游没有监测到我的超时断开，进而导致的问题。\n虽然问题得以解决，但具体成因仍然只是我的猜测，也没有权力知道全貌。因此为了验证这个猜想，我决定基于 Java 的 Vert.x 框架，模拟并分析这类链路中因空闲超时不一致而导致的问题。\n一、背景 最近我在思考一个问题。在长连接的使用场景中，为了及时释放空闲资源，通常会配置空闲超时机制。\n这种机制应用于单个连接（比如一个 TCP 或 HTTP 连接）时，自然没问题。然而，如果放在一整条通信链路中，链路上的各个节点分别配置了不同的空闲超时参数，会发生什么情况呢？\n我在一次实施中就遇到了类似的情况：当请求在发送后一段时间（大约 1 分钟）再次发起时，系统就会报错。由于我负责的是链路最下游的部分，无法直接查看上游节点的配置，只能推测可能是由于链路中各节点的空闲超时设置不一致所致。最终，我尝试将我这边的 idleTimeout 设置为永不超时，问题随之消失。我猜测，是上游没有监测到我的超时断开，进而导致的问题。\n虽然问题得以解决，但具体成因仍然只是我的猜测，也没有权力知道全貌。因此为了验证这个猜想，我决定基于 Java 的 Vert.x 框架，模拟并分析这类链路中因空闲超时不一致而导致的问题。\n首先了解TCP通信的三次握手、四次挥手。我在下面简单画一下。如何进行抓包可以参考TCP状态以及CLOSE_WAIT问题排查 - 言成言成啊\n三次握手\nsh\r1 2 3 4 5 6 7 8 9 主动建立方 被动建立方 | | | ------------------ SYN --------------------------\u0026gt; | | | | \u0026lt;--------------- SYN + ACK ----------------------- | | | | ------------------ ACK --------------------------\u0026gt; | | | 连接建立成功 连接建立成功 四次挥手\nsh\r1 2 3 4 5 6 7 8 9 10 11 12 13 主动关闭方 被动关闭方 | | | ------------------ FIN --------------------------\u0026gt; | | | | \u0026lt;------------------ ACK -------------------------- | | | | 等待服务器准备关闭 | | | | \u0026lt;----------------- FIN + ACK --------------------- | | | | ------------------ ACK --------------------------\u0026gt; | | | 连接关闭成功 连接关闭成功 不过在实际使用时，主动关闭方会发送FIN+ACK给被动关闭方。这也是符合规范的。\n二、实践 2.1 实现 本文代码meethigher/bug-test at vertx-network-disconnect\n网络链路user --[a conn]-- proxyServer/proxyClient --[b conn]-- backendServer，我现在有三台机器，分别用来模拟链路中的三个角色。\nbackendServer: 192.168.1.223 永不超时 proxyServer/proxyClient: 192.168.1.103 proxyServer: 永不超时 proxyClient: 5秒空闲超时 user: 192.168.1.105 永不超时 随便使用局域网一台设备即可，只需要有telnet命令。执行telnet 192.168.1.103 8080，观察5秒之后，连接是否会被断开 backendServer源码\njava\r1 2 3 4 NetServer backendServer = vertx.createNetServer(); backendServer.connectHandler(socket -\u0026gt; socket.write(String.valueOf(System.currentTimeMillis()))) .listen(8888) .onFailure(e -\u0026gt; System.exit(1)); 下面记录使用Vertx中NetSocket的两种api来双向传输数据，以及超时导致的问题。\n2.1.1 handler..write proxyServer/proxyClient关键代码\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 NetServer proxyServer = vertx.createNetServer(); NetClient proxyClient = vertx.createNetClient(new NetClientOptions() .setIdleTimeoutUnit(TimeUnit.SECONDS) .setIdleTimeout(5)); proxyServer.connectHandler(a -\u0026gt; { a.pause(); proxyClient.connect(8888, \u0026#34;192.168.1.223\u0026#34;).onFailure(e -\u0026gt; System.exit(1)) .onSuccess(b -\u0026gt; { b.pause(); a.handler(b::write); b.handler(a::write); a.resume(); b.resume(); }); }).listen(8080).onFailure(e -\u0026gt; System.exit(1)); 现象：b连接断开，a连接保持\ntcp抓包日志截图如下，会发现proxyServer/proxyClient向backendServer发送了FIN，所以b连接断开，但是并没有向user发送，所以a连接仍然保持。\n2.1.2 pipeTo proxyServer/proxyClient关键代码\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 NetServer proxyServer = vertx.createNetServer(); NetClient proxyClient = vertx.createNetClient(new NetClientOptions() .setIdleTimeoutUnit(TimeUnit.SECONDS) .setIdleTimeout(5)); proxyServer.connectHandler(a -\u0026gt; { a.pause(); proxyClient.connect(8888, \u0026#34;192.168.1.103\u0026#34;).onFailure(e -\u0026gt; System.exit(1)) .onSuccess(b -\u0026gt; { b.pause(); a.pipeTo(b); b.pipeTo(a); a.resume(); b.resume(); }); }).listen(8080).onFailure(e -\u0026gt; System.exit(1)); 现象：b连接断开，a连接也断开\ntcp抓包日志截图如下，会发现proxyServer/proxyClient向backendServer发送了FIN，所以b连接断开，也向user发送FIN，所以a连接也断开。\n2.2 思考 2.2.1 handler..write与pipeTo的区别 为啥handler..write与pipeTo的结果不同呢？这就需要跟一下pipeTo源码了。\n原因在于pipeTo内部给源头连接注册了endHandler和exceptionHandler，当监听到如上事件时，会默认将对端连接也进行end()。\n由于io.vertx.core.streams.Pipe的实现类io.vertx.core.streams.impl.PipeImpl逻辑不复杂，跟别的模块代码也并没有强耦合，因此我们可以自己复制一份DiyPipe出来，以供自己调试。\n那么pipeTo到底做了哪些东西呢？这个可以将其使用handler..write来实现出来。a.pipeTo(b).onComplete(completion)就相当于如下代码\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 a.resume(); a.handler(buf -\u0026gt; { b.write(buf); if (b.writeQueueFull()) { a.pause(); b.drainHandler(t -\u0026gt; a.resume()); } }); a.endHandler(v -\u0026gt; { a.handler(null); a.endHandler(null); a.exceptionHandler(null); b.end().onComplete(completion); }); a.exceptionHandler(e -\u0026gt; { a.handler(null); a.endHandler(null); a.exceptionHandler(null); b.end().onComplete(v -\u0026gt; completion.handle(Future.failedFuture(e))); }); 在此也提一个插曲，之前发现了一个tcp反向代理的bug\nTCP反向代理在反代HTTP短连接服务时，出现io.netty.channel.StacklessClosedChannelException · Issue #6 · meethigher/tcp-reverse-proxy meethigher/bug-test at vertx-tcp-proxy-closed 这个问题其实挺傻逼的，用了pipeTo这个api，连接的生命周期已经双向绑定了，而我又进行了再次绑定，进而导致关了又关的问题。\n2.2.2 endHandler()/closeHandler()区别 在Vertx中，end和close主要用于区分半关闭和全关闭的状态。\n以NetSocket为例，end底层调用了close，因此调用end()和调用close()的作用是一致的。\n但是endHandler()和closeHandler()是严格不一样的。可以通过源码查看对应的触发时机，明显是endHandler()会比closeHandler()触发更靠前。\n2.3 Promise用法示例 常规使用示例\njava\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import io.vertx.core.*; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.util.concurrent.ThreadLocalRandom; import java.util.concurrent.locks.LockSupport; public class PromiseUsage { private static final Vertx vertx = Vertx.vertx(); private static final Logger log = LoggerFactory.getLogger(PromiseUsage.class); public static Future\u0026lt;String\u0026gt; getFuture() { // Promise用法 final Promise\u0026lt;String\u0026gt; promise = Promise.promise(); vertx.setTimer(5000, id -\u0026gt; { if (ThreadLocalRandom.current().nextBoolean()) { promise.complete(\u0026#34;succeed\u0026#34;); } else { promise.fail(\u0026#34;failed\u0026#34;); } }); return promise.future(); } public static void main(String[] args) { Handler\u0026lt;AsyncResult\u0026lt;String\u0026gt;\u0026gt; completion = ar -\u0026gt; { if (ar.succeeded()) { log.info(\u0026#34;test succeed\u0026#34;); } else { log.error(\u0026#34;test failed\u0026#34;, ar.cause()); } }; getFuture().onComplete(completion); getFuture().onComplete(v -\u0026gt; { completion.handle(Future.failedFuture(new RuntimeException(\u0026#34;hh\u0026#34;))); }); for (int i = 0; i \u0026lt; 10; i++) { getFuture().onComplete(ar -\u0026gt; { if (ar.succeeded()) { log.info(\u0026#34;future completed\u0026#34;); } else { log.error(\u0026#34;future failed\u0026#34;); } }); } LockSupport.park(); } } ","D":"2024-12-01T17:52:37+08:00","P":"https://meethigher.github.io/2024/post-2/","T":"小记 Vert.x 的 Pipe 都做了什么"},{"C":"参数说明如下\ncategories: [] 表示该文章的分类，英文逗号分隔 tags: [] 表示该文章的标签，英文逗号分隔 type: post 为主题定义值，表示在 home.html、list.html、以及查询结果中展示。 draft: true 表示该文章不生成 html comments: false 表示该文章不启用 gitalk mathjax: true 表示开启数学公式功能 state: none 表示默认、draft 文章标题会显示未完成、top 文章标题会显示置顶（置顶需与weight配合使用） weight: 数字越小，文章列表越靠前 content\n","D":"2026-02-25T15:49:05+08:00","P":"https://meethigher.github.io/2026/post-7/","T":"Post 7"},{"C":"参数说明如下\ncategories: [] 表示该文章的分类，英文逗号分隔 tags: [] 表示该文章的标签，英文逗号分隔 type: post 为主题定义值，表示在 home.html、list.html、以及查询结果中展示。 draft: true 表示该文章不生成 html comments: false 表示该文章不启用 gitalk mathjax: true 表示开启数学公式功能 state: none 表示默认、draft 文章标题会显示未完成、top 文章标题会显示置顶（置顶需与weight配合使用） weight: 数字越小，文章列表越靠前 content\n","D":"2026-02-25T15:49:02+08:00","P":"https://meethigher.github.io/2026/post-6/","T":"Post 6"},{"C":"参数说明如下\ncategories: [] 表示该文章的分类，英文逗号分隔 tags: [] 表示该文章的标签，英文逗号分隔 type: post 为主题定义值，表示在 home.html、list.html、以及查询结果中展示。 draft: true 表示该文章不生成 html comments: false 表示该文章不启用 gitalk mathjax: true 表示开启数学公式功能 state: none 表示默认、draft 文章标题会显示未完成、top 文章标题会显示置顶（置顶需与weight配合使用） weight: 数字越小，文章列表越靠前 content\n","D":"2026-02-25T15:48:58+08:00","P":"https://meethigher.github.io/2026/post-5/","T":"Post 5"},{"C":"summary\ncontent\n","D":"2024-12-01T17:52:46+08:00","P":"https://meethigher.github.io/2024/post-4/","T":"Post 4"},{"C":"summary\n从兼容移动端的角度考虑，尽量避免使用行内公式，过长的行内公式，在移动端展示有问题\n快速幂的思路，就是将之前遍历相乘n次，降低到只需遍历相乘\u0026lt;n次。\n举例来说，对于\\(a^{11}\\)，推导过程如下 $$ a^{11}=a^{1*2^3+0*2^2+1*2^1+1*^0}=a^{2^3}*a^{2^1}*a^{2^0}=a^8*a^2*a^1 $$ 通过第一个等号后面的内容的乘方，可知指数的系数恰好是十进制11的二进制1011，最后的结果就是二进制位为0时，不计算。\n那么计算\\(a^{11}\\)只需要遍历3次。\n再次验证\\(a^{12}\\)，推导过程如下 $$ a^{12}=a^{1*2^3+1*2^2+0*2^1+0*2^0}=a^{2^3}*a^{2^2}=a^8*a^4 $$ 那么计算\\(a^{12}\\)只需要遍历2次。\n求多个相同因数的积的运算叫做乘方，乘方的结果叫做幂，相同因数就是底数，而因数的个数是指数。\n这是行内公式 $E=mc^2$\n这是行内公式 $a^{12}=a^{1*2^3+1*2^2+0*2^1+0*2^0}=a^{2^3}*a^{2^2}=a^8*a^4$ 阿里嘎多，吆西吆西\n这是块级公式\n$$ \\int_0^1 x^2 dx = \\frac{1}{3} $$\n这是块级公式\n\\[ a^{12}=a^{1*2^3+1*2^2+0*2^1+0*2^0}=a^{2^3}*a^{2^2}=a^8*a^4 \\]\n","D":"2024-12-01T17:52:41+08:00","P":"https://meethigher.github.io/2024/post-3/","T":"Post 3"}]