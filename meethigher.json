[{"title":"继承案例以及抽象类","url":"/blog/2019/abstract-and-extends-case/","content":"\n继承案例以及抽象方法和抽象类\n\n<!--more-->\n\n# 继承案例--发红包\n\n## 设计实现\n\n{% asset_img 1568901959610.png 类图 %}\n\n\n* 发红包\n  * 返回值：ArrayList<Integer>\n  * 方法名称：send\n  * 参数列表：\n    * 总共发多少钱：int totalMoney\n    * 分成多少份：int count\n* 收红包\n  * 返回值：void\n  * 方法名称：receive\n  * 参数列表：ArrayList<Integer> list\n\n## 具体实现\n\n* User类\n\n```\npublic class User {\n\tprivate String name;// 姓名\n\tprivate int money;// 余额，也就是当前用户拥有的钱数\n\n\tpublic User() {\n\n\t}\n\n\tpublic User(String name, int money) {\n\t\tthis.name = name;\n\t\tthis.money = money;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic int getMoney() {\n\t\treturn money;\n\t}\n\n\tpublic void setMoney(int money) {\n\t\tthis.money = money;\n\t}\n\n\t// 展示一下当前用户有多少钱\n\tpublic void show() {\n\t\tSystem.out.println(\"成员：\" + name + \" 余额：\" + money);\n\t}\n\n}\n```\n\n* Manager类\n\n```\npublic class Manager extends User {\n\tpublic Manager() {\n\n\t}\n\n\tpublic Manager(String name, int money) {\n\t\tsuper(name, money);\n\t}\n\n\tpublic ArrayList<Integer> send(int totalMoney, int count) {\n\t\t// 首先需要一个集合，用来存储若干个红包的金额\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\n\t\t// 首先看一下群主自己有多少钱\n\t\tint leftMoney = super.getMoney();// 群主当前余额\n\n\t\tif (totalMoney > leftMoney) {\n\t\t\tSystem.out.println(\"余额不足\");\n\t\t\treturn list;// 返回空集合\n\t\t}\n\n\t\t// 扣钱，重新设置余额\n\t\tsuper.setMoney(leftMoney - totalMoney);\n\n\t\t// 红包需要平均拆分成count份\n\t\tint avg = totalMoney / count;\n\t\tint mod = totalMoney % count;// 余数，也就是甩下的零头\n\n\t\t// 除不开的零头，包在最后一个红包当中\n\t\t// 下面把红包一个个放到集合当中\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tif (i >= (count - 1)) {\n\t\t\t\tlist.add(avg + mod);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlist.add(avg);\n\n\t\t}\n\n\t\treturn list;\n\n\t}\n\n}\n```\n\n\n\n* Member类\n\n```\npublic class Member extends User {\n\n\tpublic Member() {\n\t\tsuper();\n\t\t// TODO Auto-generated constructor stub\n\t}\n\n\tpublic Member(String name, int money) {\n\t\tsuper(name, money);\n\t\t// TODO Auto-generated constructor stub\n\t}\n\n\tpublic void receive(ArrayList<Integer> list) {\n\t\t// 从所有红包中，随机获取一个\n\t\t// 随机获取集合中的一个索引编号\n\t\tint index = new Random().nextInt(list.size());\n\n\t\t// 根据索引，从集合当中删除，并且得到被删除的红包，给我自己\n\t\tint delta = list.remove(index);\n\t\t// 当前成员本身有多少钱呢？\n\t\tint money = super.getMoney();\n\t\tsuper.setMoney(money + delta);\n\t}\n}\n```\n\n* 主函数\n\n```\npublic class MainRedPacker {\n\n\tpublic static void main(String[] args) {\n\t\tManager manager=new Manager(\"群主\",1000);\n\t\t\n\t\tMember one=new Member(\"成员A\",0);\n\t\tMember two=new Member(\"成员B\",0);\n\t\tMember three=new Member(\"成员C\",0);\n\t\t\n\t\t//展示一下个人信息\n\t\tmanager.show();\n\t\tone.show();\n\t\ttwo.show();\n\t\tthree.show();\n\t\tSystem.out.println(\"=====================\");\n\t\t\n\t\t//发红包\n\t\tArrayList<Integer> list=manager.send(23, 3);\n\t\t//收红包\n\t\tone.receive(list);\n\t\ttwo.receive(list);\n\t\tthree.receive(list);\n\t\t\n\t\t//再次展示发红包以后各个成员的钱数\n\t\tmanager.show();\n\t\tone.show();\n\t\ttwo.show();\n\t\tthree.show();\n\t\tSystem.out.println(\"=====================\");\n\t\t\n\t}\n\n}\n```\n\n* 运行结果\n\n```\n成员：群主 余额：1000\n成员：成员A 余额：0\n成员：成员B 余额：0\n成员：成员C 余额：0\n=====================\n成员：群主 余额：977\n成员：成员A 余额：7\n成员：成员B 余额：9\n成员：成员C 余额：7\n=====================\n```\n\n# 抽象方法以及抽象类\n\n## 基本概念\n\n啥是抽象类？直接上图。\n\n {% asset_img 1568903209060.png 啥是抽象类 %}\n\n**抽象方法：**就是加上abstract关键字，然后去掉大括号，直接分号结束\n\n**抽象类：**抽象方法所在的类，必须是抽象类才行。在class之前加上abstract即可\n\n**如何使用抽象类和抽象方法：**\n\n1. 不能直接创建new抽象类对象\n2. 必须用一个子类来继承抽象父类\n3. 子类**覆盖重写**抽象父类当中**所有的抽象方法**\n覆盖重写：子类去掉抽象方法中的abstract，然后补上方法体大括号\n4. 创建子类对象使用\n\n\n\n## 案例\n\n* Animal类\n\n```\npublic abstract class Animal {\n\t//这是一个抽象方法，代表吃东西，但是具体吃什么(大括号的内容)不确定\n\tpublic abstract void eat();\n\t\n\t//这是普通的成员方法\n\tpublic void normalMethod() {\n\t\t\n\t}\n}\n```\n\n\n\n* Cat类\n\n```\npublic class Cat extends Animal {\n\n\t@Override\n\tpublic void eat() {\n\t\tSystem.out.println(\"猫吃鱼\");\n\t}\n}\n```\n\n\n\n* 主函数\n\n```\npublic static void main(String[] args) {\n\t\t//Animal animal=new Animal();//错误写法，不能直接创建抽象类\n\t\tCat cat=new Cat();\n\t\tcat.eat();//输出：猫吃鱼\n\t}\n```\n\n**注意事项：**\n\n1. 一个抽象类不一定含有抽象方法\n   只要保证抽象方法所在的类是抽象类，即可\n   这样没有抽象方法的抽象类，也能直接创建对象，在一些特殊场景下有用途\n2. 抽象类的子类必须重写父类中所有的抽象方法，否则，编译会无法通过而报错。除非该子类也是抽象类。","tags":["java"]},{"title":"蚂蚁森林自动解锁偷能量","url":"/blog/2020/auto-antforest/","content":"\n今天最后一门科目也考完试了，可以放心码代码了！定时自动解锁，自动刷步数，自动收能量、偷能量\n\n<!--more-->\n\n该脚本基于很多大佬开源的作品，先说声感谢。\n\n我写的这个脚本只适用于我自己的手机，我不打算兼容其他手机。如果你要用，可以自己再二次修改，原理都是一样。源代码以及用到的软件放到[这里](https://github.com/meethigher/auto-antforest);\n\n> 2020-07-21更新：\n>\n> 发现bug，即使通过xep来定时处理，autojs脚本也仍然可能出现中断运行的问题。这有可能是autojs的问题，我不知道他的sleep方法是如何实现的，sleep老是不能按期执行，偶尔能定时执行，偶尔又延迟好久执行。\n>\n> 总结了一下原因，还是出在息屏的问题上。长时间息屏导致后台sleep走时延迟。所以我在每天收蚂蚁森林的前一分钟，执行解锁脚本解锁一下，唤醒一下手机，过一分钟之后，再次执行自动脚本。目前是可以运行的。\n>\n> 2020-08-10更新：\n>\n> 今天更新了新版miui系统，但是脚本无法使用了，经过测试，发现xep定时执行是可以的，但是无法自动解锁。\n>\n> 解决办法是，授予电量无限制。新版MIUI会限制在后台启动app，除非给自启动权限，但是如果给了自启动，可能不定时的就会运行脚本，给生活带来困扰。\n\n\n\n# 一、初版本\n\n先放张截图\n\n{% asset_img 1.png %}\n\n功能：\n\n1. 定时解锁\n2. 自动刷步数\n3. 自动收能量\n4. 自动偷能量\n5. 锁屏\n\n全自动蚂蚁森林.js\n\n```js\n/**\n* 该脚本的思路\n* 运行之后，给定权限跟自启动和电源无限制。\n* 每天到了下面指定的时间，自动运行。\n* 我是android10。偶尔好使，偶尔不好使。\n* 可能是android出于安全考虑，限制了息屏后app的运行（有时候时间会运行很慢，或者不走。我尝试将其安装成系统应用，但是还是不好使）\n* 不过可以用来每隔10分钟执行一次，这样还是可以的，时间一久，就gg了\n*/\n\n\n\n//检查是否开启无障碍服务，若未开启则等待开启\nauto.waitFor();\n\n//测试机分辨率为1080*2340\n//不同像分辨率的机型会按比例缩放\nsetScreenMetrics(1080, 2340); //不要修改该行代码\n\nvar g_help_friend = true;\n//六球坐标值\nvar g_energy_postion = [\n    [250, 750],\n    [350, 700],\n    [450, 650],\n    [600, 650],\n    [750, 700],\n    [850, 750]\n];\nvar hour = 7;\nvar min = 10;\nvar sec = 0;\n\n\n//debug标志 用于测试\nconst DEBUG = false;\n\n//主程序入口\nmain();\n\nfunction addSteps() {\n    launchApp(\"小米步数管理\");\n    sleep(500);\n    id(\"edtAddSteps\").findOne().setText(20000);\n    sleep(100);\n    id(\"btnAddSteps\").findOne().click();\n    console.log(\"增加步数\");\n}\n\n/**\n * 解锁屏幕\n */\nfunction unlock() {\n    if (!device.isScreenOn()) { //息屏状态将屏幕唤醒\n        device.wakeUp(); //唤醒设备\n        sleep(1000); // 等待屏幕亮起\n        //miui锁屏滑动不能唤出密码输入 通过下拉通知栏点击时间进入密码解锁\n        swipe(500, 30, 500, 1000, 300);\n        sleep(400);\n        //点击时间\n        click(100, 120);\n        sleep(500);\n        click(555, 1379); //5\n        sleep(100);\n        click(244, 1381); //4\n        sleep(100);\n        click(224, 1200); //1\n        sleep(100);\n        click(541, 1596); //8\n        sleep(100);\n        click(541, 1596); //8\n        sleep(100);\n        click(224, 1200); //1\n        sleep(100);\n        click(244, 1381); //4\n        sleep(100);\n        click(555, 1379); //5\n        sleep(100);\n        click(544, 1196); //2\n        sleep(1000);\n        console.log(\"自动解锁屏幕\");\n    }\n}\n/**\n *锁定屏幕\n */\nfunction lock() {\n    KeyCode(26);\n    console.log(\"锁屏\");\n}\n\n/**\n * 请求截图权限\n */\nfunction getScreenCapturePermission() { //建议永久开启截图权限，在\"取消\"按键的上方，部分设备看不见，但是是存在的可以点击\n    if (!requestScreenCapture()) {\n        toast(\"获取截图权限失败，脚本退出\");\n        console.error(\"获取截图权限失败，脚本退出\");\n        exit();\n    }\n    toastLog(\"获取截图权限成功，等待支付宝启动\");\n    sleep(500);\n}\n\n/**\n * 注册退出事件\n */\nfunction registerExitEvent() {\n    var thread = threads.start(function() {\n        events.observeKey();\n        events.onKeyDown(\"volume_down\", function(event) {\n            toast(\"音量下键被按下，脚本退出\");\n            console.warn(\"音量下键被按下，脚本退出\");\n            exit();\n        });\n    });\n    return thread;\n}\n\n/**\n * 寻找支付宝首页\n */\nfunction findHomePage() {\n    let i = 0;\n    //尝试5次找到支付宝首页\n    while (i++ < 5) {\n        if (text(\"首页\").exists() && text(\"我的\").exists()) break;\n        back();\n        sleep(500);\n    }\n    if (i < 5)\n        return true;\n    else\n        return false;\n}\n\n/**\n * 打开支付宝\n */\nfunction openAlipay() { //请确保打开了\"Auto.js\"的后台弹出界面权限\n    launchApp(\"支付宝\");\n    sleep(1000);\n    //寻找支付宝首页\n    if (!findHomePage()) { //未找到，退出脚本\n        toast(\"寻找支付宝首页失败，脚本退出\");\n        console.error(\"寻找支付宝首页失败，脚本退出\");\n        exit();\n    } else { //找到则点击\n        let item = text(\"首页\").findOnce();\n        if (!item.selected()) {\n            let pos = item.bounds();\n            if (!click(pos.centerX(), pos.centerY())) {\n                console.error(\"打开支付宝首页失败，脚本退出\");\n                exit();\n            }\n        }\n        console.log(\"成功找到支付宝首页\");\n    }\n}\n\n/**\n * 进入蚂蚁森林\n */\nfunction entranceAntForest() {\n    //滑动页面找到蚂蚁森林\n    var item = null,\n        i = 0;\n    while (i++ < 5) {\n        // 使用className和text双重定位\n        item = className(\"android.widget.TextView\").text(\"蚂蚁森林\").findOnce();\n        if (item != null) break;\n        swipe(520, 500, 520, 1500, 500);\n        sleep(500);\n    }\n    if (item == null) {\n        toast(\"首页上没有蚂蚁森林，退出脚本\");\n        console.error(\"首页上没有蚂蚁森林，退出脚本\");\n        exit();\n    } else {\n        let pos = item.bounds();\n        click(pos.centerX(), pos.centerY());\n    }\n    //确保进入蚂蚁森林主页\n    i = 0;\n    while (i++ < 10) {\n        if (text(\"背包\").exists() && text(\"任务\").exists()) break;\n        sleep(1000); //进入蚂蚁森林主页的时间较长，因此循环检测的时间间隔设置为1000ms(default 500ms)\n    }\n    if (i >= 10) {\n        toast(\"进入蚂蚁森林主页失败，退出脚本\");\n        exit();\n    } else {\n        if (DEBUG)\n            console.log(\"成功进入蚂蚁森林主页\", \"用时\" + i * 1.0 + \"秒\");\n        else\n            console.log(\"成功进入蚂蚁森林主页\");\n    }\n    //收集自己的能量\n    collectionEnergyByPosition(400); //100ms delay\n\n    //确保\"查看更多好友\"控件出现在屏幕中\n    item = null;\n    i = 0;\n    while (i++ < 10) {\n        item = text(\"查看更多好友\").findOnce();\n        if (item != null && item.bounds().height() > 100) break;\n        swipe(520, 1800, 520, 300, 500);\n        sleep(500);\n    }\n    if (item == null) {\n        toast(\"没有找到查看更多好友，退出脚本\");\n        exit();\n    } else {\n        let pos = item.bounds();\n        if (!click(pos.centerX(), pos.centerY())) {\n            toast(\"进入好友排行榜失败，退出脚本\");\n            exit();\n        } else {\n            //进入好友排行榜\n            if (DEBUG)\n                console.log(\"成功进入好友排行榜\", \"用时\" + i * 0.5 + \"秒\");\n            else\n                console.log(\"成功进入好友排行榜\");\n            //预留足够的反应时间(default 2000ms)等待进入排行榜页面\n            //否则会出现排行榜前几个好友检测不到的bug\n            sleep(2000);\n\n            //进入好友排行榜页面收集好友能量\n            entranceFriendsRank();\n        }\n    }\n}\n\n/**\n * 根据名称查找并点击控件 返回null表示查找失败 返回false表示点击失败 返回true表示成功\n * @param {*} click_name 控件名称\n * @param {*} match_pos 前缀、后缀还是完全匹配\n * @param {*} text_or_desc text还是desc属性\n * @param {*} timeout 查找的超时时间\n */\nfunction searchAndClickByName(serach_name, match_pos, text_or_desc, timeout) {\n    var result = null;\n    if (match_pos == \"prefix\") {\n        if (text_or_desc == \"text\")\n            result = textStartsWith(serach_name).findOne(timeout);\n        else\n            result = descStartsWith(serach_name).findOne(timeout);\n    } else {\n        if (text_or_desc == \"text\")\n            result = textEndsWith(serach_name).findOne(timeout);\n        else\n            result = descEndsWith(serach_name).findOne(timeout);\n    }\n    if (!result) {\n        let pos = result.bounds();\n        if (pos.centerX() < 0 || pos.centerY() < 0)\n            return false;\n        else\n            return click(pos.centerX(), pos.centerY());\n    }\n    return null;\n}\n\n/**\n * 通过六球坐标收取(帮收)能量\n * @param {*} delay\n */\nfunction collectionEnergyByPosition(delay) {\n    if (typeof(delay) == \"undefined\") delay = 0;\n    for (let i = 0; i < g_energy_postion.length; ++i) {\n        click(g_energy_postion[i][0], g_energy_postion[i][1]);\n        sleep(200);\n    }\n}\n\n/**\n * 获取截图\n */\nfunction getCaptureImg() {\n    var img = captureScreen();\n    sleep(100);\n    if (img == null || typeof(img) == \"undefined\") {\n        toast(\"截图失败，脚本退出\");\n        console.error(\"截图失败，脚本退出\");\n        exit();\n    } else {\n        return img;\n    }\n}\n\n/**\n * 获取有能量成熟的好友\n */\nfunction getHasEnergyFriends() {\n    var img = getCaptureImg();\n    var hand = null,\n        heart = null;\n\n    //查找可收取能量的小手 \"#1da06d\"为深绿色 \"#ffffff\"为白色\n    hand = images.findMultiColors(img, \"#1da06d\", [\n        [0, -7, \"#ffffff\"],\n        [0, 10, \"#ffffff\"]\n    ], {\n        region: [1010, 400, 1, 1800],\n        threshold: 4\n    });\n    if (hand != null) {\n        console.info(\"找到**可收取**好友\");\n        return [hand, \"hand\"];\n    }\n\n    if (g_help_friend == true) {\n        //查找可帮收能量的爱心 \"##f99236\"为橙色\n        heart = images.findColor(img, \"#f99236\", { region: [1000, 400, 10, 1800], threshold: 4 });\n        if (heart != null) {\n            console.info(\"找到**可帮收**好友\");\n            return [heart, \"heart\"];\n        }\n    }\n    return null;\n}\n\n/**\n * 检测是否到达排行榜底部\n */\nfunction arriveRankBottom() {\n    var img = getCaptureImg();\n    //分别是白色、浅灰色、深灰色\n    var result = null;\n    result = images.findMultiColors(img, \"#F5F5F5\", [\n        [0, -40, \"#FFFFFF\"],\n        [0, 20, \"#999999\"]\n    ], {\n        region: [600, 2000],\n        threshold: 1\n    });\n    if (result != null)\n        return true;\n    else\n        return false;\n}\n\n/**\n * 进入好友排行榜\n */\nfunction entranceFriendsRank() {\n    var i = 0;\n    sleep(500);\n    var epoint = getHasEnergyFriends();\n\n    //确保当前操作是在排行榜界面\n    //不断滑动，查找好友\n    while (epoint == null) {\n        swipe(520, 1800, 520, 800, 500);\n        sleep(500);\n        epoint = getHasEnergyFriends();\n        //如果检测到结尾，同时也没有可收能量的好友，那么结束收取\n        if (epoint == null && arriveRankBottom()) {\n            toastLog(\"没有更多好友了\");\n            return true;\n        }\n        //如果连续32次都未检测到可收集好友,无论如何停止查找\n        if (i++ >= 32) {\n            console.error(\"程序可能出错, 连续\" + i + \"次未检测到可收集好友\");\n            return false;\n        }\n    }\n    //找到好友，进入好友森林\n    if (click(epoint[0].x, epoint[0].y + 20)) {\n        //确认进入了好友森林\n        let i = 0;\n        while (i++ < 10) {\n            if (text(\"TA收取你\").exists() && text(\"你收取TA\").exists()) break;\n            sleep(500);\n        }\n        if (i < 10) {\n            if (DEBUG) console.log(\"成功进入好友森林主页\", \"用时\" + i * 0.5 + \"秒\");\n            collectionEnergyByPosition(400); //100ms delay\n        }\n        //返回排行榜\n        back();\n    }\n    //递归调用\n    entranceFriendsRank();\n}\n\n/**\n * 主函数\n */\nfunction main() {\n    while (true) {\n        let date = new Date();\n        let sleepHour, sleepMin, sleepSec;\n        if (date.getSeconds() > sec) {\n            sleepSec = 60 - date.getSeconds() + sec;\n        } else {\n            sleepSec = sec - date.getSeconds();\n        }\n        if (date.getMinutes() > min) {\n            sleepMin = 60 - date.getMinutes() + min;\n        } else if (date.getMinutes() == min) {\n            if (date.getSeconds() < sec) {\n                sleepMin = 0;\n            } else {\n                sleepMin = 60;\n            }\n        } else {\n            sleepMin = min - date.getMinutes();\n        }\n        if (date.getHours() > hour) {\n            sleepHour = 24 - date.getHours() + hour;\n        } else if (date.getHours() == hour) {\n            if (date.getMinutes() < min) {\n                sleepHour = 0;\n            } else {\n                sleepHour = 24;\n            }\n        } else {\n            sleepHour = hour - date.getHours();\n        }\n        if (sleepHour > 0) {\n            sleepHour--;\n        }\n        if (sleepMin > 0) {\n            sleepMin--;\n        }\n        let message = \"休眠\" + sleepHour + \"小时\" + sleepMin + \"分钟\" + sleepSec + \"秒后运行\";\n        toast(message);\n        console.log(message);\n\n        sleep(sleepHour * 60 * 60 * 1000 + sleepMin * 60 * 1000 + sleepSec * 1000);\n\n\n\n        unlock();\n        //添加步数\n        addSteps();\n        //获取截图权限\n        getScreenCapturePermission();\n        //注册\"音量下键按下退出脚本\"事件\n        //var exit_event = registerExitEvent();\n        //等待退出事件子线程执行\n        //exit_event.waitFor();\n        //打开支付宝\n        openAlipay();\n        //进入蚂蚁森林\n        entranceAntForest();\n        lock();\n    }\n}\n```\n\n然后，我将上述代码打包成了app。如下图。\n\n{% asset_img 2.png %}\n\n# 二、Bug\n\n短时间后台运行，autojs是可以自动解锁完成一系列功能的。\n\n长时间后台运行，就不行了。即使你给了所有权限、自启动、电源无限制，也是没用的。这应该是高版本android对后台app的一些限制。\n\n我看网上说，用tasker，我也试了，跟autojs同样的问题。\n\n# 三、改进\n\n通过xposed edge pro添加定时任务，定时启动上述脚本app。然后脚本app再执行解锁、刷步数、收能量、锁屏一系列操作。\n\n{% asset_img 3.png %}\n\n# 四、致谢\n\n1. [蚂蚁森林自动收取能量](https://github.com/kwu130/Alipay)\n2. [云养鸡种树](https://www.52pojie.cn/thread-1105058-1-1.html)\n\n感谢以上大佬！","tags":["open","js"]},{"title":"批处理去掉pdf水印","url":"/blog/2020/automatic-watermark-removal/","content":"\n从网上下载了张宇36讲的pdf，但是被人打了水印。一家公众号打一个水印那种，很烦。\n\n<!--more-->\n\n# 步骤一、将pdf拆分成图片\n\n用`acrobat`打开指定的pdf，点击`另存为`，以jpg格式存储到桌面`1`文件夹内\n\n# 步骤二、用ps录制动作\n\n打开`ps`中的`窗口`下面的`动作`，然后创建一个新组，再在这个组下面，创建一个新动作。\n\n等待下面小红点亮了，就说明正在录制中了，可以对图片进行一系列操作。\n\n{% asset_img 1.png 录制动作 %}\n\n# 步骤三、ps批处理水印\n\n打开`ps`中的`文件`下面的`自动`，再点`批处理`。具体的设置，看下图\n\n{% asset_img 2.png 批处理 %}\n\n# 步骤四、将图片合成pdf\n\n打开`acrobat`中的`创建`，从`多个文件创建`，点击`合并`\n\n{% asset_img 3.png 合成pdf %}\n\n# 步骤五、优化pdf\n\n将合并的pdf，进行另存为，格式选择`(优化)*.pdf`。这过这种方式保存的pdf，原来的大小是400M，处理之后，是80兆，很爽的。\n\n{% asset_img 4.png 优化后 %}\n\n{% asset_img 5.png 效果 %}\n\n# 总结\n\nok！就完成了，但是步骤三跟步骤五是需要耗费大量时间的。\n\n当然，还有更便捷的方法，比方说，用`acrobat`的`pitstop`插件可以通过颜色删除水印、通过文字名称删除水印，功能很强大的，但是安装太麻烦了，还需要破解，懒得整了。\n\n等以后有需要，再弄吧。\n\n\n\n\n\n","tags":["ps","acrobat"]},{"title":"解析b站视频","url":"/blog/2019/bilibili-spider/","content":"\n在b站关注的up猪今天更新了一期古力娜扎的《穷哈》视频。\n\n当时正在食堂啃着掉渣饼，当着众人的面，笑喷好几次。连着刷了不下十次。所以想着下载下来，当做手机铃声，由此引发了长达3个小时的持久战！\n\n<!--more-->\n\n之前有过好几次，比方说我想听qq音乐的歌，`f12`，扒呗。我想看腾讯视频，`f12`，扒呗。\n今天关注的b站up猪[潮汕好男人](https://space.bilibili.com/19071708?from=search&seid=12913111618121640457)更新了一期[《【朱丹&古力娜扎】套马杆》](https://www.bilibili.com/video/av80713692)，当时正在啃着掉渣饼，顿时听魔性了。那就扒呗！\n\n但是试了好几次，包括`network`，都未能找到一个完整的视频请求地址，而且bilibili在播放过程中，是一直在持续加载名叫`.m4s`的文件，b站不像qq音乐，直接放出来一个完整的路径。\n\n这我就很头大了，整了半天也没整好。\n\n后来再`f12`里面发现了一串代码\n\n```html\n<video preload=\"auto\" src=\"blob:https://www.bilibili.com/ddf83596-7b09-469a-80b7-0fd14bd8f7dc\"></video>\n```\n\n发现src里面的文件打不开，后来百度了，点进去理解一下[blob:http](https://blog.csdn.net/xingyun89114/article/details/80699527)。\n\n后来实在没办法了，就想着用[Fiddler](https://blog.csdn.net/c406495762/article/details/76850843)，点进去，里面有`Fiddler`的安装过程，以及如何使用。\n\n那么如何用`Fiddler`获取`b站`的真实视频地址呢？\n\n1. 抓包\n2. Composer模拟请求\n3. execute执行\n4. 导出\n5. 保存\n\n详细过程，参考[这里](https://blog.csdn.net/Enderman_xiaohei/article/details/94718494)\n\n放张图吧！\n\n{% asset_img 穷哈.png 穷哈 %}\n\n> 总结：\n>\n> 通过今天扒b站视频这一过程，越来越发现自己的不足。作为一个未来的改变世界的程序员，代码写得垃圾不说，像什么网络通信协议这块，不懂的越来越多，小白菜，又菜又白。\n>\n> 鼓励一下自己：现在都马上了2109年了，学习的成本越来越低，门槛却越来越高，你怎能放纵你自己呢？发现不足，就赶紧去学习去！\n\n","tags":["spider"]},{"title":"字符占字节的问题","url":"/blog/2020/bytes-of-characters/","content":"\n今天在用数据库的时候，发现数据库中，一个汉字占了3个字节，不是2个吗？疑惑，就百度了一下\n\n<!--more-->\n\n之前在学习[io流](https://meethigher.top/blog/2019/file-and-io-stream/)的时候，以为一个汉字就占一个字节。\n\n其实那个是不对的，还需要考虑字符集编码的问题。所以，就不在原来的文章里改了，直接独立出来一篇，以便于能够记忆深刻。\n\n英文字母在不同字符集编码下所占字节数\n\n```html\n字节数 : 1;编码：GB2312\n\n字节数 : 1;编码：GBK\n\n字节数 : 1;编码：GB18030\n\n字节数 : 1;编码：ISO-8859-1\n\n字节数 : 1;编码：UTF-8\n\n字节数 : 4;编码：UTF-16\n\n字节数 : 2;编码：UTF-16BE\n\n字节数 : 2;编码：UTF-16LE\n```\n\n中文汉字在不同字符集编码下所占字节数\n\n```html\n字节数 : 2;编码：GB2312\n\n字节数 : 2;编码：GBK\n\n字节数 : 2;编码：GB18030\n\n字节数 : 1;编码：ISO-8859-1\n\n字节数 : 3;编码：UTF-8\n\n字节数 : 4;编码：UTF-16\n\n字节数 : 2;编码：UTF-16BE\n\n字节数 : 2;编码：UTF-16LE\n```\n\n[参考文章](https://blog.csdn.net/yaomingyang/article/details/79374209)","tags":["unicode"]},{"title":"那些年，帮助过我的博客们","url":"/blog/2020/blogs/","content":"\n这里面记载着，我从入门编程，到现在为止，那些出现过帮助过我的人的博客；也记录着我看过的电影之类。希望以后回顾起来，能有所感触吧\n\n口头感谢太过苍白，索性将它们放到这里，这会是陪伴我一生的财富\n\n我要让这些博客，见证我的成长\n\n<!--more-->\n\n这篇博客，我会时时更新的。\n\n# 优质博客\n\n上学期，由于软件工程老师的影响，让我养成了看大佬博客的习惯，然后经此发现自己的不足。也算是，我唯一的精神食粮。\n\n所以，我收集了很多有用的个人博客。足够用来消磨大量的时光了，哈哈！\n\n* [阮一峰的个人网站](http://www.ruanyifeng.com/blog/)\n* [张鑫旭](https://www.zhangxinxu.com/)\n* [汪磊的个人博客（我关注的第一个博客，我的首页就是仿照的汪老师的首页）](https://blog.zce.me/blog/)\n* [一个坏掉的番茄（我同学，很厉害的大佬）](https://tomotoes.com/blog/)\n* [闷道（记录一个大佬的成长经历，大佬14年的博客一直记录到现在，强烈推荐，这个大佬就是我未来努力的方向）](https://maintao.com/)\n* [DIYgod（b站HTML5视频播放器开源作者，很牛逼，有好多我要学习的地方，放在这里，时刻准备学习新技术）](https://diygod.me/)\n* [imba97（b站关注的js大佬）](https://imba97.cn/)\n* [孟坤（借鉴他的开源代码，写的我现在的音乐网站）](https://mkblog.cn/1562/)\n* [Mark（吾爱破解上认识的大佬，他写了我一直想写的一个签到系统，不过我还是想自己写）](https://www.quchao.net/)\n* [林深时见鹿（最近在摸索着如何在自己博客部署pwa时，在谷歌上发现的大佬，国科大研究僧哦~）](https://linwhitehat.github.io/Blog/archives/)\n* [吾爱破解](https://www.52pojie.cn/)\n* [毛若昕](https://maorx.cn/)\n* [闫少航](https://pc.shaohang.xin/)\n* [神话Q传（初中玩得入迷的wap游戏，当时因为没钱、又抠门、又想变得牛逼。用手机瞎鼓捣，误打误撞破解了神话客服的账号，以及一些区霸的号，原理就跟sql注入差不多吧，大概2010年。在某些区霸号里，我悄悄看了聊天记录，原来富人就连玩游戏都是能找到妹子啪啪的，羡慕嫉妒恨啊。一夜之间，我顿时从穷逼成了区霸，各种榜一，期间，也赚了不少小钱，这也让我对计算机编程产生了兴趣，尽管那时我还不会打字，家里没条件，不会玩电脑。后来神话倒闭了，这是一个大佬为了纪念，独立开发的，也是情怀吧，这个大佬也在我学习的过程中帮我解决过不少问题）](https://xuyuanwei.top/)\n* [meto的部落（借鉴了这个大佬写的开源音乐接口）](https://i-meto.com/)\n* [杨青的个人博客（我关注的第二个博客）](https://yangqq.com/)\n* [崔家华（学习抓包时，关注的）](https://cuijiahua.com/)\n* [子墨的博客（又是一个大佬！刚开始...我看他写的代码，就在想这小子挺装逼啊，越看越热血沸腾的。现在...哇，这是个大佬！）](https://blog.zimo.wiki/)\n* [苏乞儿（学习Android）](https://blog.suqir.xyz/)\n* [自由钢琴（如果你某天累了，来这里静静听几首钢琴曲）](https://www.autopiano.cn/)\n\n对我有帮助的优质博客，我会放到这里。这些博客里，记载着，各种大佬们的成长岁月。希望也能对你们有帮助。\n\n# 开发文档\n\n我自己经常用到的文档，不代表最新。\n\n> 很多老师不能解决的问题，完全可以在上面学明白。\n\n* [web文档](https://developer.mozilla.org/zh-CN/)\n* [javase文档](https://docs.oracle.com/en/java/javase/14/docs/api/java.base/module-summary.html)\n* [javaee文档](https://docs.oracle.com/javaee/7/api/toc.htm)\n* [php文档](https://www.php.net/manual/zh/)\n* [nodejs文档](https://nodejs.org/dist/latest-v12.x/docs/api/)\n* [tiobe编程语言排行](https://www.tiobe.com/tiobe-index/)\n* [数据库排行](https://db-engines.com/en/ranking)\n* [maven仓库](https://mvnrepository.com/)\n* [npmjs仓库](https://www.npmjs.com/)\n* [webpack文档](https://webpack.js.org/)\n\n# 招聘相关\n\n我碰到的一些招聘有关的，感觉比较靠谱的，我会把链接放到这里。毕竟我也是学生，这些东西，还是很关心的\n\n* [京东凹凸实验室（有很多开源的项目，感觉很牛逼，而且直接招聘的就是全栈工程师跟高级全栈工程师，我只能说，牛逼牛逼牛逼！）](https://aotu.io/join/)\n* [百度校园招聘](https://talent.baidu.com/external/baidu/campus.html)\n* [阿里巴巴（没地址，不过用过他们开源的一些库）](https://github.com/alibaba)\n* [智者四海技术有限公司](https://app.mokahr.com/apply/zhihu/3819#/)\n\n\n# 博客与我的故事\n\n> 这个部分，可以直接跳过。个人的一些牢骚，如果你要读，那么，给你放首轻音乐，静下心来读。\n>\n> chrome80+无法播放，因为chrome强制将静态资源http转https了，换个浏览器即可。\n\n<audio src=\"http://cdn.meethigher.top/media/windyhill.mp3\" style=\"height:30px\" controls loop></audio>\n\n2018年中旬，对于我来说，算是一个转折点吧。\n\n在2018年之前，我的整天时间都安排得满满当当的。\n\n那时候，网络流行一些鸡汤，大学生就要多参加活动，多做点兼职，多培养爱好，多去外面的世界看看。\n\n我也不例外，自然加入了其中的行列，我参加各种比赛，各种竞选，做过各种兼职，去过好多地方；为了培养爱好，我还学了刀画，并且外出卖画，卖画的时候，有个阿姨还要让她孩子跟我学画。后来，我又结交了女朋友，加了院里的ACM。那时的我，学习也还行（连续两学期专业成绩第一，数学英语专业课单科状元奖学金，外加省政府奖学金，校一奖学金），还爱参加活动，还有女朋友。那种日子，说实话，过得很潇洒。一切，都那么近乎完美。\n\n在2018年之后，由于家庭原因、经济原因，种种原因，我跟她分了手。那段日子，我过得很消沉。基本上天天睡觉，课也不想好好上了，活动也不参加了，反正，我一切与外界的联系都断了。就天天躺着睡觉，那一段日子，让我消停了下来，好好思考自己的人生。\n\n事实证明，一切活动，一切任务，没有我的出席同样运转得很好。我经营了那么久的圈子，经营了那一年的感情，到了最后，只是徒增一段伤感的记忆罢了。\n\n一种心里看不到底的空虚感，油然而生。我就开始思考，那我活着的意义是什么呢，我又会什么呢？\n\n我拿过奖学金，一堆奖学金证书。到目前为止，我已经拿了一万二左右了（只是奖学金，我并没有申请助学金，我妈说我家条件不穷，没必要去争那名额）。\n\n但仔细回想起来，哪怕是奖学金，哪怕是那些证书，水分都是那么多。当年评省政府，我的智育成绩（智育第一）加德育成绩总评专业第一，跟我竞争有个专业第八的女生。导员，召集我俩，就直接问我（没问她），你觉得你拿这个奖学金，合适吗？我拿出院里公示的成绩单，成绩铁证一般放在那里，结果导员说，这不重要，重要的是你觉得自己合适吗。凭什么不合适。下一年的评选，我同样有资格竞选，但我也不想再看那狗导员的脸色。那一天，我没参加导员开的全院大会；那一年，我也没拿奖学金。\n\n那可是钱啊，钱都不要？别人看我像是奇葩。我不喜欢看狗导员脸色，就这么简单。有种人，活在世上，自有傲骨。\n\n说到那个狗导员，也挺有意思。之前我班班长实习，撂挑子，没人管班里的事，我看大家没人管，我就想着我就管管吧。我这个管，是没好处的，琐事是我处理的，但是德育分依旧是给班长加分。说白了，我就是个干活的。有一次，我自己也很忙，开会就去晚了。狗导员说，小陈啊，你说我给了你那么多好处，你给我干点活咋滴了？我顿时火冒三丈，你给了我啥好处？第二次评选省政府，老子可是直接弃权了；第一次评省政府，我不管智育还是德育都是第一，总评也是第一。那是你给我的？之后，我就直接不干了，回寝室舒舒服服写代码，导员给我打电话，直接挂了，导员又找别的班干部找我，不理。过了两天，导员又来电话了，小陈啊，你最近忙什么呢，不接我电话。我说，我写代码呢，很忙。然后挂了。\n\n不能圆滑地为人处世，那就做技术做得牛逼，这样告诫自己。\n\n作为一个专业是计算机的学生，编程方面，我好像也并不擅长，学校什么都教，c，c#，java，android，python，html，css，javascript，jsp，asp，php，sqlserver，mysql，真的是什么都教，但是什么都不深入。像当时，我们课程设计，要做管理系统，我都是从网上找，自己改，然后就作为自己的了。\n\n就开始想象毕业以后的情形，我能干什么，我会干什么。好像做什么都不行。\n\n于是，就开始学习，学编程。放弃了一堆不太现实的东西，退了刚加了两个月的ACM，因为我深知自己是个菜逼，学长学姐都很厉害，我在里面只是拖后腿而已。\n\n那时候，我不知道，怎么学，网上搜的视频的质量也不行（那时候看慕课，还有百度传课，都讲得乱七八糟。现在发现个人博客才是野生人才的聚集地，其次是b站）。后来机缘巧合，我看了汪磊老师的php，他的性格很对我胃口，他常说的话，“代码是一种艺术”，“代码来源于生活，并服务于生活”，更打动我。从他那里，我领会到，编程并不只是为了实现需求，通过编程，能享受其中对自己精神的提升，就像写了一首诗一样，能够让别人也体会到这首诗的魅力，这是一种境界。于是，我加了他的IT群，又找到了他12年还在上学时写的博客。我遇到了对的领路者。也就关注了他的博客，这是我第一个关注的博客——[汪磊的个人博客](https://blog.zce.me/blog/)。\n\n那段时间，天天泡图书馆敲代码。有个同学跟我一块，因为他要用我的插排，慢慢地，我俩晚上回寝的时候，就一起走，他就给我推荐学习的路线，如何如何学，他当时给我的感觉就是深醉于javascript不可自拨。按他的话说，“JavaScript不会有条条框框的，束缚我的思想”，那段时间，我就开始学js，当时他借了我一本红色的js工具书。后来又给我推荐了他学习的网站，也就是阮一峰跟张鑫旭，以及他自己的博客——[一个坏掉的番茄](https://tomotoes.com/blog/)。\n\n时间跳到2019年，我开始想写我的第一个博客，但是出于骨子里的自尊自傲，便不想用别人的主题，我就想自己写主题，当时参照着一篇博客，摸索着写。也就是这个博客——[闷道](https://maintao.com/)。\n\n这里面，记载着大佬从14年，到现在的点点滴滴。一度成为我下饭的点心，每次吃饭就读一篇，也让我读了很久。他的见识和能力，让我感到佩服。里面有很多观点，与我不谋而合，我感觉，我们是同类性格的人。\n\n随着我看的博客越来越多，读的文章也越来越多，我越能通过一个博客，看透这个作者的内在性格。是我们性格的相近，让我们在同一篇博客产生了共鸣。虽然，性格相似的人，并不适合做长久的朋友。但是，这样的博客，我会一直默默收藏下去的。他们自然不知道对我的精神帮助有多大，我也不会主动跟他们说，我有多感激他们。\n\n那么，经历了两年学习的我，现在是什么水平呢？我再也不用改别人的东西了，我所想实现的功能，完全是可以靠自己的双手创造出来，这时所产生的，是一种超高的成就感。\n\n那么，又如何为人处事呢？脚踏实地、少说一点废话，时刻保持谦逊的姿态，这便可以了。\n\n[关于爱情](https://meethigher.top/blog/2020/what-is-love/)，曾经有个问题，如果她不顾家里的反对，死心塌地跟着他，他会不会一直对她好。他的答案是否定的。也是从那之后，两人感情逐渐开始产生裂隙。现在的他还是啃老族，没钱、没权、没技术，未来还是很缥缈的，他又如何能向她画大饼呢？20出头，是一个女生最美好的年龄，也是一个男生一无所有的年纪。有时候，萝莉找大叔，也不无道理，你有我要的美貌，我有你爱的金钱。爱情，基本的生理需求满足之后所产生的的另一需求。一个人不会遇到真爱的另一个人，也不可能一辈子对另一个人专心。许许多多的人证明，这个结论是对的。我相信爱情，我相信她是阶段性的荷尔蒙产物。爱情最终的归宿是相依为命，但那时是否还存在爱情，恐怕只有经历过的人才懂。\n\n{% asset_img 1.png %}\n\n> 这段聊天记录，我保存了三年之久，为了激励自己努力上进。但是今天看来，我却感受不到动力了。\n>\n> 我可能会反问一句，你不缺胳膊少腿，为啥要养活你？\n>\n> 不得不感叹一下，年轻的时候，真的好单纯呢，那时候很多事，都会责怪是自己不够优秀\n\n至于大学生活，我也算是过来人。那些所谓的鸡汤读读当个乐子，外面的世界再大，你也得有一技之长能够立足；所谓的多条朋友路好走，那也得看你能为别人提供多少价值。大学的老师，有牛逼的，也有混日子的，但是你会发现，不论是何种老师，教给你的东西总是过时或者偏理论的，你需要知道何谓大学，大学的大，大在哪里？你需要做的，给自己定个长久的目标，每天一点一点地朝前努力、进步，生活简单、精神富足，这就足够了。\n\n我现在的目标，是能够创造出一些东西，并且开源，分享给所有的爱好者。只求余生能够过得开心，每天都能有小小的收获，这就行了。\n\n如果某天，有一个人，心里默默地感谢我曾经帮助过他；就像现在的我一样，感谢他们一样。那我，就很开心了。\n\n","tags":["life","blog"]},{"title":"记录实现socket聊天室的过程","url":"/blog/2020/chat-room/","content":"\n今天用Tim聊天的时候，突然意识到，好像这个聊天功能，无非就是服务端和客户端不断进行交互的过程。\n\n想做，那就做呗！\n\n<!--more-->\n\n整了一天，思路写得乱七八糟，最后把所有代码推翻重写。\n\n为了让思路能够清晰一点，还特意把服务端跟客户端进行交互的过程图给画了下来。\n\n{% asset_img 服务端与客户端交互过程图.png 服务端与客户端交互过程图 %}\n\n最后，按着这个图，慢慢地研究出来了。\n\n附上效果图。\n\n{% asset_img 简易版聊天室.png 简易版聊天室 %}\n\n看上去很完美了吧！\n\n但是！\n\n如果此时有任意一个客户端退出，服务端就会报错`Connection reset`，出现这个问题，是因为客户端关闭了连接，但是此时的服务端，还在读取数据，由此导致了错误（我是这样理解的）。\n\n那么，如何让服务端判断客户端关闭连接了呢？并在客户端关闭的时候，加上一句提示`xxx退出聊天室`。\n\n360了一下，发现需要用到[java心跳](https://blog.csdn.net/yehui928186846/article/details/52667416)技术。\n\n我要去学啦（此时时间2020-1-5 20:43）\n\n发现根本不是心不心跳的问题（2020-1-7 21:14）\n\n今天终于整明白了。\n\n参考文章[关于客户端断开连接后服务器抛出异常Connection reset](https://blog.csdn.net/su20145104009/article/details/52863451)\n\n`java.net.SocketException:Connection reset`原因：\n\n客户端关闭后，socket断开了，但是服务器为客户端开启的线程还在执行。所以要处理一下异常。\n\n在为客户端开启的线程里面定义一个布尔型变量，isOnline=true，在为客户端监听时while(true)修改为while(isOnline)，如果出现异常，即客户端退出，isOnline赋值为false\n\n\n\n参考文章[socket客户端异常关闭，服务端解决方案](https://my.oschina.net/u/1787735/blog/1838174)\n\n`java.net.SocketException:Socket is closed`原因：\n\n服务端不知道客户端socket已经关闭，如果继续发送数据，可能导致发送如上关闭异常。如果有多个客户端长连接给服务端建立，异常处理不恰当的话，还可能引起下次发送异常关闭情况。\n\nsocket客户端端来之后，回调服务端socket，这时服务端发现输入流的长度为-1，这时首先需要关闭客户端socket，然后把该socket从发送列表中删除。\n\n具体解决方案：\n\n1. 检查是否断开\n\n```java\nif(in.read(b,0,len)==-1){\n    break;\n}\n```\n\n2. 关闭客户端socket并且移除发送客户端socket\n\n```java\ntry{\n    //关闭socket\n    //从列表中删除socket\n}catch(IOException e){\n    e.printStackTrace();\n}\n```\n\n最后的运行结果：\n\n{% asset_img 客户端之间通讯.png 客户端之间通讯 %}\n\n{% asset_img 用户退出通知.png 用户退出通知 %}\n\n[开源代码下载](https://github.com/meethigher/chat-room)\n\n","tags":["java"]},{"title":"记录一次养猫的经历","url":"/blog/2020/cat/","content":"\n今天下雨夹雪，猫窝渗水了，然后我家大猫自己跑了。小猫又冷又饿，死了。\n\n<!--more-->\n\n# 一、前言\n\n我家养过很多小动物。\n\n我尤其喜欢跟小动物打交道。\n\n我四五岁的时候，就跟小猪一块玩（我妈说的），白天跟着猪到处钻，晚上抱着猪睡觉。后来小猪死了，我甚至还哭了好久。\n\n之后，养过狗，养过羊，就是把他们当玩伴一样养。羊这种的，虽然也听话，但是还保留着一股傲气。你喂他，他就屁颠屁颠过来；但如果你跟他闹，他就不理你，是我见过最傲娇的动物了。所以，我后来就开始养狗了。舔狗舔狗嘛，一听就知道没脾气。\n\n我小学的时候，养了第一只狗。\n\n那是一只三条腿的黄狗，叫做旺旺。因为他三条腿的原因，不能看家，而且又丑，没人要，我妈问，你养他吗？我那时候，还没养过狗，但是看着他，就感觉他很懂我，我就说养。后来陪了我小学到初中，最后老死了。\n\n旺旺有一次特别感动我。\n\n我小的时候，放学回家，就要上山放羊，羡慕大叔大伯他们，都有一只猎犬陪着，照看羊群；而我家这只三条腿的狗子，我也不想累他。有一次，我放学回家，撵着一群羊上山，出门之后，狗子就跟了出来，我说你回去，然后他就回去，我一回头，他又跟上来了。那次，我就让他跟我上山，他也很高兴，只要有羊吃路边的庄稼，他就咬它。我很开心，这只狗子，真的懂我。那次放羊回家，已经晚上了，山路并不好走，狗子慢慢地就跟不上羊群了，我索性就抱着他回家，从山上到家，也得有40分钟路程，他一路很安静，也很听话。我看他，他就抬头看我，那种感觉，就是他懂我。\n\n过了三四年吧，他就老死了。\n\n我最后养的一只狗，也叫旺旺，因为他跟我的第一只旺旺很像，就同样唤作旺旺了。他陪伴我有6年之久，我当时上高中，后来又上大学，并没怎么好好陪他。\n\n我一共养了13只狗，每只狗，都有名字，都有故事，我也曾记在小本本上，可惜，小本本找不到了。\n\n最后那只旺旺，我还有照片。\n\n{% asset_img dog.jpg 旺旺 %}\n\n# 二、正文\n\n从那以后，我不再养狗了，因为，人的寿命太长，而狗的寿命太短，目送玩伴离去，是很难受的一件事。\n\n而且，我家养过的狗，都是拴着的，因为怕他跑。我后来也反思了，觉得自己太过分了。让狗子没了天性，这样不好。\n\n后来，机缘巧合之下，我家有了第一只猫，我姥姥家给的，唤作咪咪。\n\n{% asset_img cat2.jpg 咪咪 %}\n\n可能是出于之前对于狗子的内疚，我就没拴这只小猫。动物，还是有天性的好。\n\n她的天性，确实是完全释放出来了。有时候，领一只猫回家，有时候，领两三只猫回家。午夜时分，也闹得不轻，吵我睡觉。\n\n{% asset_img cat1.jpg 咪咪 %}\n\n3月31号那天，我家大猫生了，她给生到了我家放煤的地方。\n\n本来，想给猫换个窝的，但是我妈说，不要管她，她觉得地方不好，自然就会搬家。\n\n于是，日子就这样过下来了。\n\n猫坐月子的这几天，我也算是比较上心地照顾了。她刚坐月子的第一天，饿了，来门口要东西吃。我给她和面烙了一张大饼，面里掺满了肉沫，然后那张饼，她吃了两顿，全吃了。\n\n之后，每天都是有肉有饭，伙食跟我一样。家里炸的肉，喂她吃；我下面条的时候，也会掺点肉汤，分她一点。总之，我吃啥，她吃啥。\n\n有时候，她吃不了，就会领着一只公猫来我家吃，那只猫吃，她就坐旁边看。我猜应该是相好的，那就吃呗，我也不管。反正剩了的饭，我家猫也不吃，很挑剔，浪费可惜。\n\n今天，下了雨夹雪，气温一下子降到了零下。小猫一直在叫，我就去看了一眼，发现小猫的窝渗水了，大猫却不在家。另外两只比较大的，会动了，他们自己会挪地方，有一只小的眼睛还没睁开，趴的袋子上都是湿的，我就给他挪了窝。\n\n本来以为大猫可能出去玩了，晚点就回家，然后我晚上下课，大概8点吧，才发现，那只小的已经饿死了。\n\n我当时气得简直要喷火，当母亲，当成这样，那也是够差劲了。\n\n我就干脆把小猫移出窝子，搬到了屋里。百度了一下，像那种丢弃的小猫，喂羊奶能喂活。\n\n{% asset_img small-cat.jpg 小奶猫 %}\n\n我就直接出门去超市了，想着买点婴儿奶粉。当时还下着雨，乌漆嘛黑，这破农村，也没个灯，依旧是土路。\n\n连着跑了三个超市，跑了好几个村子，人家都关门了，下雪天，关门比较早。\n\n后来索性回到家里，看着这两只小猫，很气。养了这么久的猫，想不到是这么个玩意，自己的孩子都不管，杂种！\n\n妈说，你把他们搬屋里干嘛，你又养不活，你给放回去，她但凡想养小猫，自然会喂，不然，死了就死了，你不用管。\n\n我就给放回去了。\n\n# 三、后记\n\n网上看着那些刷宠物的视频，以及被带动了社会很多人要养宠物的念头，甚至为了让他们留在身边，做节育手术。\n\n我就觉得这种跟风很不好。\n\n虽然是宠物，但也是朋友，如果是这样养得话，真的能收获感情吗？我觉得答案是否定的。只不过一个是玩偶，一个是定时供食的机器而已。\n\n不管是人，或是动物，天性是很重要的一部分。\n\n之前我家养的狗子们，被我束缚得太多，有时候，我就会觉得，对他们有所亏欠，虽然我养活了他们，但是却让他们没了天性，终是我的不对。\n\n后来，我家养了这只猫，我就想让她活得天性散漫一点，然后，没想到是这样一只猫。而我所愧疚的，却是那两只小奶猫了。\n\n---\n\n现在距离上次的事，已经有18天了。小猫撑了三天，最后还是死了，大猫也终究还是没回家。我也不知道它是被人抓走了，还是自己跟野猫跑了。\n\n小猫就葬在了，我家屋顶上的菜园里。\n\n这么多天，坟头上已经长了野菜。\n\n{% asset_img 1.jpg 野菜 %}","tags":["life"]},{"title":"C考研算法题","url":"/blog/2020/c-algorithm/","content":"\n闲得没事刷的C语言的算法题。\n\n事在人为，为者终成，生死之外，又有什么事是办不到的？\n\n考研加油，吉大等我！好想体验一把在985 211读书的感觉啊\n\n<!--more-->\n\n> 每天看一遍，争取在理解思路的基础上背过\n\n# 1到100内的素数\n\n```c\n#include<stdio.h>\nint main(){\n    int flag=1;//用来判断是否是素数，\n    for(int i=2;i<=100;i++){\n        for(int j=2;j<i;j++){\n            if(i%j==0) {\n                flag=0;//如果不是负数，改成0\n                break;\n            }\n        }\n        if(flag==1){\n            printf(\"%d \",i);\n        }\n        flag=1;\n    }\n    return 0;\n}\n```\n\n# 分解质因数\n\n99=3x3x11\n\n```c\n#include<stdio.h>\n\n/**\n * 短除法分解质因法\n * 思路：\n * 输入n，k=2（最小的素数）\n * 1.从k开始除，若能整除，就输出该数，并将n赋值为n/k\n * 2.若不能整除，则k++，重新执行1步\n * 输出n\n * @return\n */\nint main() {\n    int n;\n    while (scanf(\"%d\", &n)) {\n        int k;\n        for (k = 2; k < n; k++) {\n            while (n != k) {\n                if (n % k == 0) {\n                    printf(\"%d*\", k);\n                    n = n / k;\n                } else\n                    break;\n            }\n        }\n        printf(\"%d\\n\", n);\n    }\n    return 0;\n}\n```\n\n# 一个数的约数\n\n20的正约数有：1、2、4、5、10、20。\n\n注意：一个数的约数必然包括1及其本身。\n\n```c\n#include <stdio.h>\nint main()\n{\n    int n;\n    while(scanf(\"%d\",&n)){\n        for(int i=1;i<n;i++){\n            if(n%i==0){\n                printf(\"%d、\",i);\n            }\n        }\n        printf(\"%d\\n\",n);\n    }\n    return 0;\n}\n```\n\n# 统计字母数字出现的个数\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int num = 0, upper = 0, lower = 0;\n    char s[20];\n    while (gets(s)) {\n        for (int i = 0; i < strlen(s); i++) {\n            if (s[i] >= 'a' && s[i] <= 'z') {\n                lower++;\n            }\n            if (s[i] >= 'A' && s[i] <= 'Z') {\n                upper++;\n            }\n            if (s[i] >= '0' && s[i] <= '9') {\n                num++;\n            }\n        }\n        printf(\"数字=%d,大写字母=%d,小写字母=%d\\n\", num, upper, lower);\n    }\n    return 0;\n}\n```\n\n# 统计正整数出现的次数\n\n例如\n\n输入<u>1,2,2,3,3,3,5,5,5,6</u>\n\n输出<u>0:0次 1:1次 2:2次 3:3次 4:0次 5:3次 6:1次 7:0次 8:0次 9:0次</u> \n\n```c\n#include <stdio.h>\n\nint main() {\n    int a[10] = {\n            1, 2, 2, 3, 3, 3, 5, 5, 5, 6\n    };\n    int b[10] = {0};\n    for (int i = 0; i < 10; i++) {\n        b[a[i]]++;\n    }\n    for (int i = 0; i < 10; i++) {\n        printf(\"%d:%d次 \", i, b[i]);\n    }\n    return 0;\n}\n```\n\n# 分解一个n位数\n\n输入333\n\n输出 300 30 3\n\n```c\n#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int n, i = 0;\n    int b[10] = {\n            0\n    };\n    scanf(\"%d\", &n);\n    while (n != 0) {\n        b[i] = n % 10;\n        n /= 10;\n        i++;\n    }\n    for (int j = 0; j < i; j++) {\n        printf(\"%d \", b[j] * (int) pow(10, i - j - 1));\n    }\n    return 0;\n}\n```\n\n# 俩数的最大公约数和最小公倍数\n\n最大公因数，也称最大公约数、最大公因子，指两个或多个整数共有约数中最大的一个。a，b的最大公约数记为（a，b），同样的，a，b，c的最大公约数记为（a，b，c），多个整数的最大公约数也有同样的记号。\n\n互质数为数学中的一种概念，即两个或多个整数的公因数只有1的非零自然数。公因数只有1的两个非零自然数，叫做互质数。\n\n约数，又称因数。整数a除以整数b(b≠0) 除得的商正好是整数而没有余数，我们就说a能被b整除，或b能整除a。a称为b的倍数，b称为a的约数。\n\n{% asset_img 1.png %}\n\n```c\n#include <stdio.h>\n\n/**\n * 最大公约数\n * Greatest Common Divisor\n * @param a\n * @param b\n * @return\n */\nint GCD(int a, int b) {\n    int temp;\n    if (a < b) {\n        temp = a;\n        a = b;\n        b = temp;\n    }\n    while (temp != 0) {\n        temp = a % b;\n        a = b;\n        b = temp;\n    }\n    return a;\n}\n\n/**\n * 最小公倍数\n * Least Common Multiple\n * @param a\n * @param b\n * @return\n */\nint LCM(int a, int b) {\n    for (int i = a; i > 0; i++) {\n        if (i % a == 0 && i % b == 0) {\n            return i;\n        }\n    }\n}\n\nint main() {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    printf(\"最大公约数：%d\", GCD(a, b));\n    printf(\"最小公倍数：%d\", LCM(a, b));\n    return 0;\n}\n```\n\n# 冒泡排序\n\n```c\n#include <stdio.h>\nint main(){\n    int a[10]={\n            1,9,8,7,6,5,4,3,2,10\n    };\n    int temp;\n    for(int i=0;i<10-1;i++){\n        for(int j=0;j<10-i-1;j++){\n            if(a[j]>a[j+1]){\n                temp=a[j+1];\n                a[j+1]=a[j];\n                a[j]=temp;\n            }\n        }\n    }\n    for(int i=0;i<10;i++){\n        printf(\"%d \",a[i]);\n    }\n    return 0;\n}\n```\n\n# 已排好序的数组插入一个数\n\n```c\n#include<stdio.h>\n\nint main() {\n    int a[11] = {\n            1, 2, 3, 3, 5, 6, 7, 8, 9, 10\n    };\n    int temp;\n    scanf(\"%d\", &temp);\n    for (int i = 9; i >= 0; i--) {\n        if (temp < a[i]) {\n            a[i + 1] = a[i];\n        } else {\n            a[i + 1] = temp;\n            break;\n        }\n    }\n    for (int i = 0; i < 11; i++) {\n        printf(\"%d \", a[i]);\n    }\n    return 0;\n}\n```\n\n# 数组奇偶数分类\n\n设计一个C语言函数，将整数数组a[n]划分为左右两部分，使左边所有元素值为奇数，右边所有元素值为偶数\n\n```c\n#include<stdio.h>\n\nvoid divide(int a[], int n) {\n    int i = 0, j = n - 1, temp;\n    while (i < j) {\n        //若是奇数，则自增\n        //若不是奇数，则执行下步的交换\n        while (a[i] % 2 != 0) {\n            i++;\n        }\n        //若是偶数，则自减\n        //若不是偶数，则执行下步的交换\n        while (a[j] % 2 != 1) {\n            j--;\n        }\n        //这是保证左边是奇数，右边偶数\n        if (i < j) {\n            temp = a[i];\n            a[i] = a[j];\n            a[j] = temp;\n        }\n    }\n    //为了帮助理解\n    printf(\"结束的i=%d,j=%d\\n\", i, j);\n    for (int k = 0; k < n; k++) {\n        printf(\"%d \", a[k]);\n    }\n}\n\nint main() {\n    int a[10] = {\n            1, 9, 1, 2, 9, 7, 5, 1, 9, 3\n    };\n    divide(a, 10);\n    return 0;\n}\n```\n\n# 数组逆序\n\n## 矩阵逆序\n\n设给定一个m行n列整型矩阵A，编写一个函数swap，使得它对A的元素进行交换，具体如下：第一个元素和倒数第一个元素交换，第二个元素和倒数第二个元素交换，在具体实现时，不允许另设矩阵。\n\n```c\n#include <stdio.h>\n\n#define m 3\n#define n 4\n\nvoid swap(int a[m][n]) {\n    int i, j, temp;\n    for (i = 0; i < m; i++) {\n        for (j = 0; j < n; j++) {\n            printf(\"%d \", a[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"================\\n\");\n\n    //关键代码\n    for (i = 0; i < m / 2; i++) {\n        for (j = 0; j < n; j++) {\n            temp = a[i][j];\n            a[i][j] = a[m - i - 1][n - j - 1];\n            a[m - i - 1][n - j - 1] = temp;\n        }\n    }\n    //如果不是奇数行的话，截止到上面部分的代码，就能完美实现该功能了。\n    //比如，是3行的话，3/2=1,那么数组就会在区间[0,1)取值，如果将区间改成闭区间，那么偶数行又会出问题，相当于换了一遍，又再换回去了。\n    //所以如果是奇数行的话，需要再加逻辑单独处理\n    if (m % 2 != 0) {\n        i = m / 2;\n        for (j = 0; j <= n / 2; j++) {\n            temp = a[i][j];\n            a[i][j] = a[m - i - 1][n - j - 1];\n            a[m - i - 1][n - j - 1] = temp;\n        }\n    }\n\n    //输出结果\n    for (i = 0; i < m; i++) {\n        for (j = 0; j < n; j++) {\n            printf(\"%d \", a[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main() {\n    int a[m][n] = {\n            0, 1, 2, 3,\n            10, 11, 12, 13,\n            20, 21, 22, 23\n    };\n    swap(a);\n    return 0;\n}\n```\n\n## 向量逆序\n\n已知在一维数组A[M+N]中，依次存放着两个向量{1,3,5,7,9}跟{2,4}，现要求将向量逆序，变成{2,4}和{1,3,5,7,9}\n\n```c\n#include <stdio.h>\n\n#define M 5\n#define N 2\n\nvoid reverse(int a[], int n) {\n    int i, temp;\n    for (i = 0; i < n / 2; i++) {\n        temp = a[i];\n        a[i] = a[n - 1 - i];\n        a[n - 1 - i] = temp;\n    }\n}\n\nint main() {\n    int i;\n    int a[M + N] = {\n            1, 3, 5, 7, 9, 2, 4\n    };\n    //将整个数组进行逆序\n    reverse(a, M + N);\n    //将前部分数组进行正序\n    reverse(a, N);\n    //将后部分数组进行正序\n    reverse(a + N, M);\n    \n    //输出验证结果\n    for (i = 0; i < M + N; i++) {\n        printf(\"%d \", a[i]);\n    }\n    return 0;\n}\n```\n\n## 奇偶数分类并排序\n\n有100个正整数存放在数组中，试编一函数，要求：\n\n1. 所有的奇数按从小到大的顺序存放在数组的前半部\n2. 所有的偶数按从小到大的顺序存放在数组的后半部\n\n例如：1,4,3,2,5,9,7\n\n输出：1,3,5,7,9,2,4\n\n```c\n#include <stdio.h>\n\n#define N 7\n\n/**\n * 对数组进行排序\n * @param a\n * @param n\n */\nvoid inOrder(int a[], int n) {\n    int temp;\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (a[j] > a[j + 1]) {\n                temp = a[j];\n                a[j] = a[j + 1];\n                a[j + 1] = temp;\n            }\n        }\n    }\n}\n\n/**\n * 对数组进行分类\n * 奇数放到左边，偶数放到左边\n * @param a\n * @param n\n */\nvoid sort(int a[], int n) {\n    int i = 0, j = n - 1;\n    int temp;\n    while (i < j) {\n        //如果是奇数，则后移\n        while (a[i] % 2 != 0) {\n            i++;\n        }\n        //如果是偶数，则前移\n        while (a[j] % 2 == 0) {\n            j--;\n        }\n        //奇偶数互换\n        if (i < j) {\n            temp = a[i];\n            a[i] = a[j];\n            a[j] = temp;\n        }\n    }\n    inOrder(a, i);\n    inOrder(a + i, n - i);\n}\n\n\nint main() {\n    int a[N] = {\n            1, 4, 3, 2, 5, 9, 7\n    };\n    sort(a, N);\n    for (int i = 0; i < N; i++) {\n        printf(\"%d \", a[i]);\n    }\n    return 0;\n}\n```\n\n","tags":["c","algorithm"]},{"title":"socket聊天室界面版","url":"/blog/2020/chat-room-updraded-version/","content":"\n明天就要回家咯，一点都不开心。我讨厌回家。\n\n不过还是先把这个升级版的程序做完吧。因为有若干bug，所以去掉了好多人性化的功能。主要是好多理论不太理解，还得学习啊！\n\n<!--more-->\n\n## 原理\n\n![原理](https://meethigher.top/blog/2020/01/07/chat-room/服务端与客户端交互过程图.png)\n\n原理上面那个图，描述的很详细了，不多赘述。\n\n## 实现\n\n* Server端\n  * ChatServer类：主要用来实现服务端的一些功能\n  * ChatServerRunnable类：实现Runnable接口，用来服务端收发消息\n  * ServerFrame类：服务端的界面类\n* Client端\n  * ChatClient类：用来实现客户端的一些功能\n  * STCRunnable类：实现Runnable接口，用来实现服务端向客户端下发消息\n  * CTSRunnable类：实现Runnable接口，用来实现客户端向服务端发送消息\n  * CheckIP类：通过正则表达式验证服务器ip地址是否正确\n  * ClientFrame类：客户端的界面类\n\n## 运行结果\n\n* 聊天功能\n\n  {% asset_img chat.png 聊天功能 %}\n\n* 用户退出提示 \n\n  {% asset_img exit.png 退出提示 %}\n\n## 具体过程\n\n[开源代码](https://github.com/meethigher/gui-chat-room/)","tags":["java"]},{"title":"迷茫","url":"/blog/2020/confused/","content":"\n最近琐事实在太多，干脆把琐事瞥在一边，打起了游戏\n\n<!--more-->\n\n最近，很烦。\n\n因为要准备考研，然后还有那么多破事处理。\n\n比方说，我们有个老师，是院长，他给我们说，网课效果不好，这学期不上了。结果，突然又来了老师补课。\n\n为啥呢？因为这个院长不给我们上课，期末总得考核吧？某些人就喜欢拍马屁呗。就找人帮忙把作业补上了。\n\n也就是说，我们没上课，没学东西，照样得写个万字报告出来，五个字，“老师，艹您妈”。\n\n混日子的老师，太多太多了。\n\n有个梗，这么说老师这个职业。\n\n> 大学女老师：我的主业是带娃，副业是上课。\n>\n> 大学男老师：我的主业是赚钱，副业是上课。\n\n很有意思，但是事实吧，我相信很多人都认同这个观点。\n\n就很难受，索性破罐子破摔，去尼玛的狗屁老师，不听课了。我下载了王者荣耀。\n\n王者荣耀这款游戏，说好玩不好玩，说不好玩吧，里面有些人挺有意思。\n\n我从昨天十点继承了s19段位，就一直打，到晚上晚上十点，单排上了20颗星，星耀二满星。今天从6点半打到9点多钟，王者了。\n\n耗时16小时，单排25星。\n\n星耀一满星时，截了个图。\n\n{% asset_img 1.png %}\n\n渡劫成功，又截了张图。\n\n{% asset_img 2.png %}\n\n期间，有不少趣事，有的忘记截屏了。\n\n趣事一：我连着两局碰到同一个小姐姐，每次都是她在我对面，第一局我玩婉儿，她玩小乔，我其实婉儿不太熟练，只会直着飞，所以就只能飞她咯，不然我没人头，队友以为我不会玩，心态崩了咋办，所以每次都是我越塔跟小乔同归于尽。小乔就生气了，开全部喷我，我就继续飞，最后他们输了，我的婉儿竟然有32%输出！！（其实全是杀的小乔的输出，哈哈）。然后下一局，又碰到上局小乔了，不过她改成玩辅助大乔了。大乔开全部，又是你，我记仇了。然后我开全部，这大乔是妹子，杀虞姬，抢大乔。你别说，队友真挺给力（一群单身死肥宅），有几个附和着发全部，杀虞姬，抢大乔。当着大乔面，越塔强杀了好几次虞姬。到了最后，估计是射手喷大乔了，大乔一直开着全部说对不起。。。我也是醉了，玩个游戏至于这么卑微吗，这妹子肯定游戏外，脾气也是贼好的。可惜，我赢了她两局，然后每局我还是mvp，这就尴尬了不。\n\n趣事二：木兰跟曜对线，我玩兰陵王打野，我一个buff刚打完，也就50秒的时候吧，我听到了“First Blood”，一看木兰头像变黑了。怒从心起，死菜b，然后我将菜b二字打到了公屏上。然后木兰就开始跟我对喷了，抢我的蓝buff，我呢，就疯狂吃他的兵线，也不抓人了，输，输就输呗，老子单排上星这么多年，差这颗星？我家鲁班也实在是牛逼，一个人发育起来了。对面过来打人的时候，木兰丝血，我就随手放了个二技能减速，对面没追上木兰，然后木兰发了个谢谢你。最后，赢的时候，木兰直接公屏发了句，谢谢爸爸。WTF？这么没骨气。我真的是，从为见过如此厚颜无耻之人！\n\n趣事三：今天早上6点开局，匹配到了俩妹子。然后她俩都要玩法师，谁都不让谁，一个3000场法师，其他的都不咋玩，一个1000场法师、1000场辅助，结果那个会玩辅助的一看，法师位没了，她也不要玩辅助，就学了李白（绿标），我这一看她就不会玩啊，就说“阿姨，你别送，我打野还能赢的”，然后她回“好的”。这就承认自己是阿姨了呗。哈哈哈哈，老阿姨。可惜最后我拿了个mvp，还是输了。\n\n> 一血：First Blood\n>\n> 双杀：Double Kill\n>\n> 三杀：Triple Kill\n>\n> 四杀：Quadra Kill\n>\n> 五杀：Penta Kill\n\ns16赛季的时候，我也试过单排玩小号，微信区韩信没铭文的情况下，单排112场到王者。我看一些大主播，打得那种转移号，最牛逼的一个叫念青的，是98场单排到王者，我112场，感觉也还行。当初还存了截图到处装逼，现在看起来贼幼稚。不过还是找到了一张。\n\n{% asset_img 3.png %}\n\n这是低星局，单排随便秀就行了，所谓的技术是跟你花的时间玩游戏成正比的，你玩得好，那是因为你熟练，对这个英雄的技能被动理解得透彻，是个人都行，而不是因为你牛逼。\n\n我主玩的三个英雄，韩信、狂铁、孙策，之前也拿过省标牌。\n\n好多人都说猴子克韩信，但是我用韩信碰到猴子的时候，看情况1级去反野，只要没人帮忙，必单杀猴子。韩信前期的被动，加攻速，而猴子一棍子要等5秒才行，单挑那不是找死。再如我用孙策打李白，李白大招落地的那一瞬间，我大招撞过去，接眩晕直接满血给他带走。还有孙策打虞姬，虞姬在放一技能结束的那一瞬间，直接大招撞他，他二技能免疫都按不出来就带走了。狂铁同理，只不过狂铁需要有个闪现和能量条。\n\n你玩得秀不秀，细不细节，源于你对英雄的理解。马超刚出的时候，好多人都说孙策打不过马超，我用孙策也单杀过省标马超，当然我也被马超单杀过。马超有大招和疾跑的时候，孙策先手，那肯定找死，其他时候，那孙策还是吊着打马超。英雄都有自己的一个弱势期，如何把握优势期，避免弱势期，这就决定了你玩的秀不秀，能否carry。\n\n**<u>这跟学习一个道理，你学得好，说明你对知识点理解得透彻，学不好，也不是因为你笨，你只是没去上心。说白了，你懒，不努力</u>**\n\n我刚玩游戏的时候，铂金到钻石，都要打一个月，死活上不去，现在，星星随便上，队友心态再崩，我都能带他飞。我单排的胜率，恐怕是很多平台大主播都没我高，单排不只看技术，还要看你这个人的心态。好多人都说，玩电竞需要天赋，我说，天赋的不足，可以通过你后天努力弥补。<u>**学习，一样。**</u>\n\n上荣耀的时候，我也试过单排，不太行，因为给你匹配的，都特么是多排的，你玩打野，野区被反爆了，人家都不理你，也不帮你。所以我单排到王者32星之后，就不打了。\n\n相对来说，排位水分很多，巅峰赛更能说明一个人的实力跟心态。\n\n**<u>很多人对我说，上王者好难啊，我回答，多玩</u>**。很简单的一个道理，有时候就容易当局者迷。**<u>学习一样啊，不会，多学，多做题，不就ok了。</u>**\n\n从下周开始，一周有三天要实训，做课程设计，会更烦了。无奈。\n\n只能自己把握时间吧。<u>**不会，就多学；不熟，就多做。朝死里做！游戏不也一样吗？**</u>，说得容易，身临其境的时候，是真的烦，一烦，就不想做了。\n\n很难，这对我来说，真的很难很难控制这种情绪，这就导致了我的迷茫。\n\n\n\n","tags":["life","game"]},{"title":"Collection单列集合、泛型","url":"/blog/2019/collection-set-and-generic/","content":"\n学习一下Collection单列集合，顺便了解一下泛型\n<!--more-->\n\n# 第一章 Collection集合\n\n## 1.1 集合概述\n\n已经学习过并使用过集合ArrayList<E> ,那么集合到底是什么呢?\n\n**集合**：集合是java中提供的一种容器，可以用来存储多个数据。\n\n集合和数组既然都是容器，它们有啥区别呢？\n\n* 数组的长度是固定的。集合的长度是可变的。\n* 数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。\n\n{% asset_img 集合框架层架关系图.png 集合框架层次关系图 %}\n\n## 1.2  集合框架\n\nJAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。\n\n集合按照其存储结构可以分为两大类，分别是单列集合`java.util.Collection`和双列集合`java.util.Map`，今天主要学习`Collection`集合，在day04时讲解`Map`集合。\n\n* **Collection**：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是`java.util.List`和`java.util.Set`。其中，`List`的特点是元素有序、元素可重复。`Set`的特点是元素无序，而且不可重复。`List`接口的主要实现类有`java.util.ArrayList`和`java.util.LinkedList`，`Set`接口的主要实现类有`java.util.HashSet`和`java.util.TreeSet`。\n\n从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。\n\n{% asset_img 集合框架介绍.png 集合框架的介绍 %}\n\n其中，橙色框里填写的都是接口类型，而蓝色框里填写的都是具体的实现类。这几天将针对图中所列举的集合类进行逐一地讲解。\n\n集合本身是一个工具，它存放在java.util包中。在`Collection`接口定义着单列集合框架中最最共性的内容。\n\n## 1.3 Collection 常用功能\n\nCollection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：\n\n* `public boolean add(E e)`：  把给定的对象添加到当前集合中 。\n* `public void clear()` :清空集合中所有的元素。\n* `public boolean remove(E e)`: 把给定的对象在当前集合中删除。\n* `public boolean contains(E e)`: 判断当前集合中是否包含给定的对象。\n* `public boolean isEmpty()`: 判断当前集合是否为空。\n* `public int size()`: 返回集合中元素的个数。\n* `public Object[] toArray()`: 把集合中的元素，存储到数组中。\n\n方法演示：\n\n~~~java\nimport java.util.ArrayList;\nimport java.util.Collection;\n\npublic class Demo1Collection {\n    public static void main(String[] args) {\n\t\t// 创建集合对象 \n    \t// 使用多态形式\n    \tCollection<String> coll = new ArrayList<String>();\n    \t// 使用方法\n    \t// 添加功能  boolean  add(String s)\n    \tcoll.add(\"小李广\");\n    \tcoll.add(\"扫地僧\");\n    \tcoll.add(\"石破天\");\n    \tSystem.out.println(coll);\n\n    \t// boolean contains(E e) 判断o是否在集合中存在\n    \tSystem.out.println(\"判断  扫地僧 是否在集合中\"+coll.contains(\"扫地僧\"));\n\n    \t//boolean remove(E e) 删除在集合中的o元素\n    \tSystem.out.println(\"删除石破天：\"+coll.remove(\"石破天\"));\n    \tSystem.out.println(\"操作之后集合中元素:\"+coll);\n    \t\n    \t// size() 集合中有几个元素\n\t\tSystem.out.println(\"集合中有\"+coll.size()+\"个元素\");\n\n\t\t// Object[] toArray()转换成一个Object数组\n    \tObject[] objects = coll.toArray();\n    \t// 遍历数组\n    \tfor (int i = 0; i < objects.length; i++) {\n\t\t\tSystem.out.println(objects[i]);\n\t\t}\n\n\t\t// void  clear() 清空集合\n\t\tcoll.clear();\n\t\tSystem.out.println(\"集合中内容为：\"+coll);\n\t\t// boolean  isEmpty()  判断是否为空\n\t\tSystem.out.println(coll.isEmpty());  \t\n\t}\n}\n~~~\n\n> tips: 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。\n\n# 第二章 Iterator迭代器\n\n## 2.1 Iterator接口\n\n在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口`java.util.Iterator`。`Iterator`接口也是Java集合中的一员，但它与`Collection`、`Map`接口有所不同，`Collection`接口与`Map`接口主要用于存储元素，而`Iterator`主要用于迭代访问（即遍历）`Collection`中的元素，因此`Iterator`对象也被称为迭代器。\n\n想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法：\n\n* `public Iterator iterator()`: 获取集合对应的迭代器，用来遍历集合中的元素的。\n\n下面介绍一下迭代的概念：\n\n* **迭代**：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。\n\nIterator接口的常用方法如下：\n\n* `public E next()`:返回迭代的下一个元素。\n* `public boolean hasNext()`:如果仍有元素可以迭代，则返回 true。\n\n接下来通过案例学习如何使用Iterator迭代集合中元素：\n\n~~~java\npublic class IteratorDemo {\n  \tpublic static void main(String[] args) {\n        // 使用多态方式 创建对象\n        Collection<String> coll = new ArrayList<String>();\n\n        // 添加元素到集合\n        coll.add(\"串串星人\");\n        coll.add(\"吐槽星人\");\n        coll.add(\"汪星人\");\n        //遍历\n        //使用迭代器 遍历   每个集合对象都有自己的迭代器\n        Iterator<String> it = coll.iterator();\n        //  泛型指的是 迭代出 元素的数据类型\n        while(it.hasNext()){ //判断是否有迭代元素\n            String s = it.next();//获取迭代出的元素\n            System.out.println(s);\n        }\n  \t}\n}\n~~~\n\n> tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。\n\n## 2.2 迭代器的实现原理\n\n在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。\n\nIterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程：\n\n{% asset_img 迭代器实现原理.png 迭代器实现原理 %}\n\n在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。\n\n## 2.3 增强for\n\n增强for循环(也称for each循环)是**JDK1.5**以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。\n\n格式：\n\n~~~java\nfor(元素的数据类型  变量 : Collection集合or数组){ \n  \t//写操作代码\n}\n~~~\n\n它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。\n\n#### 练习1：遍历数组\n\n~~~java\npublic class NBForDemo1 {\n    public static void main(String[] args) {\n\t\tint[] arr = {3,5,6,87};\n       \t//使用增强for遍历数组\n\t\tfor(int a : arr){//a代表数组中的每个元素\n\t\t\tSystem.out.println(a);\n\t\t}\n\t}\n}\n~~~\n\n#### 练习2:遍历集合\n\n~~~java\npublic class NBFor {\n    public static void main(String[] args) {        \n    \tCollection<String> coll = new ArrayList<String>();\n    \tcoll.add(\"小河神\");\n    \tcoll.add(\"老河神\");\n    \tcoll.add(\"神婆\");\n    \t//使用增强for遍历\n    \tfor(String s :coll){//接收变量s代表 代表被遍历到的集合元素\n    \t\tSystem.out.println(s);\n    \t}\n\t}\n}\n~~~\n\n> tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。\n\n\n\n# 第三章 List接口\n\n学习Collection中的常用几个子类（`java.util.List`集合、`java.util.Set`集合）。\n\n## 3.1 List接口介绍\n\n`java.util.List`接口继承自`Collection`接口，是单列集合的一个重要分支，习惯性地会将实现了`List`接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。\n\n看完API，总结一下：\n\nList接口特点：\n\n1. 它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。\n2. 它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。\n3. 集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。\n\n> tips: List接口的子类java.util.ArrayList类，该类中的方法都是来自List中定义。\n\n## 3.2 List接口中常用方法\n\nList作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下：\n\n- `public void add(int index, E element)`: 将指定的元素，添加到该集合中的指定位置上。\n- `public E get(int index)`:返回集合中指定位置的元素。\n- `public E remove(int index)`: 移除列表中指定位置的元素, 返回的是被移除的元素。\n- `public E set(int index, E element)`:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。\n\nList集合特有的方法都是跟索引相关.\n\n```java\npublic class ListDemo {\n    public static void main(String[] args) {\n\t\t// 创建List集合对象\n    \tList<String> list = new ArrayList<String>();\n    \t\n    \t// 往 尾部添加 指定元素\n    \tlist.add(\"图图\");\n    \tlist.add(\"小美\");\n    \tlist.add(\"不高兴\");\n    \t\n    \tSystem.out.println(list);\n    \t// add(int index,String s) 往指定位置添加\n    \tlist.add(1,\"没头脑\");\n    \t\n    \tSystem.out.println(list);\n    \t// String remove(int index) 删除指定位置元素  返回被删除元素\n    \t// 删除索引位置为2的元素 \n    \tSystem.out.println(\"删除索引位置为2的元素\");\n    \tSystem.out.println(list.remove(2));\n    \t\n    \tSystem.out.println(list);\n    \t\n    \t// String set(int index,String s)\n    \t// 在指定位置 进行 元素替代（改） \n    \t// 修改指定位置元素\n    \tlist.set(0, \"三毛\");\n    \tSystem.out.println(list);\n    \t\n    \t// String get(int index)  获取指定位置元素\n    \t\n    \t// 跟size() 方法一起用  来 遍历的 \n    \tfor(int i = 0;i<list.size();i++){\n    \t\tSystem.out.println(list.get(i));\n    \t}\n    \t//还可以使用增强for\n    \tfor (String string : list) {\n\t\t\tSystem.out.println(string);\n\t\t}  \t\n\t}\n}\n```\n\n# 第四章 List的子类\n\n## 4.1 ArrayList集合\n\n`java.util.ArrayList`集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以`ArrayList`是最常用的集合。\n\n许多程序员开发时非常随意地使用ArrayList完成任何需求，并不严谨，这种用法是不提倡的。\n\n## 4.2 LinkedList集合\n\n`java.util.LinkedList`集合数据存储的结构是链表结构。方便元素添加、删除的集合。\n\n> LinkedList是一个双向链表，那么双向链表是什么样子的呢，\n\n看图这个解下et_img 双向链表.png 双向链表 %}\n\n实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法作为了解即可：\n\n* `public void addFirst(E e)`:将指定元素插入此列表的开头。\n* `public void addLast(E e)`:将指定元素添加到此列表的结尾。\n* `public E getFirst()`:返回此列表的第一个元素。\n* `public E getLast()`:返回此列表的最后一个元素。\n* `public E removeFirst()`:移除并返回此列表的第一个元素。\n* `public E removeLast()`:移除并返回此列表的最后一个元素。\n* `public E pop()`:从此列表所表示的堆栈处弹出一个元素。\n* `public void push(E e)`:将元素推入此列表所表示的堆栈。\n* `public boolean isEmpty()`：如果列表不包含元素，则返回true。\n\nLinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。（了解即可）\n\n方法演示：\n\n~~~java\npublic class LinkedListDemo {\n    public static void main(String[] args) {\n        LinkedList<String> link = new LinkedList<String>();\n        //添加元素\n        link.addFirst(\"abc1\");\n        link.addFirst(\"abc2\");\n        link.addFirst(\"abc3\");\n        System.out.println(link);\n        // 获取元素\n        System.out.println(link.getFirst());\n        System.out.println(link.getLast());\n        // 删除元素\n        System.out.println(link.removeFirst());\n        System.out.println(link.removeLast());\n\n        while (!link.isEmpty()) { //判断集合是否为空\n            System.out.println(link.pop()); //弹出集合中的栈顶元素\n        }\n\n        System.out.println(link);\n    }\n}\n~~~\n\n# 第五章 Set接口\n\n`java.util.Set`接口和`java.util.List`接口一样，同样继承自`Collection`接口，它与`Collection`接口中的方法基本一致，并没有对`Collection`接口进行功能上的扩充，只是比`Collection`接口更加严格了。与`List`接口不同的是，`Set`接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。\n\n`Set`集合有多个子类，这里介绍其中的`java.util.HashSet`、`java.util.LinkedHashSet`这两个集合。\n\n> tips:Set集合取出元素的方式可以采用：迭代器、增强for。\n\n## 5.1 HashSet集合介绍\n\n`java.util.HashSet`是`Set`接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)。`java.util.HashSet`底层的实现其实是一个`java.util.HashMap`支持，由于暂时还未学习，先做了解。\n\n`HashSet`是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：`hashCode`与`equals`方法。\n\n先来使用一下Set集合存储，看下现象，再进行原理的讲解:\n\n~~~java\npublic class HashSetDemo {\n    public static void main(String[] args) {\n        //创建 Set集合\n        HashSet<String>  set = new HashSet<String>();\n\n        //添加元素\n        set.add(new String(\"cba\"));\n        set.add(\"abc\");\n        set.add(\"bac\"); \n        set.add(\"cba\");  \n        //遍历\n        for (String name : set) {\n            System.out.println(name);\n        }\n    }\n}\n~~~\n\n输出结果如下，说明集合中不能存储重复元素：\n\n~~~text\ncba\nabc\nbac\n~~~\n\n> tips:根据结果发现字符串\"cba\"只存储了一个，也就是说重复的元素set集合不存储。\n\n## 5.2 哈希值\n\n哈希值：是一个十进制的整数，由系统随机给出（就是对象的地址值，是一个逻辑地址，是模拟出来的地址，不是数据实际存储的物理地址）\n\n在Object类有方法hashCode()，可以获取对象的哈希值\n\n源码：\n\n```java\npublic native int hashCode();\n//native 代表该方法调用的是本地操作系统的方法\n```\n\n例子：\n\n```java\npackage demo23;\n\n/*\n * 哈希值：是一个十进制的整数，由系统随机给出（就是对象的地址值，是一个逻辑地址，是模拟出来的地址，不是数据实际存储的物理地址）\n * 在Object类有方法hashCode()，可以获取对象的哈希值\n * 源码：\n * public native int hashCode(); \n * native代表该方法调用的是本地操作系统的方法\n */\nclass Person /* extends Object */ {\n\t//重写hashCode方法\n\t@Override\n\tpublic int hashCode() {\n\t\treturn 1;\n\t}\n}\npublic class Demo04HashCode {\n\tpublic static void main(String[] args) {\n\t\tPerson p=new Person();\n\t\tSystem.out.println(p);\n\t\tSystem.out.println(p.hashCode());//664740647\n\t\t\n\t\tPerson p2=new Person();\n\t\tSystem.out.println(p2.hashCode());//804564176\n\t\tSystem.out.println(Integer.toHexString(p2.hashCode()));//2ff4acd0\n\t\tSystem.out.println(p2);//demo23.Person@2ff4acd0\n\t\tSystem.out.println(p==p2);//false\n\t\t//上面的是未重写方法之前\n\t\tSystem.out.println(\"==========================================\");\n\t\t//此处已经将hashCode()更改为返回值为1，但是p==p2还是false\n\t\tSystem.out.println(p==p2);\n\t\tSystem.out.println(p.hashCode()==p2.hashCode());\n\t\t/*\n\t\t * String类的哈希值\n\t\t *  String类也重写了Object类的hashCode方法\n\t\t */\n\t\tSystem.out.println(\"123\".hashCode());//48690\n\t\tSystem.out.println(\"重地\".hashCode());//1179395\n\t\tSystem.out.println(\"通话\".hashCode());//1179395\n\t\tSystem.out.println(\"334\".hashCode());//50644\n\t\t \n\t}\n}\n```\n\n像`重地`和`通话`这样的，哈希值是一样的，叫做`哈希冲突`\n\n> 哈希冲突：两个元素不同，但是哈希值相同。\n\n## 5.3  HashSet集合存储数据的结构（哈希表）\n\n什么是哈希表呢？\n\n在**JDK1.8**之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。\n\n**JDK1.8**（包括jdk1.8之后）中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样**大大减少了查找时间。**\n\n简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。\n\n{% asset_img 哈希表.png 哈希表 %}\n\n看到这张图就有人要问了，这个是怎么存储的呢？\n\n为了方便大家的理解结合一个存储流程图来说明一下：\n\n{% asset_img 哈希流程图.png 哈希流程图 %}\n\n总而言之，**JDK1.8**引入红黑树大程度优化了HashMap的性能，那么对于来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。\n\n## 5.4 Set集合存储元素不重复的原理\n\n```java\npublic static void main(String[] args) {\n\t\tHashSet<String> set=new HashSet();\n\t\tString s1=new String(\"abc\");\n\t\tString s2=new String(\"abc\");\n\t\tset.add(s1);\n\t\tset.add(s2);\n\t\tset.add(\"重地\");\n\t\tset.add(\"通话\");\n\t\tSystem.out.println(set);//重地，通话，abc\n}\n```\n\n{% asset_img HashSet.png HashSet %}\n\n存储过程：\n\n在add方法中，会调用s1的hashCode方法，计算字符串`\"abc\"`的哈希值，哈希值是`96354`，在集合中找，有没有`96354`这个哈希值的元素，发现没有，就会把s1存储到集合中\n\n在add方法中，会调用s2的hashCode方法，计算字符串`\"abc\"`的哈希值，哈希值是`96354`，在集合中找，有没有`96354`这个哈希值的元素，发现有，发生哈希冲突，`s2`调用equals方法和哈希值相同的元素进行比较，`s2.equals(s1)`，返回`true`；\n两个元素的哈希值相同，`equals`方法返回`true`，认定两个元素相同。就不会把`s2`存储到集合中。\n\n在add方法中，会调用\"重地\"的hashCode方法，计算字符串`\"重地\"`的哈希值，哈希值是`1139395`，在集合中找，有没有`1139395`这个哈希值的元素，发现没有，就会把`\"重地\"`存储到集合中\n\n在add方法中，会调用\"通话\"的hashCode方法，计算字符串`\"通话\"`的哈希值，哈希值是`1139395`，在集合中找，有没有`1139395`这个哈希值的元素，发现有，发生哈希冲突，`\"通话\"`调用`equals`方法和哈希值相同的元素进行比较，`s2.equals(\"重地\")`，返回`false`；\n两个元素的哈希值相同，`equals`方法返回`false`，认定两个元素不同。就会把`\"通话\"`存储到集合中。\n\n## 5.5  HashSet存储自定义类型元素\n\n给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一\n\n```java\npackage demo23;\n\nimport java.util.HashSet;\n\n/*\n * HashSet存储自定义元素\n * set集合报错元素唯一：\n * 存储的元素(String,Integer,...Student,Person)，必须重写hashCode方法和equals方法\n * 要求：\n * 同名和同年龄的人，视为同一个人，只能存储一次\n */\nclass People {\n\tprivate String name;\n\tprivate int age;\n\n\tpublic People() {\n\t}\n\n\tpublic People(String name, int age) {\n\t\tsuper();\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n\n\t// 下面这三个重写方法，都是eclipse自动生成的\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"People [name=\" + name + \", age=\" + age + \"]\";\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + age;\n\t\tresult = prime * result + ((name == null) ? 0 : name.hashCode());\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tPeople other = (People) obj;\n\t\tif (age != other.age)\n\t\t\treturn false;\n\t\tif (name == null) {\n\t\t\tif (other.name != null)\n\t\t\t\treturn false;\n\t\t} else if (!name.equals(other.name))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n}\n\npublic class Demo06HashSetSavePerson {\n\tpublic static void main(String[] args) {\n\t\tHashSet<People> set = new HashSet<>();\n\t\tPeople p1 = new People(\"水冰儿\", 18);\n\t\tPeople p2 = new People(\"水冰儿\", 19);\n\t\tPeople p3 = new People(\"水冰儿\", 18);\n\t\tSystem.out.println(p1.hashCode());\n\t\tSystem.out.println(p2.hashCode());\n\t\tSystem.out.println(p3.hashCode());\n\t\tSystem.out.println(p1 == p3);// false\n\t\tSystem.out.println(p1.equals(p3));// false\n\t\tset.add(p1);\n\t\tset.add(p2);\n\t\tset.add(p3);\n\t\tSystem.out.println(set);\n\t}\n}\n\n```\n\n输出结果\n\n```txt\n27290290\n27290321\n27290290\nfalse\ntrue\n[People [name=水冰儿, age=19], People [name=水冰儿, age=18]]\n```\n\n## 5.6 LinkedHashSet\n\n`java.util.LinkedHashSet` 继承自于 `HashSet集合`\n\n特点：\n\n底层是一个哈希表（数组+链表+红黑树）+链表——**多了一条链表，用来记录元素的存储顺序，保证元素有序。**\n\n演示代码如下:\n\n~~~java\npackage demo23;\n\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\n\n/*\n * java.util.linkedHashSet extends HashSet集合\n * 特点：\n * 底层是一个哈希表（数组+链表+红黑树）+链表：多了一条链表，用来记录元素的存储顺序，保证元素有序\n */\npublic class Demo07LinkedHashSet {\n\tpublic static void main(String[] args) {\n\t\tHashSet<String> set = new HashSet<>();\n\t\tset.add(\"焰灵姬\");\n\t\tset.add(\"妙妙\");\n\t\tset.add(\"水冰儿\");\n\t\tset.add(\"水冰儿\");\n\t\tSystem.out.println(set);// 无序，并且不允许重复\n        //运行结果：[焰灵姬, 水冰儿, 妙妙]\n\n\t\tLinkedHashSet<String> linkedset = new LinkedHashSet<>();\n\t\tlinkedset.add(\"焰灵姬\");\n\t\tlinkedset.add(\"妙妙\");\n\t\tlinkedset.add(\"水冰儿\");\n\t\tlinkedset.add(\"水冰儿\");\n\t\tSystem.out.println(linkedset);// 按照添加进去的顺序。有序的，并且不允许重复\n        //运行结果：[焰灵姬, 妙妙, 水冰儿]\n\n\t}\n}\n\n~~~\n\n## 5.7  可变参数\n\n**可变参数：**`jdk1.5`之后出现的新特性。\n\n**使用前提：**\n\n当方法的参数列表的数据类型已经确定，参数的个数不确定，就可以使用可变参数。\n\n**使用格式：**\n\n```java\n定义方法时使用\n修饰符 返回值类型 方法名(数据类型...变量名){}\n```\n\n其实这个书写完全等价于\n\n```java\n修饰符 返回值类型 方法名(数据类型[] 变量名){}\n```\n\n**可变参数原理：**\n\n可变参数底层就是一个数组，根据传递的参数个数不同，会创建不同长度的数组，来存储这些参数。\n\n传递的参数个数可以是0个或者多个。\n\n**代码演示：**\n\n```java\npublic class Demo {\n    public static int add(int...arr){\n        //定义一个初始化的变量，记录累加和\n        int sum=0;\n        //遍历数组，获取数组中的每个元素\n        for(int i:arr){\n            sum+=i;\n        }\n        return sum;\n    }\n    public static void main(String[] args){\n        int i=add(10,11);\n        System.out.println(i);\n    }\n}\n```\n\n**可变参数的注意事项：**\n\n1. 一个方法的参数列表，只能有一个可变参数\n2. 如果方法的参数有多个，那么可变参数必须写在参数列表的末尾\n\n**可变参数更高级的写法：**\n\n```java\npublic static void methodFinal(Object obj){}//可以接受任意类型的参数\n```\n\n# 第六章 Collections\n\n## 6.1 常用功能\n\n* `java.utils.Collections`是集合工具类，用来对集合进行操作。部分方法如下：\n\n- `public static <T> boolean addAll(Collection<T> c, T... elements)  `:往集合中添加一些元素。\n- `public static void shuffle(List<?> list) 打乱顺序`:打乱集合顺序。\n- `public static <T> void sort(List<T> list)`:将集合中元素按照默认规则排序。\n- `public static <T> void sort(List<T> list，Comparator<? super T> )`:将集合中元素按照指定规则排序。\n\n代码演示：\n\n```java\npublic class CollectionsDemo {\n    public static void main(String[] args) {\n        ArrayList<Integer> list = new ArrayList<Integer>();\n        //原来写法\n        //list.add(12);\n        //list.add(14);\n        //list.add(15);\n        //list.add(1000);\n        //采用工具类 完成 往集合中添加元素  \n        Collections.addAll(list, 5, 222, 1，2);\n        System.out.println(list);\n        //排序方法 \n        Collections.sort(list);\n        System.out.println(list);\n    }\n}\n结果：\n[5, 222, 1, 2]\n[1, 2, 5, 222]\n```\n\n代码演示之后 ，发现的集合按照顺序进行了排列，可是这样的顺序是采用默认的顺序，如果想要指定顺序那该怎么办呢？\n\n发现还有个方法没有讲，`public static <T> void sort(List<T> list，Comparator<? super T> )`:将集合中元素按照指定规则排序。接下来讲解一下指定规则的排列。\n\n## 6.2 Comparable自然排序\n\n**sort(List<T> list)的使用前提：**\n\n被排序的集合里面存储的元素，必须实现`Comparable`，重写接口中的方法`CompareTo`的定义排序的规则\n\n**Comparable接口的排序规则：**\n\n* this-参数——升序\n* 参数-this——降序\n\n**代码演示：**\n\n```java\npackage demo24;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\n\nclass Person implements Comparable<Person> {\n\tprivate String name;\n\tprivate int age;\n\tpublic Person() {\n\t\t\n\t}\n\tpublic Person(String name,int age) {\n\t\tthis.name=name;\n\t\tthis.age=age;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Person [name=\" + name + \", age=\" + age + \"]\";\n\t}\n\t//重写排序的规则\n\t@Override\n\tpublic int compareTo(Person o) {\n\t\t// TODO Auto-generated method stub\n//\t\treturn 0;//默认返回0，意思是认为元素都是相同的。\n\t\t\n\t\t//自定义规则，比较两个人的年龄——this指调用这个方法的\n\t\treturn o.getAge()-this.getAge();//按照年龄降序排序\n\t}\n\t\n}\npublic class Demo02Sort {\n\tpublic static void main(String[] args) {\n\t\tArrayList<String> list=new ArrayList<>();\n\t\tlist.add(\"b\");\n\t\tlist.add(\"c\");\n\t\tlist.add(\"a\");\n\t\t\n\t\tSystem.out.println(list);\n\t\tCollections.sort(list);\n\t\tSystem.out.println(list);\n\t\t\n\t\tArrayList<Integer> list01=new ArrayList<>();\n\t\tlist01.add(1);\n\t\tlist01.add(3);\n\t\tlist01.add(2);\n\t\tSystem.out.println(list01);\n\t\tCollections.sort(list01);\n\t\tSystem.out.println(list01);\n\t\t/*\n\t\t * 注意：\n\t\t * sort(List<T> list)的使用前提——被排序的集合里面存储的元素，必须实现Comparable，重写接口中的方法CompareTo的定义\n\t\t * 排序的规则\n\t\t * \n\t\t * Comparable接口的排序规则：\n\t\t * 自己(this)-参数——升序\n\t\t * 参数-this——降序\n\t\t */\n\t\tArrayList<Person> list02=new ArrayList<>();\n\t\tlist02.add(new Person(\"水冰儿\",19));\n\t\tlist02.add(new Person(\"焰灵姬\",28));\n\t\tlist02.add(new Person(\"紫女\",30));\n\t\tlist02.add(new Person(\"水冰儿\",20));\n\t\tSystem.out.println(list02);\n\t\tCollections.sort(list02);\n\t\tSystem.out.println(list02);\n\t\t\n\t}\n}\n\n```\n\n\n\n## 6.3 Comparator比较器\n\n还是先研究这个方法\n\n`public static <T> void sort(List<T> list)`:将集合中元素按照默认规则排序。\n\n不过这次存储的是字符串类型。\n\n```java\npublic class CollectionsDemo2 {\n    public static void main(String[] args) {\n        ArrayList<String>  list = new ArrayList<String>();\n        list.add(\"cba\");\n        list.add(\"aba\");\n        list.add(\"sba\");\n        list.add(\"nba\");\n        //排序方法\n        Collections.sort(list);\n        System.out.println(list);\n    }\n}\n```\n\n结果：\n\n```java\n[aba, cba, nba, sba]\n```\n\n使用的是默认的规则完成字符串的排序，那么默认规则是怎么定义出来的呢？\n\n说到排序了，简单的说就是两个对象之间比较大小，那么在JAVA中提供了两种比较实现的方式，一种是**比较死板**的采用`java.lang.Comparable`接口去实现，一种是**灵活**的当我需要做排序的时候在去选择的`java.util.Comparator`接口完成。\n\n那么采用的`public static <T> void sort(List<T> list)`这个方法完成的排序，实际上要求了被排序的类型需要实现Comparable接口完成比较的功能，在String类型上如下：\n\n```java\npublic final class String implements java.io.Serializable, Comparable<String>, CharSequence {\n```\n\n<u>String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则写死了，那比如我想要字符串按照第一个字符降序排列，那么这样就要修改String的源代码，这是不可能的了</u>，那么这个时候可以使用\n\n`public static <T> void sort(List<T> list，Comparator<? super T> )`方法灵活的完成，这个里面就涉及到了Comparator这个接口，位于位于java.util包下，排序是comparator能实现的功能之一,该接口代表一个比较器，比较器具有可比性！顾名思义就是做排序的，通俗地讲需要比较两个对象谁排在前谁排在后，那么比较的方法就是：\n\n* ` public int compare(String o1, String o2)`：比较其两个参数的顺序。\n\n  > 两个对象比较的结果有三种：大于，等于，小于。\n  >\n  > 如果要按照升序排序，\n  > 则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数）\n  > 如果要按照降序排序\n  > 则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数）\n  >\n  >\n  > 上面的官方话，太啰嗦了，我总结一下，return o1-o2是升序，return o2-o1是降序\n\n操作如下:\n\n```java\nclass People {\n\tprivate String name;\n\tprivate int age;\n\tpublic People() {\n\t\t\n\t}\n\tpublic People(String name,int age) {\n\t\tthis.name=name;\n\t\tthis.age=age;\n\t}\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n\t@Override\n\tpublic String toString() {\n\t\treturn \"People [name=\" + name + \", age=\" + age + \"]\";\n\t}\n\t\n}\npublic class Demo03Sort {\n\tpublic static void main(String[] args) {\n\t\tArrayList<Integer> list=new ArrayList<>();\n\t\tlist.add(1);\n\t\tlist.add(2);\n\t\tlist.add(3);\n\t\tCollections.sort(list,new Comparator<Integer>(){\n\t\t\t//重写比较的规则\n\t\t\t@Override\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\treturn o2-o1;//降序\n//\t\t\t\treturn o1-o2;//升序\n\t\t\t}\n\t\t});\n\t\tSystem.out.println(list);\n\t\t\n\t\tArrayList<People> list01=new ArrayList<>();\n\t\tlist01.add(new People(\"焰灵姬\",28));\n\t\tlist01.add(new People(\"水冰儿\",19));\n\t\tlist01.add(new People(\"b水冰儿\",22));\n\t\tlist01.add(new People(\"a妙妙\",22));\n\t\tSystem.out.println(list01);\n\t\tCollections.sort(list01,new Comparator<People>() {\n\t\t\t@Override\n\t\t\tpublic int compare(People o1, People o2) {\n\t\t\t\t/*\n\t\t\t\t * 按照年龄升序排序\n\t\t\t\t * 如果两个人年龄相同，再使用姓名相同的第一个字比较\n\t\t\t\t */\n\t\t\t\tint result=o1.getAge()-o2.getAge();\n\t\t\t\tif(result==0) {\n\t\t\t\t\tresult=o1.getName().charAt(0)-o2.getName().charAt(0);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t});\n\t\tSystem.out.println(list01);\n\t}\n}\n```\n\n结果如下：\n\n```java\n[3, 2, 1]\n[People [name=焰灵姬, age=28], People [name=水冰儿, age=19], People [name=b水冰儿, age=22], People [name=a妙妙, age=22]]\n[People [name=水冰儿, age=19], People [name=a妙妙, age=22], People [name=b水冰儿, age=22], People [name=焰灵姬, age=28]]\n```\n\n## 6.4 简述Comparable和Comparator两个接口的区别。\n\n**Comparable**：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。\n\n上面是官方文档的，我再总结一下，这个`太死板`了。\n\n**Comparator**强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。\n\n上面是官方文档的，我再总结一下，这个`很灵活`。\n\n## 6.5  练习——Comparable\n\n创建一个学生类，存储到ArrayList集合中完成指定排序操作。\n\nStudent 初始类\n\n~~~java\npublic class Student{\n    private String name;\n    private int age;\n\n    public Student() {\n    }\n\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"Student{\" +\n               \"name='\" + name + '\\'' +\n               \", age=\" + age +\n               '}';\n    }\n}\n~~~\n\n测试类：\n\n~~~java\npublic class Demo {\n\n    public static void main(String[] args) {\n        // 创建四个学生对象 存储到集合中\n        ArrayList<Student> list = new ArrayList<Student>();\n\n        list.add(new Student(\"rose\",18));\n        list.add(new Student(\"jack\",16));\n        list.add(new Student(\"abc\",16));\n        list.add(new Student(\"ace\",17));\n        list.add(new Student(\"mark\",16));\n\n\n        /*\n          让学生 按照年龄排序 升序\n         */\n//        Collections.sort(list);//要求 该list中元素类型  必须实现比较器Comparable接口\n\n\n        for (Student student : list) {\n            System.out.println(student);\n        }\n\n\n    }\n}\n~~~\n\n发现，当调用Collections.sort()方法的时候 程序报错了。\n\n原因：如果想要集合中的元素完成排序，那么必须要实现比较器Comparable接口。\n\n于是就完成了Student类的一个实现，如下：\n\n~~~java\npublic class Student implements Comparable<Student>{\n    ....\n    @Override\n    public int compareTo(Student o) {\n        return this.age-o.age;//升序\n    }\n}\n~~~\n\n再次测试，代码就OK 了效果如下：\n\n~~~java\nStudent{name='jack', age=16}\nStudent{name='abc', age=16}\nStudent{name='mark', age=16}\nStudent{name='ace', age=17}\nStudent{name='rose', age=18}\n~~~\n\n## 6.6 扩展练习——Comparator\n\n如果在使用的时候，想要独立的定义规则去使用 可以采用Collections.sort(List list,Comparetor<T> c)方式，自己定义规则：\n\n~~~java\nCollections.sort(list, new Comparator<Student>() {\n    @Override\n    public int compare(Student o1, Student o2) {\n        return o2.getAge()-o1.getAge();//以学生的年龄降序\n    }\n});\n~~~\n\n效果：\n\n~~~java\nStudent{name='rose', age=18}\nStudent{name='ace', age=17}\nStudent{name='jack', age=16}\nStudent{name='abc', age=16}\nStudent{name='mark', age=16}\n~~~\n\n\n\n如果想要规则更多一些，可以参考下面代码：\n\n~~~java\nCollections.sort(list, new Comparator<Student>() {\n            @Override\n            public int compare(Student o1, Student o2) {\n                // 年龄降序\n                int result = o2.getAge()-o1.getAge();//年龄降序\n\n                if(result==0){//第一个规则判断完了 下一个规则 姓名的首字母 升序\n                    result = o1.getName().charAt(0)-o2.getName().charAt(0);\n                }\n\n                return result;\n            }\n        });\n~~~\n\n效果如下：\n\n~~~java\nStudent{name='rose', age=18}\nStudent{name='ace', age=17}\nStudent{name='abc', age=16}\nStudent{name='jack', age=16}\nStudent{name='mark', age=16}\n~~~\n\n# 第七章 泛型\n\n## 7.1  泛型概述\n\n在前面学习集合时，都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。\n\n大家观察下面代码：\n\n~~~java\npublic class GenericDemo {\n\tpublic static void main(String[] args) {\n\t\tCollection coll = new ArrayList();\n\t\tcoll.add(\"abc\");\n\t\tcoll.add(\"itcast\");\n\t\tcoll.add(5);//由于集合没有做任何限定，任何类型都可以给其中存放\n\t\tIterator it = coll.iterator();\n\t\twhile(it.hasNext()){\n\t\t\t//需要打印每个字符串的长度,就要把迭代出来的对象转成String类型\n\t\t\tString str = (String) it.next();\n\t\t\tSystem.out.println(str.length());\n\t\t}\n\t}\n}\n~~~\n\n程序在运行时发生了问题**java.lang.ClassCastException**。                                                                                             为什么会发生类型转换异常呢？                                                                                                                                       来分析下：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时 ClassCastException。                                                                                                                                                       怎么来解决这个问题呢？                                                                                                                                                           Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了**泛型**(**Generic**)语法，让你在设计API时可以指定类或方法支持泛型，这样使用API的时候也变得更为简洁，并得到了编译时期的语法检查。\n\n* **泛型**：可以在类或方法中预支地使用未知的类型。\n\n{% asset_img 泛型的概念.png 泛型的概念 %}\n\n> tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。\n\n## 7.2  使用泛型的好处与弊端\n\n上一节只是讲解了泛型的引入，那么泛型带来了哪些好处呢？\n\n* 将运行时期的ClassCastException，转移到了编译时期变成了编译失败。\n* 避免了类型强转的麻烦。\n\n通过如下代码体验一下：\n\n~~~java\npublic class GenericDemo2 {\n\tpublic static void main(String[] args) {\n        Collection<String> list = new ArrayList<String>();\n        list.add(\"abc\");\n        list.add(\"itcast\");\n        // list.add(5);//当集合明确类型后，存放类型不一致就会编译报错\n        // 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型\n        Iterator<String> it = list.iterator();\n        while(it.hasNext()){\n            String str = it.next();\n            //当使用Iterator<String>控制元素类型后，就不需要强转了。获取到的元素直接就是String类型\n            System.out.println(str.length());\n        }\n\t}\n}\n~~~\n\n> tips:泛型是数据类型的一部分，将类名与泛型合并一起看做数据类型。\n\n```java\npublic class Demo04Generic {\n\tpublic static void main(String[] args) {\n//\t\tshow01();\n\t\tshow02();\n\t}\n\t/*\n\t * 创建集合对象，使用泛型\n\t * 好处：\n\t * 1.避免了类型转换的麻烦，存储的是什么类型，取出的是什么类型\n\t * 2.把运行期异常（代码运行之后会抛出的异常），提升到了编译期（写代码的时候就会报错 ）\n\t * 弊端：\n\t * 泛型是什么样的类型，就只能存储什么类型的数据\n\t */\n\tpublic static void show02() {\n\t\tArrayList<String> list=new ArrayList<String>();\n\t\tlist.add(\"焰灵姬\");\n\t\tlist.add(\"潮女妖\");\n\t\tlist.add(\"江厌离\");//存储别的类型，会直接报错\n\t\t\n\t\t//使用迭代器遍历一个集合\n\t\tIterator<String> it=list.iterator();\n\t\twhile(it.hasNext()) {\n\t\t\tString s=it.next();\n\t\t\tSystem.out.println(s+\"-->\"+s.length());\n\t\t}\n\t}\n\t/*\n\t * 创建集合，不使用泛型\n\t * 好处：\n\t * 集合不使用泛型，默认的类型就是Object类型，可以存储任意类型的数据\n\t * \n\t * 弊端：\n\t * 集合不安全，会引发异常\n\t */\n\tpublic static void show01() {\n\t\tArrayList list=new ArrayList();//不使用泛型，此时默认为Object类型\n\t\tlist.add(1);\n\t\tlist.add(\"焰灵姬\");\n\t\tlist.add(\"潮女妖\");\n\t\t//增强for循环遍历\n//\t\tfor(Object o:list) {\n//\t\t\tSystem.out.println(o);\n//\t\t}\n\t\t\n\t\t//迭代器遍历\n\t\tIterator it=list.iterator();\n\t\twhile(it.hasNext()) {\n\t\t\tObject obj=it.next();\n\t\t\tSystem.out.println(obj);\n\t\t\t//想要使用String类特有的方法，length获取字符串的长度；不能使用多态 Object obj=\"abc\"\n\t\t\t//需要向下转型\n\t\t\tString s=(String) obj;\n\t\t\tSystem.out.println(s.length());\n\t\t\t\n\t\t\t//此时会报错，因为有个Integer类型的\n\t\t}\n\t}\n}\n\n```\n\n## 7.3  泛型的定义与使用\n\n在集合中会大量使用到泛型，这里来完整地学习泛型知识。\n\n泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。\n\n### 定义和使用含有泛型的类\n\n定义格式：\n\n~~~\n修饰符 class 类名<代表泛型的变量> {  }\n~~~\n\n例如，API中的ArrayList集合：\n\n~~~java\nclass ArrayList<E>{ \n    public boolean add(E e){ }\n\n    public E get(int index){ }\n   \t....\n}\n~~~\n\n使用泛型： 即什么时候确定泛型。\n\n**在创建对象的时候确定泛型**\n\n 例如，`ArrayList<String> list = new ArrayList<String>();`\n\n此时，变量E的值就是String类型,那么的类型就可以理解为：\n\n~~~java \nclass ArrayList<String>{ \n     public boolean add(String e){ }\n\n     public String get(int index){  }\n     ...\n}\n~~~\n\n再例如，`ArrayList<Integer> list = new ArrayList<Integer>();`\n\n此时，变量E的值就是Integer类型,那么的类型就可以理解为：\n\n~~~java\nclass ArrayList<Integer> { \n     public boolean add(Integer e) { }\n\n     public Integer get(int index) {  }\n     ...\n}\n~~~\n\n举例自定义泛型类\n\n~~~java\npublic class MyGenericClass<MVP> {\n\t//没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型\n\tprivate MVP mvp;\n     \n    public void setMVP(MVP mvp) {\n        this.mvp = mvp;\n    }\n     \n    public MVP getMVP() {\n        return mvp;\n    }\n}\n~~~\n\n使用:\n\n~~~java\npublic class GenericClassDemo {\n  \tpublic static void main(String[] args) {\t\t \n         // 创建一个泛型为String的类\n         MyGenericClass<String> my = new MyGenericClass<String>();    \t\n         // 调用setMVP\n         my.setMVP(\"大胡子登登\");\n         // 调用getMVP\n         String mvp = my.getMVP();\n         System.out.println(mvp);\n         //创建一个泛型为Integer的类\n         MyGenericClass<Integer> my2 = new MyGenericClass<Integer>(); \n         my2.setMVP(123);   \t  \n         Integer mvp2 = my2.getMVP();\n    }\n}\n~~~\n\n###  含有泛型的方法\n\n定义格式：\n\n~~~\n修饰符 <代表泛型的变量> 返回值类型 方法名(参数){  }\n~~~\n\n例如，\n\n~~~java\npublic class MyGenericMethod {\t  \n    public <MVP> void show(MVP mvp) {\n    \tSystem.out.println(mvp.getClass());\n    }\n    \n    public <MVP> MVP show2(MVP mvp) {\t\n    \treturn mvp;\n    }\n}\n~~~\n\n使用格式：**调用方法时，确定泛型的类型**\n\n~~~java\npublic class GenericMethodDemo {\n    public static void main(String[] args) {\n        // 创建对象\n        MyGenericMethod mm = new MyGenericMethod();\n        // 演示看方法提示\n        mm.show(\"aaa\");\n        mm.show(123);\n        mm.show(12.45);\n    }\n}\n~~~\n\n### 含有泛型的接口\n\n定义格式：\n\n~~~\n修饰符 interface接口名<代表泛型的变量> {  }\n~~~\n\n例如，\n\n~~~java\npublic interface MyGenericInterface<E>{\n\tpublic abstract void add(E e);\n\t\n\tpublic abstract E getE();  \n}\n~~~\n\n使用格式：\n\n**1、定义类时确定泛型的类型**\n\n例如\n\n~~~java\npublic class MyImp1 implements MyGenericInterface<String> {\n\t@Override\n    public void add(String e) {\n        // 省略...\n    }\n\n\t@Override\n\tpublic String getE() {\n\t\treturn null;\n\t}\n}\n~~~\n\n此时，泛型E的值就是String类型。\n\n **2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型**\n\n 例如\n\n~~~java\npublic class MyImp2<E> implements MyGenericInterface<E> {\n\t@Override\n\tpublic void add(E e) {\n       \t // 省略...\n\t}\n\n\t@Override\n\tpublic E getE() {\n\t\treturn null;\n\t}\n}\n~~~\n\n确定泛型：\n\n~~~java\n/*\n * 使用\n */\npublic class GenericInterface {\n    public static void main(String[] args) {\n        MyImp2<String>  my = new MyImp2<String>();  \n        my.add(\"aa\");\n    }\n}\n~~~\n\n## 7.4  泛型通配符\n\n当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符<?>表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。\n\n### 通配符基本使用\n\n泛型的通配符:**不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。**\n\n此时只能接受数据,不能往该集合中存储数据。\n\n举个例子大家理解使用即可：\n\n~~~java\npublic static void main(String[] args) {\n    Collection<Intger> list1 = new ArrayList<Integer>();\n    getElement(list1);\n    Collection<String> list2 = new ArrayList<String>();\n    getElement(list2);\n}\npublic static void getElement(Collection<?> coll){}\n//？代表可以接收任意类型\n~~~\n\n> tips:泛型不存在继承关系 Collection<Object> list = new ArrayList<String>();这种是错误的。\n\n### 通配符高级使用----受限泛型\n\n之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的**上限**和**下限**。\n\n**泛型的上限**：\n\n* **格式**： `类型名称 <? extends 类 > 对象名称`\n* **意义**： `只能接收该类型及其子类`\n\n**泛型的下限**：\n\n- **格式**： `类型名称 <? super 类 > 对象名称`\n- **意义**： `只能接收该类型及其父类型`\n\n比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类\n\n~~~java\npublic class Demo09Generic {\n\tpublic static void main(String[] args) {\n\t\tCollection<Integer> list1 = new ArrayList<Integer>();\n\t\tCollection<String> list2 = new ArrayList<String>();\n\t\tCollection<Number> list3 = new ArrayList<Number>();\n\t\tCollection<Object> list4 = new ArrayList<Object>();\n\n\t\t/*\n\t\t * list1 Integer\n\t\t * list2 String\n\t\t * list3 Number\n\t\t * list4 Object\n\t\t */\n\t\tgetElement1(list1);\n\t\tgetElement1(list2);// 报错\n\t\tgetElement1(list3);\n\t\tgetElement1(list4);// 报错\n\n\t\tgetElement2(list1);// 报错\n\t\tgetElement2(list2);// 报错\n\t\tgetElement2(list3);\n\t\tgetElement2(list4);\n\n\t}\n\t/*\n\t * 类与类之间的继承关系\n\t * Integer extends Number extends Object\n\t * String extends Object \n\t */\n\n\t// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类\n\tpublic static void getElement1(Collection<? extends Number> coll) {\n\t}\n\n\t// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类\n\tpublic static void getElement2(Collection<? super Number> coll) {\n\t}\n}\n\n~~~\n\n# 第八章 集合综合案例\n\n## 8.1 案例介绍\n\n按照斗地主的规则，完成洗牌发牌的动作。\n具体规则：\n\n使用54张牌打乱顺序,三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。\n\n## 8.2 案例分析\n\n{% asset_img 斗地主案例需求分析.png 斗地主案例需求分析%}\n\n* 准备牌：\n\n  牌可以设计为一个ArrayList<String>,每个字符串为一张牌。\n  每张牌由花色数字两部分组成，可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。\n  牌由Collections类的shuffle方法进行随机排序。\n\n* 发牌\n\n  将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。\n\n\n* 看牌\n\n  直接打印每个集合。\n\n## 8.3 代码实现\n\n~~~java\npackage demo20;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\n\n/*\n * 斗地主：\n * 1.准备牌\n * 2.洗牌\n * 3.发牌\n * 4.看牌\n */\npublic class DouDiZhu {\n\tpublic static void main(String[] args) {\n\t\t/*\n\t\t * 1.准备牌\n\t\t */\n\t\t//定义一个存储54张牌的ArrayList集合，泛型使用字符串\n\t\tArrayList<String> poke=new ArrayList<String>();\n\t\t//定义两个数组，一个数组存储牌的花色，一个存储序号\n\t\tString[] colors= {\n\t\t\t\t\"♥\",\"♠\",\"♣\",\"♦\"\n\t\t};\n\t\tString[] numbers= {\n\t\t\t\t\"2\",\"A\",\"K\",\"Q\",\"J\",\"10\",\"9\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\"\n\t\t};\n\t\t//先把大王跟小王存储到集合中\n\t\tpoke.add(\"大王\");\n\t\tpoke.add(\"小王\");\n\t\t//循环遍历两个数组，组装52张牌\n\t\tfor (String number : numbers) {\n\t\t\tfor (String color : colors) {\n\t\t\t\t//把组装好的牌存储到poke牌当中\n\t\t\t\tpoke.add(color+number);\n\t\t\t}\n\t\t}\n//\t\tSystem.out.println(poke);\n\t\t\n\t\t/*\n\t\t * 2.洗牌\n\t\t * 使用集合的工具类Collections中的方法\n\t\t * static void shuffle(List<?> list) 使用默认随机源对指定列表进行置换\n\t\t */\n\t\tCollections.shuffle(poke);\n//\t\tSystem.out.println(poke);\n\t\t/*\n\t\t * 3.发牌\n\t\t * 定义四个集合，存储3个玩家和1底牌\n\t\t */\n\t\tArrayList<String> player01=new ArrayList<String>();\n\t\tArrayList<String> player02=new ArrayList<String>();\n\t\tArrayList<String> player03=new ArrayList<String>();\n\t\tArrayList<String> diPai=new ArrayList<String>();\n\t\t\n\t\t//遍历poke集合，获取每一张牌，使用poke的索引，%3给三个玩家轮流发牌\n\t\t//剩余三张牌给底牌\n\t\t//注意：\n\t\t//先判断底牌（i）>=51,否则就发没了\n\t\tfor (int i = 0; i < poke.size(); i++) {\n\t\t\t//获取每一张牌\n\t\t\tString p=poke.get(i);\n\t\t\t//轮流发牌\n\t\t\tif(i>=51) {//底牌发牌\n\t\t\t\tdiPai.add(p);\n\t\t\t}else if(i%3==0){//玩家1发牌\n\t\t\t\tplayer01.add(p);\n\t\t\t}else if(i%3==1) {//玩家2发牌\n\t\t\t\tplayer02.add(p);\n\t\t\t}else if(i%3==2) {//玩家3发牌\n\t\t\t\tplayer03.add(p);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * 4.看牌\n\t\t */\n\t\tSystem.out.println(\"紫女：\"+player01);\n\t\tSystem.out.println(\"焰灵姬：\"+player02);\n\t\tSystem.out.println(\"潮女妖：\"+player03);\n\t\tSystem.out.println(\"底牌：\"+diPai);\n\t}\n}\n\n~~~\n\n","tags":["java"]},{"title":"cookie与session的区别","url":"/blog/2020/cookie-and-session/","content":"\n清明节当天，网站灰色，代码 html {filter: grayscale(1);} 。\n\n今天jsp上课的时候，学了session，老师说课下自己了解一下cookie，ok！\n\n<!--more-->\n\n# 一、Cookie\n\n HTTP 很重要的一个特点就是无状态（每一次见面都是“初次见面”），如果单纯的希望通过我们的服务端程序去记 住每一个访问者是不可能的，所以必须借助一些手段或者说技巧让服务端记住客户端，这种手段就是 **Cookie**。 \n\n{% asset_img cookie.png cookie %}\n\n Cookie 就像是在超级市场买东西拿到的小票，由超市（Server）发给消费者（Browser），超市方面不用记住每一个消费者的脸，但是他们认识消费者手里的小票（Cookie），可以通过小票知道消费者之前的一些消费信息（在服务端产生的数据）。  \n\n# 二、Session\n\n由于 Cookie 是服务端下发给客户端由客户端本地保存的。换而言之客户端可以在本地对其随意操作，包括删除和修改。如果客户端随意伪造一个 Cookie 的话，对于服务端是无法辨别的，就会造成服务端被蒙蔽，构成安全隐患。 于是乎就有了另外一种基于Cookie 基础之上的手段：Session。\n\n{% asset_img session1.png session %}\n\n Session区别于 Cookie一个很大的地方就是：Session 数据存在了服务端，而 Cookie 存在了客户端本地，存在服务端最大的优势就是，不是用户想怎么改就怎么改了。 \n\nSession 这种机制会更加适合于存放一些属于用户而又不能让用户修改的数据，因为客户端不再保存具体的数据， 只是保存一把“钥匙”。伪造一把可以用的钥匙，可能性是极低的，所以不需要在意。 \n\n{% asset_img session2.png session %}\n\n```jsp\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n\tpageEncoding=\"UTF-8\"%>\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>Insert title here</title>\n</head>\n<body>\n\t<%\n\t\tString str = (String) application.getAttribute(\"count01\");\n\t\tint total = 0;\n\t\tif (str == null) {\n\t\t\ttotal = 1;\n\t\t} else {\n\t\t\ttotal = Integer.parseInt(str) + 1;\n\t\t}\n\t\tif (session.isNew()) {\n\t\t\tout.println(\"你是第一次访问这个网站\");\n\t\t}\n\t\tapplication.setAttribute(\"count01\", total + \"\");\n\t%>\n\t<p>\n\t\t你是第<%=application.getAttribute(\"count01\")%>个访问该网站\n\t</p>\n</body>\n</html>\n```\n\n上面这个例子，是通过jsp的application对象，来实现一个网站的访问统计。\n\n> application在服务器开启之后，就会存在；在服务器关闭之后，数据就会清零。\n\n```php\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\"\n          content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n<body>\n<?php\n$countFile = \"count.txt\";\nif (!file_exists($countFile)) {\n    $count = 0;\n    $cf = fopen($countFile, \"w\");\n    fputs($cf, $count);\n    fclose($cf);\n} else {\n    $cf = fopen($countFile, \"r\");\n    $count = (int)trim(fgets($cf));\n    fclose($cf);\n}\n\n\n$count++;\n$cf = fopen($countFile, \"w\");\nfputs($cf, $count);\nfclose($cf);\n\n?>\n你是第<?php echo $count ?>个访问的\n</body>\n</html>\n```\n\nphp通过文件来统计的话，也是可以实现这个功能的","tags":["web"]},{"title":"会话技术","url":"/blog/2020/cookie-and-session-2/","content":"\n再次系统学习一下cookie和session\n\n<!--more-->\n\n之前写得一篇[cookie与session区别](https://meethigher.top/blog/2020/cookie-and-session/)\n\n# 一、会话技术\n\n会话：一次会话中包含多次请求和响应。\n\n一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止。\n\n功能：在一次会话的范围内的多次请求间，共享数据\n\n方式\n\n1. 客户端会话技术：cookie\n2. 服务器端会话技术：session\n\n有关http协议的知识，移步到[这里](https://meethigher.top/blog/2020/servlet/)\n\n# 二、Cookie\n\n概念：客户端会话技术，将数据保存到客户端\n\n## 2.1 快速入门\n\n快速入门\n\n1. 创建cookie对象，绑定数据\n   * Cookie(String name, String value)\n2. 发送cookie\n   * response.addCookie(Cookie cookie)\n3. 获取cookie，拿到数据\n   * Cookie[] request.getCookies()\n\n```java\n@WebServlet(\"/demo01Cookie\")\npublic class Demo01Cookie extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doPost(req,resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //创建cookie对象\n        Cookie cookie=new Cookie(\"msg\",\"hello\");\n        //发送cookie\n        resp.addCookie(cookie);\n\n    }\n}\n```\n\n上面这串代码，在访问该网址时，服务器返回一串cookie，\"msg=hello\"。\n\n{% asset_img 1.png %}\n\n```java\n@WebServlet(\"/demo02Cookie\")\npublic class Demo02Cookie extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doGet(request,response);\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //获取cookie\n        Cookie[] cookies = request.getCookies();\n        //遍历cookies\n        if(cookies!=null){\n            for(Cookie c:cookies){\n                String name=c.getName();\n                String value=c.getValue();\n                System.out.println(name+\"==\"+value);\n            }\n        }\n    }\n}\n```\n\n上面这些代码，是将浏览器端请求服务器时携带的cookie打印到控制台。\n\n{% asset_img 2.png %}\n\n如果想要在浏览器查看cookie的话\n\n{% asset_img 3.png %}\n\n## 2.2 实现原理\n\n浏览器**初次**请求服务器，服务器响应放回**set-cookie**，浏览器将接收到的**cookie**保存到本地。\n\n浏览器**二次**请求服务器，请求头中携带**cookie**的值。\n\n> 就相当于买东西\n>\n> Cookie 就像是在超级市场买东西拿到的小票，由超市（Server）发给消费者（Browser），超市方面不用记住每一个消费者的脸，但是他们认识消费者手里的小票（Cookie），可以通过小票知道消费者之前的一些消费信息（在服务端产生的数据）。\n\n## 2.3 Cookie细节\n\n1. 一次可以发送多个Cookie\n\n   * 可以创建多个对象，使用response调用多次addCookie方法发送cookie即可\n\n2. Cookie在浏览器中保存时间\n\n   * 默认情况下，当浏览器关闭后，Cookie数据被销毁\n   * 设置Cookie生命周期：持久化存储\n     * setMaxAge(int seconds)\n       * 正数：将Cookie数据写到硬盘的文件中，持久化存储。正数代表cookie的存活时间。比如30，在30s之后，这个Cookie文件将被删除掉\n       * 负数：默认值，存储在内存中，浏览器关闭，就销毁\n       * 零：删除Cookie信息\n\n3. Cookie存储中文\n\n   * Tomcat8之前，Cookie中不能直接存储中文数据。需要将中文数据转码，即url编码（%E3，即%跟两个十六进制的数字表示一个**字节**，有多少个字节，就会有多少%）\n   * Tomcat8之后，Cookie支持中文数据，但是特殊字符还是不支持，比方说空格。需要用url编码\n\n4. Cookie共享问题\n\n   * 默认同一服务器不同项目，是不会共享Cookie的\n     * setPath(String path)：设置cookie的获取范围。默认情况下，会去设置当前的虚拟目录\n   * 不同服务器实现cookie共享\n     * setDomain(String path)：设置一级域名相同，那么多个服务器之间cookie可以共享 \n\n```java\n@WebServlet(\"/demo04Cookie\")\npublic class Demo04Cookie extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doGet(request,response);\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //创建Cookie\n        Cookie ck1 = new Cookie(\"msg\", \"setMaxAge\");\n       //设置Cookie的存活时间\n//        ck1.setMaxAge(100);\n//        ck1.setMaxAge(-1);//默认值，会话关闭之后即消失\n        //删除当前cookie\n        //ck1.setMaxAge(0);\n\n        Cookie ck2 = new Cookie(\"hh\", \"奥利给\");\n\n        ck2.setPath(\"/demo04Cookie\");\n        //发送cookie\n        response.addCookie(ck1);\n        response.addCookie(ck2);\n    }\n}\n```\n\n{% asset_img 4.png %}\n\n## 2.4 Cookie的特点和作用\n\n特点\n\n1. Cookie存储数据在客户端浏览器\n2. 浏览器对于单个Cookie的大小有限制（4KB左右，不同浏览器不同），以及同一个域名下的总Cookie数量也有限制（20个，不同浏览器不同）\n\n作用\n\n1. Cookie一般用于存储少量的、不敏感的数据\n2. 在不登录的情况下，完成服务器对客户端的身份识别（比方说百度在不登录的情况下，存储的一些个性化设置，当然这个也是可以通过本地存储来实现）\n\n[localStorage与Cookie的异同](https://blog.csdn.net/digua523/article/details/86286623)\n\n## 2.5 案例-记录访问\n\n### 需求\n\n记住上一次访问时间\n\n如果是初次访问，提示你好，欢迎首次访问\n\n如果是二次访问，提示你好，欢迎回来，上次访问时间：xxx\n\n分析：判断是否有lastTime该cookie，如果没有，则是初次访问。访问时，服务端将访问时间存储到lastTime的cookie中\n\n### 实现\n\n```java\n@WebServlet(\"/cookieTest\")\npublic class CookieTest extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //设置响应体的消息体的数据格式以及编码\n        response.setContentType(\"text/html;charset=utf-8\");\n\n        //设置有没有lastTime这个cookie标记\n        boolean flag=false;\n\n        //获取当前时间\n        String time = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\").format(new Date());\n        //直接存储time，会出错，因为有个空格。当然删掉是可以的，不过最好的办法是url编码\n        String time_en = URLEncoder.encode(time, StandardCharsets.UTF_8);\n        //获取cookie\n        Cookie[] cks = request.getCookies();\n        //二次访问\n        if(cks!=null&&cks.length>0){\n            for(Cookie ck:cks){\n                String name=ck.getName();\n               if(\"lastTime\".equals(name)){\n                   flag=true;\n\n                   //响应数据\n                   String value= URLDecoder.decode(ck.getValue(),\"utf-8\");\n                   response.getWriter().write(\"<h1>欢迎回来，您上次访问时间\"+value+\"</h1>\");\n                   //重新设置cookie值\n                   ck.setValue(time_en);\n                   ck.setMaxAge(60*60*24*30);//cookie存储一个月\n                   response.addCookie(ck);\n                   break;\n               }\n            }\n        }\n        //初次访问\n        if(cks==null||cks.length==0|| !flag){\n            //响应数据\n            response.getWriter().write(\"<h1>您好，这是你的首次访问</h1>\");\n            //设置cookie\n            Cookie lt = new Cookie(\"lastTime\", time_en);\n            lt.setMaxAge(60*60*24*30);\n            response.addCookie(lt);\n        }\n    }\n}\n```\n\n{% asset_img  5.png %}\n\n> 注意cookie存储中特殊字符的编解码即可\n\n# 三、JSP\n\n## 3.1 概念\n\nJSP：Java Server Pages，java服务端页面\n\n本质：一个特殊页面，既可以定义html标签，又可以定义java代码。本质就是一个Servlet\n\n作用：简化Servlet书写\n\n## 3.2 原理\n\n1. 客户端请求**.jsp**，服务端判断有无**.jsp**。无则**404**\n2. 找到**.jsp**，会将**.jsp**转换为**.java**文件\n3. 编译**.java**文件，生成**.class**字节码文件\n4. 由字节码文件提供访问\n\n我们在CATALINA_BASE的路径下，能够找到集成到idea上面Tomcat的路径，在conf下面，能够找到服务器访问的源文件。像servlet生成的源码放到了WEB-INF的classes下面\n\n{% asset_img 6.png %}\n\n**.jsp**文件经过编译之后，存储在CATALINA_BASE路径下的work中\n\n{% asset_img 7.png %}\n\n可以看出，编译后**.java**文件继承了Tomcat中的**HttpJspBase.java**，我们进入Tomcat找到该类\n\n{% asset_img 8.png %}\n\n**HttpJspBase**继承了**HttpServlet**，故jsp的本质就是一个Servlet\n\n## 3.3 jsp脚本\n\njsp脚本：jsp定义Java代码的方式\n\n1. <% 代码 %>：定义在jsp转换后的java类（Servlet）的service方法中。service方法中可以定义什么，该脚本中就可以定义什么。\n2. <%! 代码 %>：定义在jsp转换后的java类（Servlet）的成员位置。（不过尽量不要再Servlet中定义成员变量，会引发线程安全问题）\n3. <%= 代码 %>：定义在jsp转换后的java类（Servlet）的service方法中。会输出在网页页面上，输出语句能输出啥，该脚本中就能定义啥\n\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>$Title$</title>\n</head>\n<body>\n<% System.out.println(\"Hello JSP\"); %>\n<%!\n    int i = 3;\n%>\n<%= i %>\n<%= \"我打你妈的\" %>\n<h1>Hello JSP</h1>\n</body>\n</html>\n```\n\n以上面这个例子为例，编译生成的index_jsp.java如下\n\n```java\npublic final class index_jsp extends org.apache.jasper.runtime.HttpJspBase\n    implements org.apache.jasper.runtime.JspSourceDependent,\n                 org.apache.jasper.runtime.JspSourceImports {\n\n\n    int i=3;\n  \n  private static final javax.servlet.jsp.JspFactory _jspxFactory =\n          javax.servlet.jsp.JspFactory.getDefaultFactory();\n\n  private static java.util.Map<java.lang.String,java.lang.Long> _jspx_dependants;\n\n  private static final java.util.Set<java.lang.String> _jspx_imports_packages;\n\n  private static final java.util.Set<java.lang.String> _jspx_imports_classes;\n\n  static {\n    _jspx_imports_packages = new java.util.HashSet<>();\n    _jspx_imports_packages.add(\"javax.servlet\");\n    _jspx_imports_packages.add(\"javax.servlet.http\");\n    _jspx_imports_packages.add(\"javax.servlet.jsp\");\n    _jspx_imports_classes = null;\n  }\n\n  private volatile javax.el.ExpressionFactory _el_expressionfactory;\n  private volatile org.apache.tomcat.InstanceManager _jsp_instancemanager;\n\n  public java.util.Map<java.lang.String,java.lang.Long> getDependants() {\n    return _jspx_dependants;\n  }\n\n  public java.util.Set<java.lang.String> getPackageImports() {\n    return _jspx_imports_packages;\n  }\n\n  public java.util.Set<java.lang.String> getClassImports() {\n    return _jspx_imports_classes;\n  }\n\n  public javax.el.ExpressionFactory _jsp_getExpressionFactory() {\n    if (_el_expressionfactory == null) {\n      synchronized (this) {\n        if (_el_expressionfactory == null) {\n          _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();\n        }\n      }\n    }\n    return _el_expressionfactory;\n  }\n\n  public org.apache.tomcat.InstanceManager _jsp_getInstanceManager() {\n    if (_jsp_instancemanager == null) {\n      synchronized (this) {\n        if (_jsp_instancemanager == null) {\n          _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());\n        }\n      }\n    }\n    return _jsp_instancemanager;\n  }\n\n  public void _jspInit() {\n  }\n\n  public void _jspDestroy() {\n  }\n\n  public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)\n      throws java.io.IOException, javax.servlet.ServletException {\n\n    if (!javax.servlet.DispatcherType.ERROR.equals(request.getDispatcherType())) {\n      final java.lang.String _jspx_method = request.getMethod();\n      if (\"OPTIONS\".equals(_jspx_method)) {\n        response.setHeader(\"Allow\",\"GET, HEAD, POST, OPTIONS\");\n        return;\n      }\n      if (!\"GET\".equals(_jspx_method) && !\"POST\".equals(_jspx_method) && !\"HEAD\".equals(_jspx_method)) {\n        response.setHeader(\"Allow\",\"GET, HEAD, POST, OPTIONS\");\n        response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, \"JSP 只允许 GET、POST 或 HEAD。Jasper 还允许 OPTIONS\");\n        return;\n      }\n    }\n\n    final javax.servlet.jsp.PageContext pageContext;\n    javax.servlet.http.HttpSession session = null;\n    final javax.servlet.ServletContext application;\n    final javax.servlet.ServletConfig config;\n    javax.servlet.jsp.JspWriter out = null;\n    final java.lang.Object page = this;\n    javax.servlet.jsp.JspWriter _jspx_out = null;\n    javax.servlet.jsp.PageContext _jspx_page_context = null;\n\n\n    try {\n      response.setContentType(\"text/html;charset=UTF-8\");\n      pageContext = _jspxFactory.getPageContext(this, request, response,\n      \t\t\tnull, true, 8192, true);\n      _jspx_page_context = pageContext;\n      application = pageContext.getServletContext();\n      config = pageContext.getServletConfig();\n      session = pageContext.getSession();\n      out = pageContext.getOut();\n      _jspx_out = out;\n\n      out.write(\"\\n\");\n      out.write(\"\\n\");\n      out.write(\"<html>\\n\");\n      out.write(\"  <head>\\n\");\n      out.write(\"    <title>$Title$</title>\\n\");\n      out.write(\"  </head>\\n\");\n      out.write(\"  <body>\\n\");\n      out.write(\"  \");\n System.out.println(\"Hello JSP\"); \n      out.write('\\n');\n      out.write(' ');\n      out.write(' ');\n      out.write('\\n');\n      out.write(' ');\n      out.write(' ');\n      out.print( i );\n      out.write('\\n');\n      out.write(' ');\n      out.write(' ');\n      out.print( \"我打你妈的\" );\n      out.write(\"\\n\");\n      out.write(\"  <h1>Hello JSP</h1>\\n\");\n      out.write(\"  </body>\\n\");\n      out.write(\"</html>\\n\");\n    } catch (java.lang.Throwable t) {\n      if (!(t instanceof javax.servlet.jsp.SkipPageException)){\n        out = _jspx_out;\n        if (out != null && out.getBufferSize() != 0)\n          try {\n            if (response.isCommitted()) {\n              out.flush();\n            } else {\n              out.clearBuffer();\n            }\n          } catch (java.io.IOException e) {}\n        if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);\n        else throw new ServletException(t);\n      }\n    } finally {\n      _jspxFactory.releasePageContext(_jspx_page_context);\n    }\n  }\n}\n```\n\n## 3.4 jsp内置对象\n\n内置对象概念：在jsp页面中不需要获取和创建，可以直接使用的对象。\n\n> 因为jsp编译后就是一个servlet类，其中某些代码直接放到了service方法中，所以，像request这种的，是在Servlet中已经定义好的，就可以直接使用。叫做内置对象。\n>\n> 具体可以参照上面jsp生成的java代码\n\njsp一共有9个内置对象（本次介绍三个，详细看下篇博客）\n\n* request\n* response\n* out：字符输出流对象，可以将数据输出到页面上。类似于response.getWriter()\n  * out.write()：按代码顺序输出\n  * response.getWriter().write()：直接先输出。在jsp中尽量不要用这个。\n\n> 在Tomcat服务器做出响应之前，会先找response.getWriter()缓冲区的内容，再找out缓冲区中的内容，故response.getWriter().write()数据输出永远在out.write()之前\n\n{% asset_img 9.png %}\n\n通过jsp，我们可以优化Cookie的案例\n\n```jsp\n<%@ page import=\"java.text.SimpleDateFormat\" %>\n<%@ page import=\"java.util.Date\" %>\n<%@ page import=\"java.net.URLEncoder\" %>\n<%@ page import=\"java.nio.charset.StandardCharsets\" %>\n<%@ page import=\"java.net.URLDecoder\" %>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>Title</title>\n</head>\n<body>\n<%\n\n    //设置有没有lastTime这个cookie标记\n    boolean flag = false;\n\n    //获取当前时间\n    String time = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\").format(new Date());\n    //直接存储time，会出错，因为有个空格。当然删掉是可以的，不过最好的办法是url编码\n    String time_en = URLEncoder.encode(time, StandardCharsets.UTF_8);\n    //获取cookie\n    Cookie[] cks = request.getCookies();\n    //二次访问\n    if (cks != null && cks.length > 0) {\n        for (Cookie ck : cks) {\n            String name = ck.getName();\n            if (\"lastTime\".equals(name)) {\n                flag = true;\n\n                //响应数据\n                String value = URLDecoder.decode(ck.getValue(), \"utf-8\");\n%>\n<h1>欢迎回来，您上次访问时间<%=value%>\n</h1>\n<%\n                //重新设置cookie值\n                ck.setValue(time_en);\n                ck.setMaxAge(60 * 60 * 24 * 30);//cookie存储一个月\n                response.addCookie(ck);\n                break;\n            }\n        }\n    }\n    //初次访问\n    if (cks == null || cks.length == 0 || !flag) {\n%>\n<h1>您好，这是你的首次访问</h1>\n<%\n        Cookie lt = new Cookie(\"lastTime\", time_en);\n        lt.setMaxAge(60 * 60 * 24 * 30);\n        response.addCookie(lt);\n    }\n%>\n</body>\n</html>\n```\n\n> 优点：简单、方便，不用重启服务器即可运行。\n>\n> 缺点：代码没有进行分离。后期很难维护。当然实际开发中，还是不会用这种模式的。\n\n# 四、Session\n\n概念：服务器端会话技术。在**<u>一次会话</u>**的多次请求间共享数据，将数据保存在服务器端的对象中（有一个对象就是HttpSession）\n\n## 4.1 快速入门\n\n1. 获取HttpSession\n\n   * request.getSession()\n2. HttpSession对象\n   * Object getAttribute(String name)\n   * void setAttribute(String name, Object value)\n   * void removeAttribute(String name)\n\n```java\n@WebServlet(\"/demo01Session\")\npublic class Demo01Session extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //使用Session共享数据\n\n        //1.获取Session\n        HttpSession session = request.getSession();\n        //2.存储数据\n        session.setAttribute(\"msg\",\"Hello Session\");\n\n    }\n}\n```\n\n访问上一个页面的时候，获取到session，并存储了数据\n\n```java\n@WebServlet(\"/demo02Session\")\npublic class Demo02Session extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //使用Session共享数据\n\n        //1.获取Session\n        HttpSession session = request.getSession();\n\n        //2.获取数据\n        Object msg = session.getAttribute(\"msg\");\n        System.out.println(msg);\n\n    }\n}\n```\n\n访问demo02Session，即可获取到session中存储的数据。\n\n> 如果客户端关闭之后，则再次获取数据，会获取到null\n\n## 4.2 实现原理\n\n**<u>Session是依赖于Cookie的！</u>**\n\n初次访问服务器，获取Session，没有Cookie。会在内存中创建一个新的Session对象，该Session对象有唯一的id（jsp的话就是JSESSIONID；如果是php，会是PHPSESSID），然后将该id以set-cookie的形式返回给客户端。\n\n{% asset_img 10.png %}\n\n二次访问服务器，请求头cookie中就会携带该Session对象的id，然后服务器根据id来判断获取的是哪个Session对象\n\n{% asset_img 11.png %}\n\n## 4.3 Session细节\n\n1. 客户端关闭后，服务器不关闭，两次获取到的Session默认**不是同一个**\n   * 如果需要相同，则可以创建Cookie，键为JSESSIONID，并且设置最大存活时间，让Cookie持久保存\n2. 客户端不关闭，服务器关闭后，两次获取到的Session不是同一个\n   * 那么如何在服务器关闭后保持数据不丢失？\n     * Session钝化\n       * 在服务器正常关闭之前，将session对象存储到硬盘上\n     * Session活化\n       * 在服务器启动后，将session文件转化为内容中的session对象即可\n3. Session的销毁\n   * 默认情况下，服务器关闭\n   * session对象调用invalidate()\n   * session默认失效时间为30分钟\n     * 可以在web.xml进行选择性修改\n\nSession的钝化和活化，在本地Tomcat中是可以自动完成的，在idea的集成环境下，是不可以的。在服务器正常关闭的时候，Tomcat会自动在work目录下生成SESSIONS.ser，当服务器再次启动时，会将该文件读取到内存并删除。[javaweb之session序列化与反序列化](https://blog.csdn.net/wjw0130/article/details/45766709)\n\n{% asset_img 12.png %}\n\n## 4.4 Session的特点\n\n特点\n\n1. session用于存储一次会话的多次请求的数据，存在服务器端\n2. session可以存储任意类型，任意大小\n\n## 4.5 Session与Cookie区别\n\n区别\n\n1. Session存储在服务器端，Cookie存储在客户端\n2. Session没有数据大小限制，Cookie有大小限制\n3. 相对来说，Session比较安全，Cookie不太安全\n\n## 4.6 案例-验证码\n\n### 需求\n\n1. 访问带有验证码的登录页面login.jsp\n2. 用户输入用户名、密码以及验证码\n   * 若用户名和密码输入有误，跳转登录页面，提示**用户名或密码错误**\n   * 如果验证码输入有误，跳转登录页面，提示**验证码错误**\n   * 如果全部正确，跳转主页success.jsp，提示**用户名，欢迎你**\n\n分析\n\n1. 设置request编码\n2. 获取参数Map集合\n3. 获取验证码\n4. 将用户信息封装到User对象\n5. 判断程序生成的验证码和用户输入的验证码是否一致（从Session中获取程序生成的随机验证码）\n   * 不一致\n     * 给用户提示信息\n     * 跳转登录页面：转发\n   * 一致\n     * 判断用户名和密码\n       * 正确\n       * 不正确\n\n### 实现\n\nlogin.jsp\n\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>登录</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n        }\n\n        .box {\n            background-color: #74C3B5;\n            color: #fff;\n            width:100vw;\n            height:100vh;\n            position:fixed;\n        }\n        .container {\n            width: 600px;\n            margin: 80px auto;\n            text-align: center;\n        }\n\n        .logo {\n            width: 250px;\n            height: 70px;\n            margin: auto;\n            border-radius: 5px;\n            margin-bottom: 40px;\n            font-size:44px;\n        }\n\n\n        input {\n            color: #fff;\n            width: 250px;\n            height: 40px;\n            /*opacity:.5;*/\n            transition: all ease .4s;\n            background-color: rgba(255, 255, 255, .2);\n            text-align: center;\n            font-size: 20px;\n            border: 2px solid rgba(255, 255, 255, .4);\n            outline: none;\n            border-radius: 5px;\n        }\n        img {\n            outline: 0;\n            border: 1px solid rgba(255, 255, 255, 0.4);\n            background-color: rgba(255, 255, 255, 0.2);\n            width: 250px;\n            height: 70px;\n            border-radius: 3px;\n            padding: 5px 8px;\n            margin: 0 auto 5px auto;\n            display: block;\n            text-align: center;\n            color: white;\n            opacity: .9;\n            box-sizing: border-box;\n        }\n\n        input:focus {\n            color: #75DFB7;\n            width: 300px;\n            background-color: #fff;\n        }\n\n        button {\n            width: 250px;\n            height: 40px;\n            border: none;\n            background-color: rgba(255, 255, 255, .9);\n            font-size: 20px;\n            color: #75DFB7;\n            cursor: pointer;\n            border-radius: 5px;\n        }\n\n        ul {\n            list-style: none;\n        }\n\n        li {\n            line-height: 50px;\n        }\n\n        form a {\n            text-decoration: none;\n            color: #fff;\n        }\n\n        input::placeholder {\n            color:#fff;\n        }\n        .bg-bubbles {\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            z-index: 1;\n            pointer-events: none;\n        }\n        .bg-bubbles li {\n            position: absolute;\n            list-style: none;\n            display: block;\n            width: 40px;\n            height: 40px;\n            background-color: rgba(255, 255, 255, 0.15);\n            bottom: -160px;\n            -webkit-animation: square 25s infinite;\n            animation: square 25s infinite;\n            -webkit-transition-timing-function: linear;\n            transition-timing-function: linear;\n        }\n        .bg-bubbles li:nth-child(1) {\n            left: 10%;\n        }\n        .bg-bubbles li:nth-child(2) {\n            left: 20%;\n            width: 80px;\n            height: 80px;\n            -webkit-animation-delay: 2s;\n            animation-delay: 2s;\n            -webkit-animation-duration: 17s;\n            animation-duration: 17s;\n        }\n        .bg-bubbles li:nth-child(3) {\n            left: 25%;\n            -webkit-animation-delay: 4s;\n            animation-delay: 4s;\n        }\n        .bg-bubbles li:nth-child(4) {\n            left: 40%;\n            width: 60px;\n            height: 60px;\n            -webkit-animation-duration: 22s;\n            animation-duration: 22s;\n            background-color: rgba(255, 255, 255, 0.25);\n        }\n        .bg-bubbles li:nth-child(5) {\n            left: 70%;\n        }\n        .bg-bubbles li:nth-child(6) {\n            left: 80%;\n            width: 120px;\n            height: 120px;\n            -webkit-animation-delay: 3s;\n            animation-delay: 3s;\n            background-color: rgba(255, 255, 255, 0.2);\n        }\n        .bg-bubbles li:nth-child(7) {\n            left: 32%;\n            width: 160px;\n            height: 160px;\n            -webkit-animation-delay: 7s;\n            animation-delay: 7s;\n        }\n        .bg-bubbles li:nth-child(8) {\n            left: 55%;\n            width: 20px;\n            height: 20px;\n            -webkit-animation-delay: 15s;\n            animation-delay: 15s;\n            -webkit-animation-duration: 40s;\n            animation-duration: 40s;\n        }\n        .bg-bubbles li:nth-child(9) {\n            left: 25%;\n            width: 10px;\n            height: 10px;\n            -webkit-animation-delay: 2s;\n            animation-delay: 2s;\n            -webkit-animation-duration: 40s;\n            animation-duration: 40s;\n            background-color: rgba(255, 255, 255, 0.3);\n        }\n        .bg-bubbles li:nth-child(10) {\n            left: 90%;\n            width: 160px;\n            height: 160px;\n            -webkit-animation-delay: 11s;\n            animation-delay: 11s;\n        }\n        @-webkit-keyframes square {\n            0% {\n                -webkit-transform: translateY(0);\n                transform: translateY(0);\n            }\n            100% {\n                -webkit-transform: translateY(-700px) rotate(600deg);\n                transform: translateY(-700px) rotate(600deg);\n            }\n        }\n        @keyframes square {\n            0% {\n                -webkit-transform: translateY(0);\n                transform: translateY(0);\n            }\n            100% {\n                -webkit-transform: translateY(-700px) rotate(600deg);\n                transform: translateY(-700px) rotate(600deg);\n            }\n        }\n        error {\n            color:deeppink;\n        }\n    </style>\n</head>\n<body>\n<%\n    String login_error = (String) request.getAttribute(\"login_error\");\n    String cc_error = (String) request.getAttribute(\"cc_error\");\n%>\n<div class=\"box\">\n    <div class=\"container\">\n        <div class=\"logo\">\n            神话Q传\n        </div>\n        <%\n            if(login_error!=null){\n                out.write(\"<error>\"+login_error+\"</error>\");\n            }\n            if(cc_error!=null){\n                out.write(\"<error>\"+cc_error+\"</error>\");\n            }\n        %>\n        <form action=\"/session/loginServlet\" method=\"post\">\n            <ul>\n                <li><input type=\"text\" name=\"username\" placeholder=\"用户名\" autocomplete=\"off\"></li>\n                <li><input type=\"text\" name=\"password\" placeholder=\"密码\" autocomplete=\"off\"></li>\n                <li><input type=\"text\" name=\"checkcode\" placeholder=\"不区分大小写\"></li>\n                <li><img id=\"checkcode\" src=\"/session/checkCodeServlet\" alt=\"\"></li>\n                <li>\n                    <button>登录</button>\n                </li>\n            </ul>\n        </form>\n    </div>\n    <ul class=\"bg-bubbles\">\n        <li></li>\n        <li></li>\n        <li></li>\n        <li></li>\n        <li></li>\n        <li></li>\n        <li></li>\n        <li></li>\n        <li></li>\n        <li></li>\n    </ul>\n</div>\n<script>\n    document.querySelector(\"#checkcode\").onclick=function (){\n        let url = \"/session/checkCodeServlet\";\n        let date=new Date().getTime();\n        this.setAttribute(\"src\", url+\"?\"+date)\n    }\n</script>\n</body>\n</html>\n```\n\nCheckCodeServlet.java\n\n```java\n@WebServlet(\"/session/checkCodeServlet\")\npublic class CheckCodeServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        int width=100;\n        int height=30;\n        //1.创建对象，在内存中画图（验证码图片对象）\n        BufferedImage image=new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);\n        //2.美化图片\n        //2.1填充背景色\n        Graphics g=image.getGraphics();//绘图对象\n        g.setColor(new Color(255,255,255,255));\n        g.fillRect(0,0,width,height);\n        //2.2画边框\n        g.setColor(Color.RED);\n        g.drawRect(0,0,width-1,height-1);\n        //2.3写验证码\n        String str=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz\";\n        Random r=new Random();\n        //StringBuilder在处理多个字符串拼接的时候，效率要比+拼接要高很多。\n        StringBuilder stringBuilder = new StringBuilder();\n        for (int i = 0; i < 4; i++) {\n            //设置字体,绘制字符\n            g.setFont(new Font(Font.SANS_SERIF,Font.BOLD,20));\n            char c = str.charAt(r.nextInt(str.length()));\n            stringBuilder.append(c);\n            g.drawString(String.valueOf(c),width/5*(i+1),height/2+10);\n        }\n        //将验证码存入session\n        String checkcode=stringBuilder.toString();\n        request.getSession().setAttribute(\"checkcode\",checkcode);\n        //2.4 画干扰线\n        g.setColor(Color.green);\n        for (int i = 0; i < 10; i++) {\n            int x1=r.nextInt(width);\n            int y1=r.nextInt(height);\n            int x2=r.nextInt(width);\n            int y2=r.nextInt(height);\n            g.drawLine(x1,y1,x2,y2);//画线\n            //画点\n//            g.drawOval(x1,y1,5,5);\n//            g.fillOval(x1,y1,5,5);\n//            g.drawOval(x2,y2,5,5);\n//            g.fillOval(x2,y2,5,5);\n        }\n        //3.将图片输出到页面展示\n        ImageIO.write(image,\"jpg\",response.getOutputStream());\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request,response);\n    }\n}\n```\n\nLoginServlet.java\n\n```java\n@WebServlet(\"/session/loginServlet\")\npublic class LoginServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n//        1. 设置request编码\n        request.setCharacterEncoding(\"utf-8\");\n        HttpSession session = request.getSession();\n//        2. 获取参数Map集合\n//        Map<String, String[]> map = request.getParameterMap();\n        String username = request.getParameter(\"username\");\n        String password = request.getParameter(\"password\");\n        String checkcode = request.getParameter(\"checkcode\");\n//        3. 获取验证码\n        String code = (String)session.getAttribute(\"checkcode\");\n        //这是为了使验证码保持一次性使用\n        session.removeAttribute(\"checkcode\");\n        //忽略大小写\n        if(code!=null&&code.equalsIgnoreCase(checkcode)){\n            if(\"胡列娜\".equals(username)&&\"fairy\".equals(password)){\n                //存储信息\n                session.setAttribute(\"user\",username);\n                //重定向\n                response.sendRedirect(\"/session/success.jsp\");\n            }else{\n                //存储信息\n                request.setAttribute(\"login_error\",\"用户名或者密码错误\");\n                //转发\n                request.getRequestDispatcher(\"/session/login.jsp\").forward(request,response);\n            }\n        }else{\n            //存储信息\n            request.setAttribute(\"cc_error\",\"验证码错误\");\n            //转发\n            request.getRequestDispatcher(\"/session/login.jsp\").forward(request,response);\n        }\n//        4. 将用户信息封装到User对象\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n}\n```\n\nsuccess.jsp\n\n```java\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>主页</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n        }\n\n        .box {\n            background-color: #74C3B5;\n            color: #fff;\n            width:100vw;\n            height:100vh;\n            position:fixed;\n        }\n    </style>\n</head>\n<body>\n<div class=\"box\">\n    <%\n        String user= (String) request.getSession().getAttribute(\"user\");\n        if(user!=null){\n            out.write(user+\",欢迎您\");\n        }else{\n            response.sendRedirect(\"/session/login.jsp\");\n        }\n    %>\n</div>\n</body>\n</html>\n```\n\n{% asset_img 13.png %}\n\n> 这个页面是我原来模仿一个网页游戏写的一个页面，今天无意间发现了那么久远的代码，就直接拿来用了。\n\n### 问题\n\n验证码重复使用的问题已经解决了。\n\n还有一个问题，就是如果用户直接访问LoginServlet会报错，这个是直接将LoginServlet摆在了明面上，这样做是不太好的，实际开发中，可以异步请求LoginServlet，而LoginServlet只需返回结果即可。这样应该会相对更安全易用","tags":["web","jsp"]},{"title":"今日校园实现自动监测并提交最新签到","url":"/blog/2020/cpdaily-sign/","content":"\n之前未开学之前，是信息表采集，开学之后，改成了循环签到，那就想着再写个脚本\n\n<!--more-->\n\n站在巨人的肩膀上，所以该代码全部开源，我也借鉴的大佬的东西，放在第三节致谢。有问题可以在下面进行留言讨论！\n\n[源码](https://github.com/meethigher/cpdaily-sign)\n\n[博客地址](https://meethigher.top/blog/2020/cpdaily-sign/)\n\n# 一、开发流程\n\n## 1.1 思路\n\n1. 抓包（抓包的流程，可以参照我之前的[文章](https://meethigher.top/blog/2020/cpdaily-automation/)）\n2. 每日接口获取最新表单\n3. 通过上步的id获取详细表单\n4. 通过上步获取该表单的选项id\n\n如果整体的思路看不明白，可以参照下面的详细步骤\n\n## 2.1 获取最新表单\n\n接口\n\n```html\n/wec-counselor-sign-apps/stu/sign/getStuSignInfosInOneDay\n```\n\n参数\n\n```json\n{}\n```\n\n返回值\n\n```json\n{\n\t\"code\": \"0\",\n\t\"message\": \"SUCCESS\",\n\t\"datas\": {\n\t\t\"dayInMonth\": \"2020-09-10\",\n\t\t\"codeRcvdTasks\": [],\n\t\t\"signedTasks\": [],\n\t\t\"unSignedTasks\": [{\n\t\t\t\"stuSignWid\": \"746210\",\n\t\t\t\"signInstanceWid\": \"4146\", //需要\n\t\t\t\"signWid\": \"514213\", //需要\n\t\t\t\"signRate\": \"1\",\n\t\t\t\"taskType\": \"4\",\n\t\t\t\"taskName\": \"一日三签（早签到）\",\n\t\t\t\"senderUserName\": \"牛逼学院(牛逼老师)\",\n\t\t\t\"signStatus\": \"2\",\n\t\t\t\"isMalposition\": null,\n\t\t\t\"isLeave\": \"0\",\n\t\t\t\"leavePcUrl\": null,\n\t\t\t\"leaveMobileUrl\": null,\n\t\t\t\"currentTime\": \"2020-09-10 08:15\",\n\t\t\t\"singleTaskBeginTime\": null,\n\t\t\t\"singleTaskEndTime\": null,\n\t\t\t\"rateSignDate\": \"2020-09-10 (周四)\",\n\t\t\t\"rateTaskBeginTime\": \"05:00\",\n\t\t\t\"rateTaskEndTime\": \"09:59\"\n\t\t}, {\n\t\t\t\"stuSignWid\": \"759720\",\n\t\t\t\"signInstanceWid\": \"4199\",\n\t\t\t\"signWid\": \"514234\",\n\t\t\t\"signRate\": \"1\",\n\t\t\t\"taskType\": \"4\",\n\t\t\t\"taskName\": \"一日三签（午签到）\",\n\t\t\t\"senderUserName\": \"牛逼学院(牛逼老师)\",\n\t\t\t\"signStatus\": \"2\",\n\t\t\t\"isMalposition\": null,\n\t\t\t\"isLeave\": \"0\",\n\t\t\t\"leavePcUrl\": null,\n\t\t\t\"leaveMobileUrl\": null,\n\t\t\t\"currentTime\": \"2020-09-10 08:15\",\n\t\t\t\"singleTaskBeginTime\": null,\n\t\t\t\"singleTaskEndTime\": null,\n\t\t\t\"rateSignDate\": \"2020-09-10 (周四)\",\n\t\t\t\"rateTaskBeginTime\": \"10:00\",\n\t\t\t\"rateTaskEndTime\": \"15:59\"\n\t\t}, {\n\t\t\t\"stuSignWid\": \"778325\",\n\t\t\t\"signInstanceWid\": \"4266\",\n\t\t\t\"signWid\": \"535128\",\n\t\t\t\"signRate\": \"1\",\n\t\t\t\"taskType\": \"4\",\n\t\t\t\"taskName\": \"一日三签（晚签到）\",\n\t\t\t\"senderUserName\": \"牛逼学院(牛逼老师)\",\n\t\t\t\"signStatus\": \"2\",\n\t\t\t\"isMalposition\": null,\n\t\t\t\"isLeave\": \"0\",\n\t\t\t\"leavePcUrl\": null,\n\t\t\t\"leaveMobileUrl\": null,\n\t\t\t\"currentTime\": \"2020-09-10 08:15\",\n\t\t\t\"singleTaskBeginTime\": null,\n\t\t\t\"singleTaskEndTime\": null,\n\t\t\t\"rateSignDate\": \"2020-09-10 (周四)\",\n\t\t\t\"rateTaskBeginTime\": \"16:00\",\n\t\t\t\"rateTaskEndTime\": \"22:00\"\n\t\t}],\n\t\t\"leaveTasks\": []\n\t}\n}\n```\n\n其中我们需要获取`signWid`514213和`signInstanceWid`4146\n\n## 2.2 获取详细信息\n\n接口\n\n```html\n/wec-counselor-sign-apps/stu/sign/detailSignInstance\n```\n\n参数\n\n```json\n{\n  \"signWid\" : 514213,\n  \"signInstanceWid\" : 4146\n}\n```\n\n返回值\n\n```json\n{\n  \"message\" : \"SUCCESS\",\n  \"datas\" : {\n    \"latitude\" : \"\",\n    \"singleTaskEndTime\" : null,\n    \"catQrUrl\" : \"https:\\/\\/cat.cpdaily.com\\/erweima\",\n    \"singleTaskBeginTime\" : null,\n    \"signInstanceWid\" : \"4146\",\n    \"signPhotoUrl\" : null,\n    \"signTime\" : null,\n    \"senderUserName\" : \"牛逼学院(牛逼老师)\",\n    \"qrCodeRcvdUsers\" : [\n      {\n        \"targetWid\" : \"91457111\",\n        \"targetType\" : \"4\",\n        \"targetName\" : \"牛逼老师\\/19070302\",\n        \"targetGrade\" : \"-1\",\n        \"targetDegree\" : \"-1\",\n        \"targetUserType\" : \"-1\"\n      }\n    ],\n    \"isNeedExtra\" : 1,\n    \"signCondition\" : 0,\n    \"currentTime\" : \"2020-09-10 09:33:08\",\n    \"taskDesc\" : \"https:\\/\\/wecres.cpdaily.com\\/counselor\\/1018615876819107\\/content\\/54e503639d0244049c3b85baabe509fc.html\",\n    \"signType\" : null,\n    \"changeActorName\" : \"牛逼老师\",\n    \"isMalposition\" : 0,\n    \"longitude\" : \"\",\n    \"signedStuInfo\" : {\n      \"cls\" : \"20200521\",\n      \"major\" : \"改变世界专业-牛逼\",\n      \"dept\" : \"牛逼学院\",\n      \"sex\" : \"男\",\n      \"mobile\" : null,\n      \"nation\" : \"-\",\n      \"userWid\" : \"1017790009\",\n      \"userId\" : \"20200521\",\n      \"userName\" : \"雷军\",\n      \"malposition\" : null,\n      \"extraFieldItemVos\" : [\n        {\n          \"fieldIndex\" : 0,\n          \"extraDesc\" : \"\",\n          \"extraFieldItemWid\" : \"\",\n          \"extraTitle\" : \"体温\",\n          \"extraFieldItem\" : null,\n          \"isExtraFieldOtherItem\" : \"0\",\n          \"isAbnormal\" : \"0\"\n        },\n        {\n          \"fieldIndex\" : 0,\n          \"extraDesc\" : \"\",\n          \"extraFieldItemWid\" : \"\",\n          \"extraTitle\" : \"身体是否异常\",\n          \"extraFieldItem\" : null,\n          \"isExtraFieldOtherItem\" : \"0\",\n          \"isAbnormal\" : \"0\"\n        }\n      ],\n      \"schoolStatus\" : null,\n      \"stuDormitoryVo\" : {\n        \"sex\" : \"\",\n        \"area\" : \"\",\n        \"building\" : \"\",\n        \"unit\" : \"\",\n        \"room\" : \"\"\n      },\n      \"grade\" : \"2019级\"\n    },\n    \"extraFieldItemVos\" : [\n\n    ],\n    \"changeTime\" : null,\n    \"taskType\" : \"4\",\n    \"photograph\" : [\n\n    ],\n    \"signRate\" : \"1\",\n    \"isPhoto\" : 0,\n    \"signAddress\" : null,\n    \"rateTaskEndTime\" : \"09:59\",\n    \"taskName\" : \"一日三签（早签到）\",\n    \"leaveAppUrl\" : \"\\/wec-counselor-leave-apps\\/leave\\/home\\/index.html\",\n    \"isAllowUpdate\" : false,\n    \"signMode\" : 0,\n    \"rateTaskBeginTime\" : \"05:00\",\n    \"signStatus\" : \"2\",\n    \"signPlaceSelected\" : [\n      {\n        \"address\" : \"只有野鸡学校才用这个流氓app（北界王西区）\",\n        \"radius\" : 520,\n        \"longitude\" : \"125.398185\",\n        \"placeWid\" : null,\n        \"creatorUserWid\" : null,\n        \"creatorName\" : null,\n        \"wid\" : null,\n        \"latitude\" : \"44.001709\",\n        \"currentStatus\" : null,\n        \"isShare\" : null,\n        \"creatorUserId\" : null\n      },\n      {\n        \"address\" : \"只有野鸡学校才用这个流氓app（北界王东区）\",\n        \"radius\" : 500,\n        \"longitude\" : \"125.40993457956229\",\n        \"placeWid\" : null,\n        \"creatorUserWid\" : null,\n        \"creatorName\" : null,\n        \"wid\" : null,\n        \"latitude\" : \"44.00262969203334\",\n        \"currentStatus\" : null,\n        \"isShare\" : null,\n        \"creatorUserId\" : null\n      },\n      {\n        \"address\" : \"只有野鸡学校才用这个流氓app（南界王校区）\",\n        \"radius\" : 400,\n        \"longitude\" : \"125.296568\",\n        \"placeWid\" : null,\n        \"creatorUserWid\" : null,\n        \"creatorName\" : null,\n        \"wid\" : null,\n        \"latitude\" : \"43.859918\",\n        \"currentStatus\" : null,\n        \"isShare\" : null,\n        \"creatorUserId\" : null\n      }\n    ],\n    \"rateSignDate\" : \"2020-09-10 (周四)\",\n    \"extraField\" : [\n      {\n        \"hasOtherItems\" : 0,\n        \"title\" : \"体温\",\n        \"extraFieldItems\" : [\n          {\n            \"isSelected\" : null,\n            \"value\" : null,\n            \"content\" : \"37.3度以下\",\n            \"isOtherItems\" : 0,\n            \"wid\" : 499882,//获取\n            \"isAbnormal\" : false\n          },\n          {\n            \"isSelected\" : null,\n            \"value\" : null,\n            \"content\" : \"37.3度及以上\",\n            \"isOtherItems\" : 0,\n            \"wid\" : 499883,\n            \"isAbnormal\" : true\n          }\n        ],\n        \"description\" : \"\",\n        \"wid\" : 211814\n      },\n      {\n        \"hasOtherItems\" : 1,\n        \"title\" : \"身体是否异常\",\n        \"extraFieldItems\" : [\n          {\n            \"isSelected\" : null,\n            \"value\" : null,\n            \"content\" : \"健康\",\n            \"isOtherItems\" : 0,\n            \"wid\" : 499884,//获取\n            \"isAbnormal\" : false\n          },\n          {\n            \"isSelected\" : null,\n            \"value\" : null,\n            \"content\" : \"感冒\",\n            \"isOtherItems\" : 0,\n            \"wid\" : 499885,\n            \"isAbnormal\" : false\n          },\n          {\n            \"isSelected\" : null,\n            \"value\" : null,\n            \"content\" : \"发烧\",\n            \"isOtherItems\" : 0,\n            \"wid\" : 499886,\n            \"isAbnormal\" : false\n          },\n          {\n            \"isSelected\" : null,\n            \"value\" : null,\n            \"content\" : \"咳嗽\",\n            \"isOtherItems\" : 0,\n            \"wid\" : 499887,\n            \"isAbnormal\" : false\n          },\n          {\n            \"isSelected\" : null,\n            \"value\" : null,\n            \"content\" : \"其它\",\n            \"isOtherItems\" : 1,\n            \"wid\" : 499888,\n            \"isAbnormal\" : false\n          }\n        ],\n        \"description\" : \"\",\n        \"wid\" : 211815\n      }\n    ],\n    \"downloadUrl\" : \"https:\\/\\/img.cpdaily.com\\/ldy\\/index.html\"\n  },\n  \"code\" : \"0\"\n}\n```\n\n获取我需要的两个参数，`体温选项`499882和`身体是否异常选项`499884\n\n## 2.3 模拟提交\n\n最后通过上面步骤获取到的4146,499882,499884以及自定义的地址，进行签到\n\n接口\n\n```html\n/wec-counselor-sign-apps/stu/sign/submitSign\n```\n\n参数\n\n```json\n{\n\t\"abnormalReason\": \"\",\n\t\"position\": \"你的地址\",\n\t\"longitude\": 你的经度,\n\t\"isNeedExtra\": 1,\n\t\"latitude\": 你的纬度,\n\t\"isMalposition\": 0,\n\t\"extraFieldItems\": [{\n\t\t\t\"extraFieldItemWid\": 499882,\n\t\t\t\"extraFieldItemValue\": \"37.3度以下\"\n\t\t},\n\t\t{\n\t\t\t\"extraFieldItemWid\": 499884,\n\t\t\t\"extraFieldItemValue\": \"健康\"\n\t\t}\n\t],\n\t\"signInstanceWid\": \"4146\",\n\t\"signPhotoUrl\": \"\"\n}\n```\n\n返回值\n\n```json\n{\n  \"message\" : \"SUCCESS\",\n  \"datas\" : {\n    \"signedStuInfo\" : null,\n    \"signInstanceWid\" : \"4146\"\n  },\n  \"code\" : \"0\"\n}\n```\n\n# 二、运行结果\n\n![](https://meethigher.top/blog/2020/cpdaily-sign/1.png)\n\n# 三、致谢\n\n1. [ZimoLoveShuang](https://github.com/ZimoLoveShuang/auto-sign/)\n\n","tags":["java","open"]},{"title":"今日校园实现自动监测并提交最新表单","url":"/blog/2020/cpdaily-automation/","content":"\n这个软件，有个bug，通知栏没法直接跳转。我反馈了一个多月，还是暂未受理。\n\n而且，这个软件会一直在后台请求启动手机上其他app，限制读取应用列表也没用，不知道他想干啥。\n\n不管了，反正已经卸载了。\n\n<!--more-->\n\n站在巨人的肩膀上，我所写的东西，也会开源分享出来！\n\n授人以鱼不如授人以渔，我把思路分享出来。\n\n将源码放在这里[今日校园实现自动检测并提交最新表单](https://github.com/meethigher/cpdaily-submit)，也可以来[这里](https://www.bilibili.com/video/BV1tQ4y1N7XQ)给我的视频点个赞吖！\n\n{% asset_img 8.png 提交 %}\n\n{% asset_img 9.png 邮件 %}\n\n# 一、抓包（重点）\n\n## 1.1 如何抓包\n\nFiddler4电脑端与手机端抓包的教程，我不多bb了。点这个[链接](https://blog.csdn.net/c406495762/article/details/76850843)里面有具体步骤，这个大佬是专门学习机器学习的，他的博客放到[这里](https://cuijiahua.com/)。\n\n一开始，我是用的Fiddler4来进行抓包的，但是涉及到ssl-pinning的问题。导致抓包失败，也就是抓取过程中，一堆灰色链接。同时，手机上的网路也会被断开。\n\nfiddler抓包中遇到的问题\n\n[无法抓https](https://www.jianshu.com/p/7242d4e8b179)\n\n[android7+用户级证书不被信任](https://www.jianshu.com/p/59fd5af2eade)\n\n[fiddler使用介绍](https://blog.51cto.com/fresscale/1912943)\n\n{% asset_img 1.png 失败 %}\n\n之后，我就开始考虑，要不用手机抓包，就下载了[HttpCannary](https://github.com/MegatronKing/HttpCanary)，HttpCanary有普通版和高级版之分，建议下载高级版，同样会遇到ssl-pinning的问题，具体解决方法请移步到[系统证书的安装，解决APP抓不到包](https://www.bilibili.com/video/BV1Qe411s7q9?from=search&seid=10930251094898400074)，下载软件点[这里](https://lanzous.com/b0c2a09rg)\n\n## 1.2 我的解决方法\n\n此节是废话，请略过。\n\n我一开始用幸运破解器，很幸运的是，虽然显示破解授权失败，但打开的时候，发现能用了。\n\n下一步，就是安装系统证书了，我就把手机root了，我的手机是小米的，直接root就行。\n\n{% asset_img 2.jpg root %}\n\n但是，还是在安装系统证书的过程中出了问题，不能往系统里面移动证书，原因是没有权限。\n\n后来百度了一下，发现，MIUI的root权限，从Android7之后，就没有完整的root权限了。除非刷第三方系统。\n\n但是我又舍不得自己的MIUI12。\n\n接下来，就准备用模拟器了，我下载的是[逍遥安卓模拟器](http://www.xyaz.cn/)。安卓的是4.4版本系统，刷入了[xposed框架](http://xposed.appkg.com/)，安装了[justtrustme模块](https://github.com/Fuzion24/JustTrustMe)。\n\n然后，打开Fiddler抓包，Yes！\n\n有了Cpdaily-Extension跟MOD_AUTH_CAS这两条数据，就能模拟提交了。\n\n> 此处是2020年5月30日更新，用android4.4毕竟不是个好的解决办法，因为现在好多app已经不支持旧版了。那么还得需要root。\n>\n> 我手机是android10，想要抓加密包的话，就得安装系统证书，安装到系统文件下。\n>\n> 经过一番折腾，成功了。具体过程看[博客](https://meethigher.top/blog/2020/root/)\n\n抓包问题就此解决。耗费了我一整天的时间。\n\n提交过程中碰到的坑：\n\n1. 今日校园版本过低。这是因为你提交的内容格式不对，按抓包的流程来一遍。\n2. 返回乱码消息。这是因为提交的表单内容，中文部分出现了编码问题，建议以utf-8格式发送。\n\n# 二、Java模拟post请求\n\n这个算是套模板吧，都是这个套路，直接上代码。不要拿来就用，还是根据实际情况进行修改的。\n\n```java\n/**\n * HttpUtil类\n * @author kit chen\n * @description 用来模拟发送post请求\n */\npublic class HttpUtil {\n\tpublic static String sendPost(String url, String param,Map<String,String> headers) {\n\t\tBufferedWriter out = null;\n\t\tBufferedReader in = null;\n\t\tString result = \"\";\n\t\ttry {\n\t\t\tURL realUrl = new URL(url);\n\t\t\tURLConnection conn = realUrl.openConnection();\n\t\t\tSet<Entry<String, String>> set=headers.entrySet();\n\t\t\tfor(Entry<String,String> header:set) {\n\t\t\t\tconn.setRequestProperty(header.getKey(), header.getValue());\n\t\t\t}\n\t\t\tconn.setDoOutput(true);\n\t\t\tconn.setDoInput(true);\n\t\t\tout = new BufferedWriter(new OutputStreamWriter(conn.getOutputStream(), \"utf-8\"));\n\t\t\tout.write(param);\n\t\t\tout.flush();\n\t\t\tin = new BufferedReader(new InputStreamReader(conn.getInputStream(), \"utf-8\"));\n\t\t\tString line;\n\t\t\twhile ((line = in.readLine()) != null) {\n\t\t\t\tresult += line;\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(\"发送 POST 请求出现异常！\" + e);\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (out != null) {\n\t\t\t\t\tout.close();\n\t\t\t\t}\n\t\t\t\tif (in != null) {\n\t\t\t\t\tin.close();\n\t\t\t\t}\n\t\t\t} catch (IOException ex) {\n\t\t\t\tex.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n```\n\n# 三、模拟请求中的问题\n\n通过抓包获取了请求头跟请求参数，请求参数还好说。\n\n在抓取请求头的时候，遇到了点问题。\n\n通过测试发现，如果想要成功提交内容，需要Cpdaily-Extension跟MOD_AUTH_CAS。\n\n如果设备不去主动退出的话，Cpdaily-Extension是会**一直存在有效**的。类似的像QQ也是这样的。我在抓取Cpdaily-Extension的过程中，尝试访问各种页面，但是都没法获取到这个的值。哪怕是在登录的时候，也没有这个参数。只有在提交的时候，才能抓取到。\n\n像MOD_AUTH_CAS这个的值，类似于session，是有有效期的。我目前还没有测试一直让这个东西保持有效。这个值，大概6个小时左右，就会失效了，需要重新登录网页获取。\n\n问了大佬，好像是涉及到了[cas单点登录](https://blog.csdn.net/anumbrella/article/details/80821486)的知识，这块我也不懂。学！\n\n{% asset_img 2.png 知识盲点 %}\n\n# 四、监测表单并返回表单号\n\n今日校园有个获取今日最新表单的接口，如果没有的话，里面某个数据会是个空数组。\n\n接口\n\n```text\n/wec-counselor-collector-apps/stu/collector/queryCollectorProcessingList\n```\n\npost的请求参数\n\n```json\n{\"pageSize\": 6,\"pageNumber\": 1}\n```\n\n这个pageSize是指返回几条数据，响应请求中，我记得返回的json字符串，最多就只有6个参数，所以这个传个6就行了。大于等于6\n\n返回的内容\n\n```json\n{\n\t\"code\": \"0\",\n\t\"message\": \"SUCCESS\",\n\t\"datas\": {\n\t\t\"totalSize\": 0,\n\t\t\"pageSize\": 6,\n\t\t\"pageNumber\": 1,\n\t\t\"rows\": [\n            \"wid\":\"xx\",\n            \"formWid\":\"xx\",\n            \"isHandled\":\"0\"\n            \"...\":\"...\"\n        ]\n\t}\n}\n```\n\n我们要的就是这个wid、formWid跟isHandled。isHandled表示是否提交，非0为提交。\n\n监测到有rows有数据，并且isHandled未提交的时候，我们就可以进行模拟提交了。\n\n# 五、获取学校表单号\n\n这个还有一个坑就是，每天的学校的表单号schoolTaskWid不是固定的，由此，我们就需要来模拟请求来获取schoolTaskWid\n\n接口\n\n```text\n/wec-counselor-collector-apps/stu/collector/detailCollector\n```\n\npost请求参数 \n\n```json\n{\"collectorWid\": 传进来第三步获取的collectWid}`\n```\n\n> 注意：\n>\n> 这sb接口开发者，一开始定义的是collectWid，结果后面又成了collectorWid，一开始在这边把我给坑了，需要注意。\n>\n> 这个接口获取的是collectorWid，第三步获取的是collectWid，其实他俩是一个东西。\n\n大致的返回内容\n\n```json\n{\n\t\"code\": \"0\",\n\t\"message\": \"SUCCESS\",\n\t\"datas\": {\n\t\t\"collector\": {\n\t\t\t\"wid\": \"8888\",\n\t\t\t\"formWid\": \"164\",\n\t\t\t\"priority\": \"5\",\n\t\t\t\"endTime\": \"8888-88-88 88:00:00\",\n\t\t\t\"currentTime\": \"8888-88-88 88:00:00\",\n\t\t\t\"schoolTaskWid\": \"8888\",\n\t\t\t\"isConfirmed\": 1,\n\t\t\t\"senderUserName\": \"牛逼学院(牛逼老师)\",\n\t\t\t\"createTime\": \"8888-88-88 88:00:00\",\n\t\t\t\"attachmentUrls\": null,\n\t\t\t\"attachmentNames\": null,\n\t\t\t\"attachmentSizes\": null,\n\t\t\t\"isUserSubmit\": 1,\n\t\t\t\"fetchStuLocation\": true,\n\t\t\t\"address\": \"xx省xx市xx县\" \n\t\t},\n\t\t\"form\": {\n\t\t\t\"wid\": \"164\",\n\t\t\t\"formTitle\": \"8月8日学生身体健康状况调查\",\n\t\t\t\"formContent\": \"https://wecres.cpdaily.com/counselor/1076158768111098/content/d1c0daf5604af56fbccfadaf28cdbd82.html\",\n\t\t\t\"backReason\": null,\n\t\t\t\"isBack\": 0,\n\t\t\t\"attachments\": []\n\t\t}\n\t}\n}\n```\n\n这里我们获取需要的schoolTaskWid。\n\n# 六、获取详细表单\n\n今日校园还有一条验证就是每次请求的表的id，以及表选项的id都是变化的。\n\n所有，我们还需要抓取表的详细表单。\n\n接口\n\n```text\n/wec-counselor-collector-apps/stu/collector/getFormFields\n```\n\n参数\n\n```json\n{\"pageSize\":30,\"pageNumber\":1,\"formWid\":formWid,\"collectorWid\":collectorWid}\n```\n\n返回的内容，依你们老师的设定为准，不放结果了。\n\n# 七、模拟Post请求提交\n\n## 7.1 思路\n\n接口\n\n```html\n/wec-counselor-collector-apps/stu/collector/submitForm\n```\n\n通过上面，我们获取到了formWid，collectWid，schoolTaskWid，address，form。\n\n接下来，我们构造出post的json字符串请求体。\n\n发送！\n\n成功！\n\n## 7.2 邮件通知\n\n如果提交成功，或者提交失败。都会发通知邮件给我。\n\n但是，试了几次，经常报错`554 DT:SPM`，也就是被当做垃圾邮件驳回了。\n\n尝试了好几个邮箱，像139,163,qq邮箱，都会有这个问题，网上说设置端口啊，不要25，要465...开启ssl...等等\n\n如果涉及到敏感词，什么签到、自动，仍然没有一个奏效的，都没当成垃圾邮件处理。\n\n刚好看到一个大佬写的博客，建议用腾讯企业邮箱，试了一下，果然ok了。\n\n[记录一次Could not connect to SMTP host: smtp.163.com, port: 25的解决办法](https://blog.csdn.net/qq_38410730/article/details/86538298?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1)\n\n> 腾讯云或者阿里云，是默认禁用25端口的\n\n我附上发邮件的代码\n\n```java\npublic class SendMail {\n\tpublic static String send(String[] mail) {\n\t\tProperties properties = new Properties();\n\t\tproperties.put(\"mail.transport.protocol\", \"smtp\");// 连接协议\n        properties.put(\"mail.smtp.host\", \"smtp.exmail.qq.com\");// 主机名\n        properties.put(\"mail.smtp.port\", \"587\");// 端口号\n        properties.put(\"mail.smtp.auth\", \"true\");//设置smtp是否需要认证\n        properties.put(\"mail.smtp.ssl.enable\", \"true\");// 设置是否使用ssl安全连接 ---一般都使用\n        properties.put(\"mail.debug\", \"false\");// 设置是否显示debug信息 true 会在控制台显示相关信息\n        try{\n            Session session = Session.getInstance(properties);\n            Message message = new MimeMessage(session);\n            message.setFrom(new InternetAddress(Data.fromMail));\n            message.setRecipient(Message.RecipientType.TO, new InternetAddress(Data.toMail));\n            message.setSubject(mail[0]);\n            message.setText(mail[1]);\n            message.setSentDate(new Date());\n            Transport transport = session.getTransport();\n            transport.connect(Data.fromMail, Data.fromMailPw);//登录发信账号\n            transport.sendMessage(message, message.getAllRecipients());\n            transport.close();\n            return \"邮件发送成功\";\n        }catch (Exception e){\n            return \"邮件发送失败\";\n        }\n\t}\n}\n```\n\n## 7.3 运行结果\n\n{% asset_img 3.png 结果 %}\n\n* 获取到新表单，则提交。提交成功或失败，24小时之后，再次监测新表单提交\n* 未获取到表单数据，继续监测，间隔2小时\n\n{% asset_img 4.png 提交 %}\n\n{% asset_img 5.png 邮箱通知 %}\n\n# 八、总结\n\n## 8.1 感谢大佬\n\n[python版今日校园自动签到、填表](https://www.cnblogs.com/FSHOU/p/12425456.html)\n\n[python版今日校园自动填报脚本](https://github.com/Itswag/cpdaily_submit)\n\n[java定时刷新网页](https://www.jianshu.com/p/c6059b265dd0)\n\n[手机抓包教程第四节——系统证书的安装，解决APP抓不到包](https://www.bilibili.com/video/BV1Qe411s7q9?from=search&seid=6692535577953796826)\n\n[记录一次Could not connect to SMTP host: smtp.163.com, port: 25的解决办法](https://blog.csdn.net/qq_38410730/article/details/86538298?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1)\n\n[java抓取网页指定元素/内容](https://blog.csdn.net/yfx000/article/details/56831023)\n\n[模拟登陆系列](https://github.com/CharlesPikachu/DecryptLogin)\n\n[QQ空间模拟登录](https://mp.weixin.qq.com/s/Awnj0x_E7XJtbOW_7OBwbA)\n\n还是那句话，站在巨人的肩膀上\n\n多亏了有大佬们的指点\n\n{% asset_img 6.jpg dalao  %}\n\n{% asset_img 7.jpg dalao %}\n\n## 8.2 个人收获\n\n连着两天，早上5点就起。\n\n因为这个是学校的老师发的表单，我没有老师权限，没法模拟。\n\n所以，只能，每天早起，在表单未提交之前，进行测试。这也是最难受的一点。\n\n今天专业课考试，我当时写代码写得正在兴头上，结果作业没给交上去。估计这学期也就考个60分吧。无所谓了，反正我也不是学霸，计较个锤子。而且，我这学期，也都没咋听课，天天在家里就知道玩。每次都下定决心好好学习，结果，嘿嘿...\n\n总得来说，抓包还是很关键的。\n\n这个博客算是整理整个的思路，如果思路看明白了，那么，实现这样的功能就不难了。\n\n我看网上也有不少的类似程序，但是大多数是Python开发的，确实，Python在处理数据的时候，很舒服，给我的感觉，就是跟JavaScript一样，就是舒服。PHP如果实现这个功能的话，也会比较轻松。\n\n由于我现在正在学java，还没学透，正好可以拿这个练练手。毕竟，java就像是我的初恋，虽然她身材很臃肿，但我依然爱她啊！\n\n处理过程中，真的感觉**人生苦短，多用python**。\n\n像这样的功能，好多编程语言都能实现，Java不是不能，只是太繁琐了。\n\n如果我再次写这个的话，首选Python，其次Nodejs。\n\n在分层方面，还是觉得自己做地不太好，像学过的继承多态，我在处理的过程中，就是一直在硬写、闷头写。自己的代码也能看得出毛病来，但是想优化，却又不知从何改起。一方面，是对学过的东西，没有彻底理解；另一方面，也是自己的项目经验太少了。\n\n一定要花时间，弥补这方面的不足！","tags":["java","open","spider"]},{"title":"Debug","url":"/blog/2019/debug/","content":"\n总结一下debug的时候，各个键的功能吧\n\n<!--more-->\n\n**Debug调试程序**\n\n可以让代码逐行执行，可以查看代码执行的过程，调试程序中出现的bug\n\n**使用方式**\n\n1. 添加断点（哪里有bug就添加到哪里）\n2. Debug执行程序\n\n**执行程序**\n\n`StepOver`逐行执行程序\n\n`StepInto`进入方法\n\n`StepOut`跳出方法\n\n`Resume`跳到下个断点，如果没有，退出Debug\n\n`Terminate`退出Debug调试\n\n`Console`切换控制台","tags":["test"]},{"title":"安装cygwin","url":"/blog/2020/cygwin-install/","content":"\n记录一次安装cygwin的过程\n\n<!--more-->\n\n因为最近准备考研，做算法题的时候，就想着用电脑敲代码，更能加深印象。\n\n之前用过c-free、devC++、vc++6.0、vscode，说实话，一个原因是有的界面很low，还有一个感觉用起来比较死板，严重影响写代码的心情。\n\n所以，我就找了jetbrains旗下的Clion用来写C程序。\n\n安装cygwin的时候，卡住了，百度了很多教程，感觉[这篇](https://blog.csdn.net/u010356768/article/details/90756742)算是小白学习安装cygwin的比较详细的教程了。\n\ncygwin的镜像地址\n\n1. http://mirrors.sohu.com/cygwin/\n2. http://mirrors.163.com/cygwin/\n3. http://mirrors.ustc.cn/\n\n> 注意在安装的时候，将make组件也安装上，不然可能会出现别的情况","tags":["c"]},{"title":"java中equals和==的区别","url":"/blog/2019/equals/","content":"\n被equals和==坑了好几次了，这里介绍一下基本类型和引用类型\n\n<!--more-->\n\n### java中equals和==的区别\n\n对于基本类型来说，==是对数值的比较。\n\n对于引用类型来说，==是对地址值的比较。\n\n```\nint num1=1;\nint num2=1;\nSystem.out.println(num1==num2)//true\n```\n\n因为int是基本类型，基本类型中==是对数值比较。\n\n```\nString str1=\"abc\";\nString str2=\"abc\";\nchar[] charsArray={\n\t'a','b','c'\n};\nString str3=new String(charsArray);\n\nSystem.out.println(str1==str2);//true\nSystem.out.println(str1==str3);//false\nSystem.out.println(str2==str3);//false\n\nSystem.out.println(str1.equals(str2));//true\nSystem.out.println(str1.equals(str3));//true\nSystem.out.println(str2.equals(str3));//true\n```\n\n> 原文链接：https://blog.csdn.net/weixin_40304387/article/details/81071816 （以下文字看原文链接理解）\n\n> 采用字面值的方式创建一个字符串时，JVM（Java Virtual Machine，即java虚拟机）首先会去字符串池中查找是否存在\"abc\"这个对象，如果不存在，则在字符串常量池中创建\"abc\"这个对象，然后将池中\"abc\"这个对象的引用地址返回给\"abc\"对象的引用s1，这样s1会指向字符串常量池中\"abc\"这个字符串对象；如果存在，则不创建任何对象，直接将池中\"abc\"这个对象的地址返回，赋给引用s2。因为s1、s2都是指向同一个字符串池中的\"abc\"对象，所以结果为true。\n>\n> 采用new关键字新建一个字符串对象时，JVM首先在字符串池中查找有没有\"abc\"这个字符串对象，如果有，则不在池中再去创建\"abc\"这个对象了，直接在堆中创建一个\"abc\"字符串对象，然后将堆中的这个\"abc\"对象的地址返回赋给引用s3，这样，s3就指向了堆中创建的这个\"abc\"字符串对象；如果没有，则首先在字符串池中创建一个\"abc\"字符串对象，然后再在堆中创建一个\"abc\"字符串对象，然后将堆中这个\"abc\"字符串对象的地址返回赋给s3引用，这样，s3指向了堆中创建的这个\"abc\"字符串对象。s4则指向了堆中创建的另一个\"abc\"字符串对象。s3 、s4是两个指向不同对象的引用，结果当然是false。\n\n\n\n{% asset_img 字符串的常量池.png 字符串常量池 %}\n\n在堆内存中（从jdk1.7开始），有一个空间，叫字符串常量池。字符串直接创建的，在字符串常量池中存储。而在字符串常量池中，存储着字符串对象。字符串在最底层是用byte数组存储的。\n\nnew关键字创建时，会把char型数组转换成字符数组，然后创建。\n\n\n\n### 基本类型和引用类型\n\n* 基本类型\n  * 整型\n    * byte\n    * short\n    * int\n    * long\n  * 浮点型\n    * float\n    * double\n  * 字符型\n    * char\n  * 布尔型\n    * boolean\n\n* 引用类型（java为每种基本类型，都提供了对应的封装类型）\n  * Byte\n  * Short\n  * Integer\n  * Long\n  * Float\n  * Double\n  * Character\n  * Boolean\n\n注意：在泛型类中，类型只能是引用类型，不能是基本类型。","tags":["java"]},{"title":"常用的数据结构","url":"/blog/2019/data-structure/","content":"\n想要成为计算机大佬，数据结构同样很重要\n\n<!--more-->\n\n# 数据结构\n\n## 1 数据结构有什么用？\n\n当你用着java里面的容器类很爽的时候，你有没有想过，怎么ArrayList就像一个无限扩充的数组，也好像链表之类的。好用吗？好用，这就是数据结构的用处，只不过你在不知不觉中使用了。\n\n现实世界的存储，我们使用的工具和建模。每种数据结构有自己的优点和缺点，想想如果Google的数据用的是数组的存储，我们还能方便地查询到所需要的数据吗？而算法，在这么多的数据中如何做到最快的插入，查找，删除，也是在追求更快。\n\n我们java是面向对象的语言，就好似自动档轿车，C语言好似手动档吉普。数据结构呢？是变速箱的工作原理。你完全可以不知道变速箱怎样工作，就把自动档的车子从 A点 开到 B点，而且未必就比懂得的人慢。写程序这件事，和开车一样，经验可以起到很大作用，但如果你不知道底层是怎么工作的，就永远只能开车，既不会修车，也不能造车。当然了，数据结构内容比较多，细细的学起来也是相对费功夫的，不可能达到一蹴而就。我们将常见的数据结构：堆栈、队列、数组、链表和红黑树 这几种给大家介绍一下，作为数据结构的入门，了解一下它们的特点即可。\n\n{% asset_img 数据结构比喻.png 数据结构比喻 %}\n\n## 2 常见的数据结构\n\n数据存储的常用结构有：栈、队列、数组、链表和红黑树。我们分别来了解一下：\n\n#### 栈\n\n* **栈**：**stack**,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。\n\n简单的说：采用该结构的集合，对元素的存取有如下的特点\n\n* 先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。\n* 栈的入口、出口的都是栈的顶端位置。\n\n{% asset_img 堆栈.png 堆栈 %}\n\n这里两个名词需要注意：\n\n* **压栈**：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。\n* **弹栈**：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。\n\n\n#### 队列\n\n* **队列**：**queue**,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。\n\n简单的说，采用该结构的集合，对元素的存取有如下的特点：\n\n* 先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，小火车过山洞，车头先进去，车尾后进去；车头先出来，车尾后出来。\n* 队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。\n\n{% asset_img 队列图.png 队列图 %}\n\n#### 数组\n\n* **数组**:**Array**,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。\n\n简单的说,采用该结构的集合，对元素的存取有如下的特点：\n\n*  查找元素快：通过索引，可以快速访问指定位置的元素\n\n{% asset_img 数组查询快.png 数组查询快 %}\n\n*  增删元素慢\n   * **指定索引位置增加元素**：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。如下图\n   \n   {% asset_img 数组添加.png 数组添加 %}\n   \n   * **指定索引位置删除元素：**需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。如下图\n   \n   {% asset_img 数组删除.png 数组删除 %}\n\n\n\n####  链表\n\n* **链表**:**linked list**,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的链表结构有单向链表与双向链表，那么这里给大家介绍的是**单向链表**。\n\n{% asset_img 单链表结构特点.png 单链表结构特点 %}\n\n简单的说，采用该结构的集合，对元素的存取有如下的特点：\n\n* 多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。\n\n{% asset_img 单链表结构.png 单链表结构 %}\n\n* 查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素\n\n* 增删元素快：\n\n  *  增加元素：只需要修改连接下个元素的地址即可。\n\n  {% asset_img 增加结点.png 增加结点 %}\n\n  *  删除元素：只需要修改连接下个元素的地址即可。\n\n  {% asset_img 删除结点.png 删除节点 %}\n\n#### 红黑树\n\n* **二叉树**：**binary tree** ,是每个结点不超过2的有序**树（tree）** 。\n\n简单的理解，就是一种类似于我们生活中树的结构，只不过每个结点上都最多只能有两个子结点。\n\n二叉树是每个节点最多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和“右子树”。\n\n如图：\n\n{% asset_img 二叉树.png 二叉树 %}\n\n我们要说的是二叉树的一种比较有意思的叫做**红黑树**，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。\n\n红黑树的约束:\n\n1. 节点可以是红色的或者黑色的\n\n\n2. 根节点是黑色的\n\n\n3. 叶子节点(特指空节点)是黑色的\n4. 每个红色节点的子节点都是黑色的\n5. 任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同\n\n红黑树的特点:\n\n​\t速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍","tags":["data-structure"]},{"title":"驾照","url":"/blog/2020/driver-license/","content":"\n科四考完了。过了。\n\n<!--more-->\n\n我自己约了科四考试，也没跟教练说。\n\n上次科二考试，没考过，教练直接把我丢考场了，我当时又没带钱，又不知道路，一路借钱问路才到家了。\n\n所以之后的科二考试，我都是自己约的，自己骑车去的，虽然远了点，但是自在。\n\n今天一早就起了，一路上边看地图边前进，在环形路的时候，我都慌了，好在还是平安度过。\n\n我当时就直接穿了一双我妈做的布鞋，发型也是自己理的，坑坑洼洼的。一路上好多人看我像奇葩，有几个漂亮小姐姐还一直瞟我，估计心里在想，哪里来的土包子？\n\n原来的我，会拼命掩饰我是山里出来的人，努力合群，证明自己也是城里人。\n\n现在反而无所谓了，我就是山里的人，我就是土包子。虽然我讨厌山里落后的环境，但是还是无法掩饰自己是山里人的事实，又何必遮遮掩掩。\n\n随着年龄的增大，自己也逐渐成熟，人心险恶也见识了不少，反而越发让我想做真实的自己。\n\n你看不起我，那你尽管看不起好了，我本来就是个底层的人。\n\n你拍我马屁，我有自知之明，几斤几两还是掂得清楚，抱歉，咱俩不熟。\n\n两个小时之后，到了考点，不确定，一路又问人找路。感谢。有的时候礼貌的一句谢谢，能让别人很开心，同时自己也很开心。\n\n科四如期过了，只错了两个选择题，还是马虎做错的。\n\n科四的备考跟我科一时一样，临时抱佛脚。凌晨到早上刷完了1400多道题，然后去考试，过了。这玩意都是原题，有印象就行了。\n\n期间，交补考费的时候，交警12123一直闪退，我用虚拟机还是闪退，用网页又没法支付，找人工，人工说系统坏了，不禁火大。说实话，这些在政府工作的程序员真是废地跟渣渣一样，网页支付都做不出来。说白了，国家就是因为这群蛀虫在，才腐败的。\n\n多说无益，心知肚明即可。\n\n考驾照报名费1600（其中科一考试费80元，科二考试费240元，科三考试费200，科四考试费40，剩下的就是归驾校了），科一加10块，科二熟练场地两次400，补考480，科三打点教练600，路费200，科四口罩和快递费（口罩1.5元，快递15）算17吧。\n\n这样一共算下来，考驾照共花了3307元，2018.1-2020.8。\n\n回家剃了个秃头，接下来全心准备考研了。\n\n{% asset_img 1.jpg %}","tags":["life"]},{"title":"继承实现依赖关联聚合组合的联系和区别","url":"/blog/2019/extends-implements/","content":"\n画类图的时候，碰到的各种关系\n\n<!--more-->\n\n[继承、实现、依赖、关联、聚合、组合的联系和区别](https://www.cnblogs.com/jiqing9006/p/5915023.html)\n\n{% asset_img 联系和区别.png 联系和区别 %}\n\n","tags":["design-model"]},{"title":"关于继承、方法重写、super和this","url":"/blog/2019/extends-and-super/","content":"\n面向对象三大特性之一——继承\n\n<!--more-->\n\n## 继承\n\n在继承的关系中，子类就是父类。也就是说，子类可以被当做父类来对待。\n\n定义父类的格式：\n\n```\npublic class 父类名称 {\n\n//...\n\n}\n```\n\n\n\n定义子类的格式：\n\n```\npublic class 子类名称 extends 父类名称 {\n\n//...\n\n}\n```\n\n\n\n在父子类的继承中，如果成员变量重名，则创建子类对象时，访问有两种方式：\n\n1. 直接通过子类对象访问成员变量：\n   等号左边是谁，就优先用谁，没有则向上找；\n2. 间接通过成员方法访问成员变量：\n   该方法属于谁，就优先用谁，没有则向上找。\n\n```\nclass Fu {\n\tint num=100;\n\tpublic void methodFu() {\n\t\tSystem.out.println(num);\n\t}\n}\nclass Zi extends Fu {\n\tint num=200;\n\tpublic void methodZi() {\n\t\tSystem.out.println(num);\n\t}\n}\npublic class Demo02ExtendsField {\n\tpublic static void main(String[] args) {\n\t\tFu fu=new Fu();\n\t\tZi zi=new Zi();\n\t\t\n\t\tSystem.out.println(zi.num);//200\n\t\t\n\t\tzi.methodZi();//200;\n\t\tzi.methodFu();//100;\n\t}\n}\n```\n\n## 继承中的方法重写\n\n局部变量：直接输出\n\n本类的成员变量：this\n\n父类的成员变量：super\n\n***\n\n**方法重写**\n概念：在继承关系当中，方法的名称一样，参数列表也一样。\n\n重写（Override）:方法的名称一样，参数列表也一样。覆盖。[发生在继承关系当中]\n\n重载（Overload）:方法的名称一样，参数列表不一样。\n\n**方法覆盖的特点**\n创建的是子类对象，则优先使用子类方法\n\n```\nclass Fu1 {\n\tint num=10;\n\tpublic void methodC() {\n\t\tSystem.out.println(\"父类重名方法执行\");\n\t}\n}\nclass Zi1 extends Fu1 {\n\tint num=20;\n\tpublic void method() {\n\t\tint num=30;\n\t\tSystem.out.println(num);//30 局部变量\n\t\tSystem.out.println(this.num);//20 该类中的成员变量\n\t\tSystem.out.println(super.num);//10 父类中的成员变量\n\t}\n\tpublic void methodC() {\n\t\tSystem.out.println(\"子类重名方法执行\");\n\t}\n}\npublic class Demo03ExtendsField {\n\tpublic static void main(String[] args) {\n\t\tZi1 zi=new Zi1();\n\t\tzi.method();\n\t\tzi.methodC();\n\t}\n\t\n}\n```\n\n**方法重写的注意事项**\n\n1. 必须保证父子类之间的方法的名称相同，参数列表也相同\n   @Override:写在方法前面，用来检测是不是有效地正确覆盖重写；这个注解只要不写，只要满足要求，也是正确的方法覆盖重写\n\n2. 子类方法的返回值必须小于等于父类方法的返回值范围\n   前提：Object类是所有类的公共最高父类（祖宗类），java.lang.String就是Object的子类；Object是最大的范围，String是他的子类，范围要小。\n\n   ```\n   class Fulei {\n   \tpublic Object method() {\n   \t\treturn null;\n   \t}\n   }\n   class Zilei extends Fulei {\n   \t@Override\n   \tpublic String method() {\n   \t\treturn null;\n   \t}\n   }\n   ```\n\n3. 子类方法的权限修饰符必须大于等于父类方法的权限修饰符\n   提示：public>protected>(default)>private\n   备注：default不是关键字，是不写的情况下\n\n   ```\n   class Fulei {\n   \tvoid method() {//这个默认是default\n   \t\t\n   \t}\n   }\n   class Zilei extends Fulei {\n   \t@Override\n   \tpublic void method() {//public\n   \t\t\n   \t}\n   }\n   ```\n\n   \n\n**方法重写实际案例**\n\n```\nclass Phone {\n\tpublic void call() {\n\t\tSystem.out.println(\"打电话\");\n\t}\n\tpublic void send() {\n\t\tSystem.out.println(\"发短信\");\n\t}\n\tpublic void show() {\n\t\tSystem.out.println(\"显示号码\");\n\t}\n}\nclass NewPhone extends Phone {\n\t@Override\n\tpublic void show() {\n\t\t// TODO Auto-generated method stub\n\t\tsuper.show();\n\t\tSystem.out.println(\"显示姓名\");\n\t\tSystem.out.println(\"显示头像\");\n\t}\n}\npublic class Demo05Phone {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tPhone p=new Phone();\n\t\tp.call();\n\t\tp.send();\n\t\tp.show();\n\t\t\n\t\tNewPhone np=new NewPhone();\n\t\tnp.call();\n\t\tnp.send();\n\t\tnp.show();\n\t}\n\n}\n```\n\n## super关键字\n\n继承关系中，父子类构造方法的访问特点：\n\n * 1.子类**构造方法**当中有一个默认隐藏的super()调用。所以一定是先调用父类构造方法，后调用子类构造方法\n\n * 2.子类构造可以通过super调用父类重载构造\n\n * 3.super的父类构造调用，必须是子类构造方法的第一个语句（第一个super的语句）;\n\n * 总结：\n\n   子类必须调用父类的构造方法，不写则赠送super();写了，则用指定的super(),super只能是第一个。\n\n总结：\n * super关键字的用法有三种：\n * 1.在子类的**成员方法**中，访问父类的**成员变量**\n * 2.在子类的**成员方法**中，访问父类的**成员方法**\n * 3.在子类的**构造方法**中，访问父类的**构造方法**\n\n```\nclass F {\n\tpublic F() {\n\t\tSystem.out.println(\"父类无参构造方法\");\n\t}\n\tpublic F(int num) {\n\t\tSystem.out.println(\"父类有参构造方法\");\n\t}\n}\nclass Z extends F {\n\tpublic Z() {\n\t\t//super();默认有个隐藏的super();\n\t\tsuper(20);\n\t\tSystem.out.println(\"子类构造方法\");\n\t}\n\tpublic void method() {\n\t\t//super();//此处会报错。只有子类构造方法，才能调用父类构造方法。\n\t}\n}\npublic class Demo06Constructor {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tZ z=new Z();\n\t}\n\n}\n```\n\n## this关键字\n\nsuper关键字用来访问父类内容，而this关键字用来访问本类内容。\n\n三种用法：\n\n1. 在本类的**成员方法**中，访问本类的**成员变量**\n2. 在本类的**成员方法**中，访问本类的另一个**成员方法**\n3. 在本类的**构造方法**中，访问本类的另一个**构造方法**\n   1. this调用跟super调用一样，也必须是构造方法的第一个语句，也必须是唯一一个\n   2. super跟this都必须是第一个，并且**两者不能同时使用**\n\n```\nclass 父 {\n\tint num=30;\n}\nclass 子 extends 父 {\n\tint num=20;\n\tpublic void method(){\n\t\tint num=10;\n\t\tSystem.out.println(num);//10\n\t\tSystem.out.println(this.num);//20\n\t\tSystem.out.println(super.num);//30\n\t}\n\t\n\tpublic void methodA() {\n\t\tSystem.out.println(\"A\");\n\t}\n\tpublic void methodB() {\n\t\tthis.methodA();//A\n\t\tSystem.out.println(\"B\");//B\n\t}\n}\n```\n\n","tags":["java"]},{"title":"File类与IO流","url":"/blog/2019/file-and-io-stream/","content":"\n学习一下File类与io流\n\n<!--more-->\n\n# 第一章 File类\n\n## 1.1 概述\n\n`java.io.File` 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。\n\n具体操作\n\n* 创建文件/文件夹\n* 删除文件/文件夹\n* 获取文件/文件夹\n* 判断文件/文件夹是否存在\n* 对文件进行遍历\n* 获取文件的大小\n\nFile类是一个与系统无关的类，任何的操作系统都可以使用这个类中的方法。\n\n`file`文件\n\n`directory`文件夹/目录\n\n`path`路径\n\n`static String pathSeparator`与系统有关的路径分隔符，为了方便，它被表示为一个字符串。\n\n`static char pathSeparatorChar`与系统有关的路径分隔符\n\n路径分隔符，`windows`是`;`，`linux`是`:`。\n\n`static String separator`与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串\n\n`static char separatorChar`与系统有关的默认名称分隔符\n\n文件名称分割符，`windows`是`\\`，`linux`是`/`。\n\n## 1.2 构造方法\n\n* `public File(String pathname) ` ：通过将给定的**路径名字符串**转换为抽象路径名来创建新的 File实例。  \n* `public File(String parent, String child) ` ：从**父路径名字符串和子路径名字符串**创建新的 File实例。\n* `public File(File parent, String child)` ：从**父抽象路径名和子路径名字符串**创建新的 File实例。  \n\n\n* 构造举例，代码如下：\n\n```java\n// 文件路径名\nString pathname = \"D:\\\\aaa.txt\";\nFile file1 = new File(pathname); \n\n// 文件路径名\nString pathname2 = \"D:\\\\aaa\\\\bbb.txt\";\nFile file2 = new File(pathname2); \n\n// 通过父路径和子路径字符串\n String parent = \"d:\\\\aaa\";\n String child = \"bbb.txt\";\n File file3 = new File(parent, child);\n\n// 通过父级File对象和子路径字符串\nFile parentDir = new File(\"d:\\\\aaa\");\nString child = \"bbb.txt\";\nFile file4 = new File(parentDir, child);\n```\n\n> 小贴士：\n>\n> 1. 一个File对象代表硬盘中实际存在的一个文件或者目录。\n> 2. 无论该路径下是否存在文件或者目录，都不影响File对象的创建。\n\n## 1.3 常用方法\n\n### 获取功能的方法\n\n* `public String getAbsolutePath() ` ：返回此File的绝对路径名字符串。\n\n* ` public String getPath() ` ：将此File转换为路径名字符串。 \n\n* `public String getName()`  ：返回由此File表示的文件或目录的名称。  \n\n* `public long length()`  ：返回由此File表示的文件的长度。 \n\n> 注意：length()获取的是构造方法指定的文件的大小，以字节为单位。文件夹是没有大小概念的，没法获取文件夹大小；如果构造方法中给出的路径是不存在，或者是假的，那么length方法返回0\n>\n\n  方法演示，代码如下：\n\n  ```java\n  public class FileGet {\n      public static void main(String[] args) {\n          File f = new File(\"d:/aaa/bbb.java\");     \n          System.out.println(\"文件绝对路径:\"+f.getAbsolutePath());\n          System.out.println(\"文件构造路径:\"+f.getPath());\n          System.out.println(\"文件名称:\"+f.getName());\n          System.out.println(\"文件长度:\"+f.length()+\"字节\");\n  \n          File f2 = new File(\"d:/aaa\");     \n          System.out.println(\"目录绝对路径:\"+f2.getAbsolutePath());\n          System.out.println(\"目录构造路径:\"+f2.getPath());\n          System.out.println(\"目录名称:\"+f2.getName());\n          System.out.println(\"目录长度:\"+f2.length());\n      }\n  }\n  输出结果：\n  文件绝对路径:d:\\aaa\\bbb.java\n  文件构造路径:d:\\aaa\\bbb.java\n  文件名称:bbb.java\n  文件长度:636字节\n  \n  目录绝对路径:d:\\aaa\n  目录构造路径:d:\\aaa\n  目录名称:aaa\n  目录长度:4096\n  ```\n\n> API中说明：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。\n\n### 绝对路径和相对路径\n\n* **绝对路径**：从盘符开始的路径，这是一个完整的路径。\n* **相对路径**：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。\n\n```java\npublic class FilePath {\n    public static void main(String[] args) {\n      \t// D盘下的bbb.java文件\n        File f = new File(\"D:\\\\bbb.java\");\n        System.out.println(f.getAbsolutePath());\n      \t\n\t\t// 项目下的bbb.java文件\n        File f2 = new File(\"bbb.java\");\n        System.out.println(f2.getAbsolutePath());\n    }\n}\n输出结果：\nD:\\bbb.java\nD:\\idea_project_test4\\bbb.java\n```\n\n注意事项：\n\n1. 路径他是不区分大小写的。\n2. 路径中的文件名称分隔符，windows是`\\`，是转义字符，所以在使用的时候，应该用`\\\\`。\n\n### 判断功能的方法\n\n- `public boolean exists()` ：此File表示的文件或目录是否实际存在。\n- `public boolean isDirectory()` ：此File表示的是否为目录。\n- `public boolean isFile()` ：此File表示的是否为文件。\n\n> 注意事项：\n>\n> 1. 电脑硬盘中只有文件/文件夹，两个是互斥的\n> 2. 使用前提，路径存在，否则返回false\n\n\n方法演示，代码如下：\n\n```java\npublic class FileIs {\n    public static void main(String[] args) {\n        File f = new File(\"d:\\\\aaa\\\\bbb.java\");\n        File f2 = new File(\"d:\\\\aaa\");\n      \t// 判断是否存在\n        System.out.println(\"d:\\\\aaa\\\\bbb.java 是否存在:\"+f.exists());\n        System.out.println(\"d:\\\\aaa 是否存在:\"+f2.exists());\n      \t// 判断是文件还是目录\n        System.out.println(\"d:\\\\aaa 文件?:\"+f2.isFile());\n        System.out.println(\"d:\\\\aaa 目录?:\"+f2.isDirectory());\n    }\n}\n输出结果：\nd:\\aaa\\bbb.java 是否存在:true\nd:\\aaa 是否存在:true\nd:\\aaa 文件?:false\nd:\\aaa 目录?:true\n```\n\n### 创建删除功能的方法\n\n- `public boolean createNewFile()` ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 \n- `public boolean delete()` ：删除由此File表示的文件或目录。  \n- `public boolean mkdir()` ：创建由此File表示的目录。\n- `public boolean mkdirs()` ：创建由此File表示的目录，包括任何必需但不存在的父目录。\n\n方法演示，代码如下：\n\n```java\npublic class FileCreateDelete {\n    public static void main(String[] args) throws IOException {\n        // 文件的创建\n        File f = new File(\"aaa.txt\");\n        System.out.println(\"是否存在:\"+f.exists()); // false\n        System.out.println(\"是否创建:\"+f.createNewFile()); // true\n        System.out.println(\"是否存在:\"+f.exists()); // true\n\t\t\n     \t// 目录的创建\n      \tFile f2= new File(\"newDir\");\t\n        System.out.println(\"是否存在:\"+f2.exists());// false\n        System.out.println(\"是否创建:\"+f2.mkdir());\t// true\n        System.out.println(\"是否存在:\"+f2.exists());// true\n\n\t\t// 创建多级目录\n      \tFile f3= new File(\"newDira\\\\newDirb\");\n        System.out.println(f3.mkdir());// false\n        File f4= new File(\"newDira\\\\newDirb\");\n        System.out.println(f4.mkdirs());// true\n      \n      \t// 文件的删除\n       \tSystem.out.println(f.delete());// true\n      \n      \t// 目录的删除\n        System.out.println(f2.delete());// true\n        System.out.println(f4.delete());// false\n    }\n}\n```\n\n> API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。delete方法是直接在硬盘上删除文件/文件夹，不走回收站，删除要谨慎。\n\n## 1.4 目录的遍历\n\n* `public String[] list()` ：返回一个String数组，表示该File目录中的所有子文件或目录。\n\n\n* `public File[] listFiles()` ：返回一个File数组，表示该File目录中的所有的子文件或目录。  \n\n```java\npublic class FileFor {\n    public static void main(String[] args) {\n        File dir = new File(\"d:\\\\java_code\");\n      \n      \t//获取当前目录下的文件以及文件夹的名称。\n\t\tString[] names = dir.list();\n\t\tfor(String name : names){\n\t\t\tSystem.out.println(name);\n\t\t}\n        //获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息\n        File[] files = dir.listFiles();\n        for (File file : files) {\n            System.out.println(file);\n        }\n    }\n}\n```\n\n> 小贴士：\n>\n> 调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。\n>\n> 隐藏文件以及隐藏文件夹同样也能被遍历\n\n# 第二章 递归\n\n## 2.1 概述\n\n* **递归**：指在当前方法内调用自己的这种现象。\n* **递归的分类:**\n  - 递归分为两种，直接递归和间接递归。\n  - 直接递归称为方法自身调用自己。\n  - 间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法。\n* **注意事项**：\n  * 当一个方法调用其他方法的时候，被调用的方法没有执行完毕，当前方法会一直等待调用的方法执行完毕，才会继续执行。\n  * 递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。\n  * 在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。\n  * 构造方法,禁止递归\n* 递归的使用前提：\n  * 当调用方法的时候，方法的主体保持不变，每次调用方法的参数不同，可以使用递归。\n\n```java\npublic class Demo01Recursive {\n\tpublic static void main(String[] args) {\n//\t\ta();\n\t\tb(1);\n\t}\n\t/*\n\t * 编译报错\n\t * 构造方法是创建对象使用的，一直递归会导致内存中有无数多个对象，直接编译报错。\n\t */\n//\tpublic Demo01Recursive() {\n//\t\tDemo01Recursive();\n//\t}\n\t/*\n\t * 在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。\n\t */\n\tpublic static void b(int a) {\n\t\tSystem.out.println(a);\n\t\tif(a==20) {//设置成20000就会挂了\n\t\t\treturn;//结束方法\n\t\t}\n\t\tb(++a);\n\t}\n\t/*\n\t * 递归要有条件限定，保证递归能够停下来，否则会发生栈内存溢出\n\t * java.lang.StackOverFlowError\n\t * \n\t */\n\tpublic static void a() {\n\t\tSystem.out.println(\"a方法\");\n\t\ta();\n\t}\n}\n```\n\n## 2.2 递归累加求和  \n\n### 计算1 ~ n的和\n\n**分析**：num的累和 = num + (num-1)的累和，所以可以把累和的操作定义成一个方法，递归调用。\n\n**注意：**使用递归求和，main方法调用sum方法，sum方法会一直调用sum方法，导致在内存中有多个sum方法（频繁的创建方法，调用方法，销毁方法）效率低下。所以如果只是求和，不推荐用递归，for循环即可\n\n**实现代码**：\n\n```java\npublic class Demo02Recursive {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(sum(3));\n\t\t\n\t\tSystem.out.println(sum(100));\n\t}\n\tpublic static int sum(int n) {\n\t\t//获取到1的时候结束\n\t\tif(n==1) {\n\t\t\treturn 1;\n\t\t}\n\t\t//获取下一个被加的数字\n\t\treturn n+sum(n-1);\n\t}\n}\n```\n\n### 代码执行图解\n\n{% asset_img 递归求和.png 递归求和 %}\n\n> 小贴士：递归一定要有条件限定，保证递归能够停止下来，次数不要太多，否则会发生栈内存溢出。\n\n## 2.3 递归求阶乘\n\n* **阶乘**：所有小于及等于该数的正整数的积。\n\n```java\nn的阶乘：n! = n * (n-1) *...* 3 * 2 * 1 \n```\n\n**分析**：这与累和类似,只不过换成了乘法运算，学员可以自己练习，需要注意阶乘值符合int类型的范围。\n\n```\n推理得出：n! = n * (n-1)!\n```\n\n**代码实现**：\n\n```java\npublic class Demo03Recursive {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(factorial(3));\n\t}\n\tpublic static int factorial(int n) {\n\t\tif(n==1) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn n*factorial(n-1);\n\t}\n}\n```\n\n## 2.4 递归打印多级目录\n\n**分析**：多级目录的打印，就是当目录的嵌套。遍历之前，无从知道到底有多少级目录，所以我们还是要使用递归实现。\n\n**代码实现**：\n\n```java  \npublic class Demo04RecursivePrintDirectory {\n\tpublic static void main(String[] args) throws IOException {\n\t\tFile f=new File(\"C:\\\\users\\\\kitchen\\\\desktop\\\\abc\");\n\t\tgetAllFile(f);\n\t}\n\t/*\n\t * 定义一个方法，参数传递File类型的目录\n\t * 方法中对目录进行遍历\n\t * abc\\b\n\t * abc\\b\\b.txt\n\t * abc\\b\\b.java\n\t */\n\tpublic static void getAllFile(File dir) {\n\t\tFile[] file=dir.listFiles();\n\t\tfor(File f:file) {\n\t\t\tif(!f.isFile()) {\n\t\t\t\tSystem.out.println(f);\n\t\t\t\tgetAllFile(f);\n\t\t\t}else {\n\t\t\t\tSystem.out.println(f);\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n# 第三章 综合案例\t\n\n## 3.1 文件搜索\t\n\n搜索`D:\\aaa` 目录中的`.java` 文件。\n\n**分析**：\n\n1. 目录搜索，无法判断多少级目录，所以使用递归，遍历所有目录。\n2. 遍历目录时，获取的子文件，通过文件名称，判断是否符合条件。\n\n**代码实现**：\n\n```java\npublic class Demo05Recursive {\n\tpublic static void main(String[] args) {\n\t\tFile file=new File(\"C:\\\\users\\\\kitchen\\\\desktop\\\\abc\");\n\t\tsearchJava(file);\n\t}\n\t/*\n\t * 搜索.java文件\n\t */\n\tpublic static void searchJava(File dir) {\n\t\tFile[] file=dir.listFiles();\n\t\tfor(File f:file) {\n\t\t\tif(!f.isFile()) {\n\t\t\t\tsearchJava(f);\n\t\t\t}else {\n\t\t\t\tString str=f.toString();\n\t\t\t\tif(str.toLowerCase().endsWith(\".java\")) {\n\t\t\t\t\tSystem.out.println(str);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n## 3.2 文件过滤器优化\n\n`java.io.FileFilter`是一个接口，是File的过滤器。 该接口的对象可以传递给File类的`listFiles(FileFilter)` 作为参数， 接口中只有一个方法。\n\n`boolean accept(File pathname)  ` ：测试pathname是否应该包含在当前File目录中，符合则返回true。\n\n**分析**：\n\n1. 接口作为参数，需要传递子类对象，重写其中方法。我们选择匿名内部类方式，比较简单。\n2. `accept`方法，参数为File，表示当前File下所有的子文件和子目录。保留住则返回true，过滤掉则返回false。保留规则：\n   1. 要么是.java文件。\n   2. 要么是目录，用于继续遍历。\n3. 通过过滤器的作用，`listFiles(FileFilter)`返回的数组元素中，子文件对象都是符合条件的，可以直接打印。\n\n**代码实现：**\n\n```java\npublic class Demo06FileFilter {\n\tpublic static void main(String[] args) {\n\t\tFile file=new File(\"C:\\\\users\\\\kitchen\\\\desktop\\\\abc\");\n\t\tsearchJava(file);\n\t}\n\tpublic static void searchJava(File dir) {\n\t\tFile[] file=dir.listFiles(new FileFilter() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic boolean accept(File pathname) {\n\t\t\t\t/*\n\t\t\t\t * 过滤的规则：\n\t\t\t\t * 在accept方法中，判断File对象是否是以.java为结尾，或者是否是一个目录\n\t\t\t\t * 是就返回true\n\t\t\t\t * 不是就返回false，false就表示该路径被过滤掉了\n\t\t\t\t */\n\t\t\t\treturn pathname.getName().toLowerCase().endsWith(\".java\")||pathname.isDirectory();\n\t\t\t}\n\t\t});\n\t\tfor(File f:file) {\n\t\t\tif(f.isFile()) {\n\t\t\t\tSystem.out.println(f);\n\t\t\t}else {\n\t\t\t\tsearchJava(f);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\n\n```\n\n\n\n## 3.3 Lambda优化\n\n**分析：**`FileFilter`是只有一个方法的接口，因此可以用lambda表达式简写。\n\nlambda格式：\n\n```java\n()->{ }\n```\n\n**代码实现：**\n\n```java\npublic class Demo06FileFilter {\n\tpublic static void main(String[] args) {\n\t\tFile file=new File(\"C:\\\\users\\\\kitchen\\\\desktop\\\\abc\");\n\t\tsearchJava(file);\n\t}\n\tpublic static void searchJava(File dir) {\n//\t\tFile[] file=dir.listFiles(new FileFilter() {\n//\t\t\t\n//\t\t\t@Override\n//\t\t\tpublic boolean accept(File pathname) {\n//\t\t\t\t/*\n//\t\t\t\t * 过滤的规则：\n//\t\t\t\t * 在accept方法中，判断File对象是否是以.java为结尾，或者是否是一个目录\n//\t\t\t\t * 是就返回true\n//\t\t\t\t * 不是就返回false，false就表示该路径被过滤掉了\n//\t\t\t\t */\n//\t\t\t\treturn pathname.getName().toLowerCase().endsWith(\".java\")||pathname.isDirectory();\n//\t\t\t}\n//\t\t});\n\t\t\n\t\t//Lambda优化，采用Lambda的省略格式\n\t\tFile[] file=dir.listFiles((d,pathname)->new File(d,pathname).isDirectory()||pathname.toLowerCase().endsWith(\".java\")\n\t\t);\n\t\tfor(File f:file) {\n\t\t\tif(f.isFile()) {\n\t\t\t\tSystem.out.println(f);\n\t\t\t}else {\n\t\t\t\tsearchJava(f);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\n```\n\n# 第四章 IO概述\n\n## 4.1 什么是IO\n\n生活中，你肯定经历过这样的场景。当你编辑一个文本文件，忘记了`ctrl+s` ，可能文件就白白编辑了。当你电脑上插入一个U盘，可以把一个视频，拷贝到你的电脑硬盘里。那么数据都是在哪些设备上的呢？键盘、内存、硬盘、外接设备等等。\n\n我们把这种数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为`输入input` 和`输出output` ，即流向内存是输入流，流出内存的输出流。\n\nJava中I/O操作主要是指使用`java.io`包下的内容，进行输入、输出操作。**输入**也叫做**读取**数据，**输出**也叫做作**写出**数据。\n\n## 4.2 IO的分类\n\n根据数据的流向分为：**输入流**和**输出流**。\n\n* **输入流** ：把数据从`其他设备`上读取到`内存`中的流。 \n* **输出流** ：把数据从`内存` 中写出到`其他设备`上的流。\n\n根据数据的类型分为：**字节流**和**字符流**。\n\n* **字节流** ：以字节为单位，读写数据的流。\n* **字符流** ：以字符为单位，读写数据的流。\n\n> 1字符=2字节（byte） 1个字节=8个二进制位（bit）\n>\n> 例如 字节->二进制位 ===== 97->0110 0001\n>\n> 此处关于字符占字节的描述不准确，请看[这里](https://meethigher.top/blog/2020/bytes-of-characters/)\n\n## 4.3 IO的流向说明图解\n\n{% asset_img 1_io.jpg io.jpg %}\n\n## 4.4 顶级父类们\n\n|            |           **输入流**            |              输出流              |\n| :--------: | :-----------------------------: | :------------------------------: |\n| **字节流** | 字节输入流<br />**InputStream** | 字节输出流<br />**OutputStream** |\n| **字符流** |   字符输入流<br />**Reader**    |    字符输出流<br />**Writer**    |\n\n# 第五章 字节流 \n\n## 5.1 一切皆为字节\n\n一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。\n\n> 任意的文本编辑器（记事本，notepad++）\n>\n> 在打开文件的时候，都会查询编码表，把字节转换为字符表示\n>\n> 0-127：查询ASCII表\n>\n> 其他值：查询系统默认码表（中文系统GBK）\n\n## 5.2 字节输出流\n\n`java.io.OutputStream `抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。\n\n* `public void close()` ：关闭此输出流并释放与此流相关联的任何系统资源。  \n* `public void flush() ` ：刷新此输出流并强制任何缓冲的输出字节被写出。  \n* `public void write(byte[] b)`：将 b.length字节从指定的字节数组写入此输出流。  \n* `public void write(byte[] b, int off, int len)` ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。  \n* `public abstract void write(int b)` ：将指定的字节输出流。\n\n写入数据的原理：由内存到硬盘\n\n* java程序-->jvm(java虚拟机)-->os(操作系统)-->os调用写数据的方法-->把数据写入到文件\n\n字节输出流的使用步骤：\n\n1. 创建一个FileOutputStream对象，构造方法中传递写入数据的路径\n2. 调用FileOutputStream对象中的方法write方法，把数据写入到文件中\n3. 释放资源（流的使用会占用一定的内存，使用完毕要把内存清空提高程序的效率）\n\n> 小贴士：\n>\n> close方法，当完成流的操作时，必须调用此方法，释放系统资源。\n\n## 5.3 FileOutputStream类\n\n`OutputStream`有很多子类，我们从最简单的一个子类开始。\n\n`java.io.FileOutputStream `类是文件输出流，用于将数据写出到文件。\n\n### 构造方法\n\n* `public FileOutputStream(File file)`：创建文件输出流以写入由指定的 File对象表示的文件。 \n* `public FileOutputStream(String name)`： 创建文件输出流以指定的名称写入文件。  \n\n当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。\n\n构造方法的作用：\n\n1. 创建一个FileOutputStream对象\n2. 根据构造方法中传递的文件路径创建一个空的文件\n3. 会把FileOutputStream对象指向创建好的文件。\n\n* 构造举例，代码如下：\n\n```java\npublic class FileOutputStreamConstructor throws IOException {\n    public static void main(String[] args) {\n   \t \t// 使用File对象创建流对象\n        File file = new File(\"a.txt\");\n        FileOutputStream fos = new FileOutputStream(file);\n      \n        // 使用文件名称创建流对象\n        FileOutputStream fos = new FileOutputStream(\"b.txt\");\n    }\n}\n```\n\n### 写出字节数据\n\n1. **写出字节**：`write(int b)` 方法，每次可以写出一个字节数据，代码使用演示：\n\n```java\npublic class FOSWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileOutputStream fos = new FileOutputStream(\"fos.txt\");     \n      \t// 写出数据\n      \tfos.write(97); // 写出第1个字节\n      \tfos.write(98); // 写出第2个字节\n      \tfos.write(99); // 写出第3个字节\n      \t// 关闭资源\n        fos.close();\n    }\n}\n输出结果：\nabc\n```\n\n> 小贴士：\n>\n> 1. 虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。\n> 2. 流操作完毕后，必须释放系统资源，调用close方法，千万记得。\n\n2. **写出字节数组**：`write(byte[] b)`，每次可以写出数组中的数据，代码使用演示：\n\n```java\npublic class FOSWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileOutputStream fos = new FileOutputStream(\"fos.txt\");     \n      \t// 字符串转换为字节数组\n      \tbyte[] b = \"黑马程序员\".getBytes();\n      \t// 写出字节数组数据\n      \tfos.write(b);\n      \t// 关闭资源\n        fos.close();\n    }\n}\n输出结果：\n黑马程序员\n```\n\n3. **写出指定长度字节数组**：`write(byte[] b, int off, int len)` ,每次写出从off索引开始，len个字节，代码使用演示：\n\n```java\npublic class FOSWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileOutputStream fos = new FileOutputStream(\"fos.txt\");     \n      \t// 字符串转换为字节数组\n      \tbyte[] b = \"abcde\".getBytes();\n\t\t// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。\n        fos.write(b,2,2);\n      \t// 关闭资源\n        fos.close();\n    }\n}\n输出结果：\ncd\n```\n\n### 数据追加续写\n\n经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？\n\n- `public FileOutputStream(File file, boolean append)`： 创建文件输出流以写入由指定的 File对象表示的文件。  \n- `public FileOutputStream(String name, boolean append)`： 创建文件输出流以指定的名称写入文件。  \n\n这两个构造方法，参数中都需要传入一个boolean类型的值，`true` 表示追加数据，`false` 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示：\n\n```java\npublic class FOSWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileOutputStream fos = new FileOutputStream(\"fos.txt\"，true);     \n      \t// 字符串转换为字节数组\n      \tbyte[] b = \"abcde\".getBytes();\n\t\t// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。\n        fos.write(b);\n      \t// 关闭资源\n        fos.close();\n    }\n}\n文件操作前：cd\n文件操作后：cdabcde\n```\n\n### 写出换行\n\nWindows系统里，换行符号是`\\r\\n` 。\n\nLinux系统里，换行符号是`/n`。\n\nMac系统，换行是`\\r`\n\n把以指定是否追加续写了，代码使用演示：\n\n```java\npublic class FOSWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileOutputStream fos = new FileOutputStream(\"fos.txt\");  \n      \t// 定义字节数组\n      \tbyte[] words = {97,98,99,100,101};\n      \t// 遍历数组\n        for (int i = 0; i < words.length; i++) {\n          \t// 写出一个字节\n            fos.write(words[i]);\n          \t// 写出一个换行, 换行符号转成数组写出\n            fos.write(\"\\r\\n\".getBytes());\n        }\n      \t// 关闭资源\n        fos.close();\n    }\n}\n\n输出结果：\na\nb\nc\nd\ne\n```\n\n> * 回车符`\\r`和换行符`\\n` ：\n>   * 回车符：回到一行的开头（return）。\n>   * 换行符：下一行（newline）。\n> * 系统中的换行：\n>   * Windows系统里，每行结尾是 `回车+换行` ，即`\\r\\n`；\n>   * Unix系统里，每行结尾只有 `换行` ，即`\\n`；\n>   * Mac系统里，每行结尾是 `回车` ，即`\\r`。从 Mac OS X开始与Linux统一。\n\n## 5.4 字节输入流\n\n`java.io.InputStream `抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。\n\n- `public void close()` ：关闭此输入流并释放与此流相关联的任何系统资源。    \n- `public abstract int read()`： 从输入流读取数据的下一个字节。 \n- `public int read(byte[] b)`： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。\n\n读取数据的原理：硬盘-->内存\n\n* java程序-->jvm-->os-->os读取数据的方法-->读取文件\n\n字节输入流的使用步骤：\n\n1. 创建InputStream对象，构造方法中绑定要读取的数据源\n2. 使用FileInputStream对象中的方法read，读取文件\n3. 释放资源\n\n> 小贴士：\n>\n> close方法，当完成流的操作时，必须调用此方法，释放系统资源。\n\n## 5.5 FileInputStream类\n\n`java.io.FileInputStream `类是文件输入流，从文件中读取字节。\n\n### 构造方法\n\n* `FileInputStream(File file)`： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 \n* `FileInputStream(String name)`： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。  \n\n构造方法的作用：\n\n1. 创建一个FileInputStream对象\n2. 会把FileInputStream对象指向构造方法中要读取的文件。\n\n当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出`FileNotFoundException` 。\n\n- 构造举例，代码如下：\n\n```java\npublic class FileInputStreamConstructor throws IOException{\n    public static void main(String[] args) {\n   \t \t// 使用File对象创建流对象\n        File file = new File(\"a.txt\");\n        FileInputStream fos = new FileInputStream(file);\n      \n        // 使用文件名称创建流对象\n        FileInputStream fos = new FileInputStream(\"b.txt\");\n    }\n}\n```\n\n### 读取字节数据\n\n1. **读取字节**：`read`方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回`-1`，代码使用演示：\n\n```java\npublic class FISRead {\n    public static void main(String[] args) throws IOException{\n      \t// 使用文件名称创建流对象\n       \tFileInputStream fis = new FileInputStream(\"read.txt\");\n      \t// 读取数据，返回一个字节\n        int read = fis.read();\n        System.out.println((char) read);\n        read = fis.read();\n        System.out.println((char) read);\n        read = fis.read();\n        System.out.println((char) read);\n        read = fis.read();\n        System.out.println((char) read);\n        read = fis.read();\n        System.out.println((char) read);\n      \t// 读取到末尾,返回-1\n       \tread = fis.read();\n        System.out.println( read);\n\t\t// 关闭资源\n        fis.close();\n    }\n}\n输出结果：\na\nb\nc\nd\ne\n-1\n```\n\n循环改进读取方式，代码使用演示：\n\n```java\npublic class FISRead {\n    public static void main(String[] args) throws IOException{\n      \t// 使用文件名称创建流对象\n       \tFileInputStream fis = new FileInputStream(\"read.txt\");\n      \t// 定义变量，保存数据\n        int b ；\n        // 循环读取\n        while ((b = fis.read())!=-1) {\n            System.out.println((char)b);\n        }\n\t\t// 关闭资源\n        fis.close();\n    }\n}\n输出结果：\na\nb\nc\nd\ne\n```\n\n> 小贴士：\n>\n> 1. 虽然读取了一个字节，但是会自动提升为int类型。\n> 2. 流操作完毕后，必须释放系统资源，调用close方法，千万记得。\n\n2. **使用字节数组读取**：`read(byte[] b)`，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回`-1` ，代码使用演示：\n\n```java\npublic class FISRead {\n    public static void main(String[] args) throws IOException{\n      \t// 使用文件名称创建流对象.\n       \tFileInputStream fis = new FileInputStream(\"read.txt\"); // 文件中为abcde\n      \t// 定义变量，作为有效个数\n        int len ；\n        // 定义字节数组，作为装字节数据的容器   \n        byte[] b = new byte[2];\n        // 循环读取\n        while (( len= fis.read(b))!=-1) {\n           \t// 每次读取后,把数组变成字符串打印\n            System.out.println(new String(b));\n        }\n\t\t// 关闭资源\n        fis.close();\n    }\n}\n\n输出结果：\nab\ncd\ned\n```\n\n错误数据`d`，是由于最后一次读取时，只读取一个字节`e`，数组中，**上次读取的数据没有被完全替换**，所以要通过`len` ，获取有效的字节。\n\n这个写入文件的时候，也要通过`write(b,0,len)`；不然可能就会重复了。\n\n就比方说上面的`abcde`，如果只调用`write(b)`，就会导致输出的内容`abcded`。\n\n代码使用演示：\n\n```java\npublic class FISRead {\n    public static void main(String[] args) throws IOException{\n      \t// 使用文件名称创建流对象.\n       \tFileInputStream fis = new FileInputStream(\"read.txt\"); // 文件中为abcde\n      \t// 定义变量，作为有效个数\n        int len ；\n        // 定义字节数组，作为装字节数据的容器   \n        byte[] b = new byte[2];\n        // 循环读取\n        while (( len= fis.read(b))!=-1) {\n           \t// 每次读取后,把数组的有效字节部分，变成字符串打印\n            System.out.println(new String(b，0，len));//  len 每次读取的有效字节个数\n        }\n\t\t// 关闭资源\n        fis.close();\n    }\n}\n\n输出结果：\nab\ncd\ne\n```\n\n> 小贴士：\n>\n> 使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。\n\n## 5.6 字节流练习：图片复制\n\n### 复制原理图解\n\n{% asset_img 2_copy.jpg copy.jpg %}\n\n### 案例实现\n\n复制图片文件，代码使用演示：\n\n```java\npublic class Copy {\n    public static void main(String[] args) throws IOException {\n        // 1.创建流对象\n        // 1.1 指定数据源\n        FileInputStream fis = new FileInputStream(\"D:\\\\test.jpg\");\n        // 1.2 指定目的地\n        FileOutputStream fos = new FileOutputStream(\"test_copy.jpg\");\n\n        // 2.读写数据\n        // 2.1 定义数组\n        byte[] b = new byte[1024];\n        // 2.2 定义长度\n        int len;\n        // 2.3 循环读取\n        while ((len = fis.read(b))!=-1) {\n            // 2.4 写出数据\n            fos.write(b, 0 , len);\n        }\n\n        // 3.关闭资源\n        fos.close();\n        fis.close();\n    }\n}\n```\n\n> 小贴士：\n>\n> 流的关闭原则：先开后关，后开先关。\n\n# 第六章 字符流\n\n当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。\n\n1个中文\n\ngbk:占用两个字节\n\nutf-8:占用3个字节\n\n而字节流，一次只能读取一个字节\n\n所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。\n\n## 6.1 字符输入流【Reader】\n\n`java.io.Reader`抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。\n\n- `public void close()` ：关闭此流并释放与此流相关联的任何系统资源。    \n- `public int read()`： 从输入流读取一个字符。 \n- `public int read(char[] cbuf)`： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。\n\n字节输入流的使用步骤：\n\n1. 创建FileReader对象，构造方法中绑定要读取的数据源\n2. 使用FileReader对象中的方法read读取文件\n3. 释放资源\n\n## 6.2 FileReader类  \n\n`java.io.FileReader `类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。\n\n> 小贴士：\n>\n> 1. 字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。\n>\n> idea中UTF-8\n>\n> 2. 字节缓冲区：一个字节数组，用来临时存储字节数据。\n\n### 构造方法\n\n- `FileReader(File file)`： 创建一个新的 FileReader ，给定要读取的File对象。   \n- `FileReader(String fileName)`： 创建一个新的 FileReader ，给定要读取的文件的名称。  \n\n当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。\n\n构造方法的作用：\n\n1. 创建一个FileReader对象\n2. 会把FileReader对象指向要读取的文件\n\n- 构造举例，代码如下：\n\n```java\npublic class FileReaderConstructor throws IOException{\n    public static void main(String[] args) {\n   \t \t// 使用File对象创建流对象\n        File file = new File(\"a.txt\");\n        FileReader fr = new FileReader(file);\n      \n        // 使用文件名称创建流对象\n        FileReader fr = new FileReader(\"b.txt\");\n    }\n}\n```\n\n### 读取字符数据\n\n1. **读取字符**：`read`方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回`-1`，循环读取，代码使用演示：\n\n```java\npublic class FRRead {\n    public static void main(String[] args) throws IOException {\n      \t// 使用文件名称创建流对象\n       \tFileReader fr = new FileReader(\"read.txt\");\n      \t// 定义变量，保存数据\n        int b ；\n        // 循环读取\n        while ((b = fr.read())!=-1) {\n            System.out.println((char)b);\n        }\n\t\t// 关闭资源\n        fr.close();\n    }\n}\n输出结果：\n黑\n马\n程\n序\n员\n```\n\n> 小贴士：虽然读取了一个字符，但是会自动提升为int类型。\n\n2. **使用字符数组读取**：`read(char[] cbuf)`，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回`-1` ，代码使用演示：\n\n```java\npublic class FRRead {\n    public static void main(String[] args) throws IOException {\n      \t// 使用文件名称创建流对象\n       \tFileReader fr = new FileReader(\"read.txt\");\n      \t// 定义变量，保存有效字符个数\n        int len ；\n        // 定义字符数组，作为装字符数据的容器\n         char[] cbuf = new char[2];\n        // 循环读取\n        while ((len = fr.read(cbuf))!=-1) {\n            System.out.println(new String(cbuf));\n        }\n\t\t// 关闭资源\n        fr.close();\n    }\n}\n输出结果：\n黑马\n程序\n员序\n```\n\n获取有效的字符改进，代码使用演示：\n\n```java\npublic class FISRead {\n    public static void main(String[] args) throws IOException {\n      \t// 使用文件名称创建流对象\n       \tFileReader fr = new FileReader(\"read.txt\");\n      \t// 定义变量，保存有效字符个数\n        int len ；\n        // 定义字符数组，作为装字符数据的容器\n        char[] cbuf = new char[2];\n        // 循环读取\n        while ((len = fr.read(cbuf))!=-1) {\n            System.out.println(new String(cbuf,0,len));\n        }\n    \t// 关闭资源\n        fr.close();\n    }\n}\n\n输出结果：\n黑马\n程序\n员\n```\n\n## 6.3 字符输出流【Writer】\n\n`java.io.Writer `抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。\n\n- `void write(int c)` 写入单个字符。\n- `void write(char[] cbuf) `写入字符数组。 \n- `abstract  void write(char[] cbuf, int off, int len) `写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 \n- `void write(String str) `写入字符串。 \n- `void write(String str, int off, int len)` 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。\n- `void flush() `刷新该流的缓冲。  \n- `void close()` 关闭此流，但要先刷新它。 \n\n字符输出流的使用步骤：\n\n1. 创建FileWriter对象，构造方法中绑定要写入数据的目的地。\n2. 使用FileWriter中的write方法，把数据写入到内存缓冲区中（字符转换为字节的过程）\n3. 使用FileWriter中的flush，把内存缓冲区中的数据，刷新到文件中\n4. 释放资源(会先把内存缓冲区中的数据刷新到文件中)\n\n\n\n## 6.4 FileWriter类\n\n`java.io.FileWriter `类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。\n\n### 构造方法\n\n- `FileWriter(File file)`： 创建一个新的 FileWriter，给定要读取的File对象。   \n- `FileWriter(String fileName)`： 创建一个新的 FileWriter，给定要读取的文件的名称。  \n\n当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。\n\n构造方法的作用：\n\n1. 会创建一个FileWriter对象\n2. 会根据构造方法中传递的文件/文件的路径，创建一个文件\n3. 会把FileWriter对象，指向创建好的文件。\n\n- 构造举例，代码如下：\n\n```java\npublic class FileWriterConstructor {\n    public static void main(String[] args) throws IOException {\n   \t \t// 使用File对象创建流对象\n        File file = new File(\"a.txt\");\n        FileWriter fw = new FileWriter(file);\n      \n        // 使用文件名称创建流对象\n        FileWriter fw = new FileWriter(\"b.txt\");\n    }\n}\n```\n\n### 基本写出数据\n\n**写出字符**：`write(int b)` 方法，每次可以写出一个字符数据，代码使用演示：\n\n```java\npublic class FWWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileWriter fw = new FileWriter(\"fw.txt\");     \n      \t// 写出数据\n      \tfw.write(97); // 写出第1个字符\n      \tfw.write('b'); // 写出第2个字符\n      \tfw.write('C'); // 写出第3个字符\n      \tfw.write(30000); // 写出第4个字符，中文编码表中30000对应一个汉字。\n      \n      \t/*\n        【注意】关闭资源时,与FileOutputStream不同。\n      \t 如果不关闭,数据只是保存到缓冲区，并未保存到文件。\n        */\n        // fw.close();\n    }\n}\n输出结果：\nabC田\n```\n\n> 小贴士：\n>\n> 1. 虽然参数为int类型四个字节，但是只会保留一个字符的信息写出。\n> 2. 未调用close方法，数据只是保存到了缓冲区，并未写出到文件中。\n\n### 关闭和刷新\n\n因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要`flush` 方法了。\n\n* `flush` ：刷新缓冲区，流对象可以继续使用。\n* `close `:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。\n\n代码使用演示：\n\n```java\npublic class FWWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileWriter fw = new FileWriter(\"fw.txt\");\n        // 写出数据，通过flush\n        fw.write('刷'); // 写出第1个字符\n        fw.flush();\n        fw.write('新'); // 继续写出第2个字符，写出成功\n        fw.flush();\n      \n      \t// 写出数据，通过close\n        fw.write('关'); // 写出第1个字符\n        fw.close();\n        fw.write('闭'); // 继续写出第2个字符,【报错】java.io.IOException: Stream closed\n        fw.close();\n    }\n}\n```\n\n> 小贴士：即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。\n\n### 写出其他数据\n\n1. **写出字符数组** ：`write(char[] cbuf)` 和 `write(char[] cbuf, int off, int len)` ，每次可以写出字符数组中的数据，用法类似FileOutputStream，代码使用演示：\n\n```java\npublic class FWWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileWriter fw = new FileWriter(\"fw.txt\");     \n      \t// 字符串转换为字节数组\n      \tchar[] chars = \"黑马程序员\".toCharArray();\n      \n      \t// 写出字符数组\n      \tfw.write(chars); // 黑马程序员\n        \n\t\t// 写出从索引2开始，2个字节。索引2是'程'，两个字节，也就是'程序'。\n        fw.write(b,2,2); // 程序\n      \n      \t// 关闭资源\n        fos.close();\n    }\n}\n```\n\n2. **写出字符串**：`write(String str)` 和 `write(String str, int off, int len)` ，每次可以写出字符串中的数据，更为方便，代码使用演示：\n\n```java\npublic class FWWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileWriter fw = new FileWriter(\"fw.txt\");     \n      \t// 字符串\n      \tString msg = \"黑马程序员\";\n      \n      \t// 写出字符数组\n      \tfw.write(msg); //黑马程序员\n      \n\t\t// 写出从索引2开始，2个字节。索引2是'程'，两个字节，也就是'程序'。\n        fw.write(msg,2,2);\t// 程序\n      \t\n        // 关闭资源\n        fos.close();\n    }\n}\n```\n\n3. **续写和换行**：操作类似于FileOutputStream。\n\n```java\npublic class FWWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象，可以续写数据\n        FileWriter fw = new FileWriter(\"fw.txt\"，true);     \n      \t// 写出字符串\n        fw.write(\"黑马\");\n      \t// 写出换行\n      \tfw.write(\"\\r\\n\");\n      \t// 写出字符串\n  \t\tfw.write(\"程序员\");\n      \t// 关闭资源\n        fw.close();\n    }\n}\n输出结果:\n黑马\n程序员\n```\n\n> 小贴士：字符流，只能操作文本文件，不能操作图片，视频等非文本文件。\n>\n> 当我们单纯读或者写文本文件时  使用字符流 其他情况使用字节流\n\n# 第七章 IO异常的处理\n\n## 7.1 JDK7前处理\n\n之前的入门练习，我们一直把异常抛出，而实际开发中并不能这样处理，建议使用`try...catch...finally` 代码块，处理异常部分，代码使用演示：\n\n```java  \npublic class HandleException1 {\n    public static void main(String[] args) {\n      \t// 声明变量\n        FileWriter fw = null;\n        try {\n            //创建流对象\n            fw = new FileWriter(\"fw.txt\");\n            // 写出数据\n            fw.write(\"黑马程序员\"); //黑马程序员\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (fw != null) {\n                    fw.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n## 7.2 JDK7的处理(扩展知识点了解内容)\n\n还可以使用JDK7优化后的`try-with-resource` 语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。\n\n格式：\n\n```java\ntry (创建流对象语句，如果多个,使用';'隔开) {\n\t// 读写数据\n} catch (IOException e) {\n\te.printStackTrace();\n}\n```\n\n代码使用演示：\n\n```java\npublic class Demo02TryCatch {\n\tpublic static void main(String[] args) {\n\t\ttry (FileInputStream fis = new FileInputStream(\"c:\\\\users\\\\kitchen\\\\desktop\\\\abc\\\\abc.txt\");\n\t\t\t\tFileOutputStream fos = new FileOutputStream(\"src\\\\demo35\\\\abc.txt\")) {\n\t\t\tint len=0;\n\t\t\twhile((len=fis.read())!=-1) {\n\t\t\t\tfos.write(len);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tSystem.out.println(e);\n\t\t}\n\t}\n}\n\n```\n\n## 7.3 JDK9的改进(扩展知识点了解内容)\n\nJDK9中`try-with-resource` 的改进，对于**引入对象**的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，无需手动close，我们来了解一下格式。\n\n改进前格式：\n\n```java\n// 被final修饰的对象\nfinal Resource resource1 = new Resource(\"resource1\");\n// 普通对象\nResource resource2 = new Resource(\"resource2\");\n// 引入方式：创建新的变量保存\ntry (Resource r1 = resource1;\n     Resource r2 = resource2) {\n     // 使用对象\n}\n```\n\n改进后格式：\n\n```java\n// 被final修饰的对象\nfinal Resource resource1 = new Resource(\"resource1\");\n// 普通对象\nResource resource2 = new Resource(\"resource2\");\n\n// 引入方式：直接引入\ntry (resource1; resource2) {\n     // 使用对象\n}\n```\n\n改进后，代码使用演示：\n\n```java\npublic class TryDemo {\n    public static void main(String[] args) throws IOException {\n       \t// 创建流对象\n        final  FileReader fr  = new FileReader(\"in.txt\");\n        FileWriter fw = new FileWriter(\"out.txt\");\n       \t// 引入到try中\n        try (fr; fw) {\n          \t// 定义变量\n            int b;\n          \t// 读取数据\n          \twhile ((b = fr.read())!=-1) {\n            \t// 写出数据\n            \tfw.write(b);\n          \t}\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n# 第八章 属性集\n\n## 8.1 概述\n\n`java.util.Properties ` 继承于` Hashtable` ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，`System.getProperties` 方法就是返回一个`Properties`对象。\n\n## 8.2 Properties类\n\n### 构造方法\n\n- `public Properties()` :创建一个空的属性列表。\n\n### 基本的存储方法\n\n- `public Object setProperty(String key, String value)` ： 保存一对属性。  \n- `public String getProperty(String key) ` ：使用此属性列表中指定的键搜索属性值。\n- `public Set<String> stringPropertyNames() ` ：所有键的名称的集合。\n\n```java\npublic class ProDemo {\n    public static void main(String[] args) throws FileNotFoundException {\n        // 创建属性集对象\n        Properties properties = new Properties();\n        // 添加键值对元素\n        properties.setProperty(\"filename\", \"a.txt\");\n        properties.setProperty(\"length\", \"209385038\");\n        properties.setProperty(\"location\", \"D:\\\\a.txt\");\n        // 打印属性集对象\n        System.out.println(properties);\n        // 通过键,获取属性值\n        System.out.println(properties.getProperty(\"filename\"));\n        System.out.println(properties.getProperty(\"length\"));\n        System.out.println(properties.getProperty(\"location\"));\n\n        // 遍历属性集,获取所有键的集合\n        Set<String> strings = properties.stringPropertyNames();\n        // 打印键值对\n        for (String key : strings ) {\n          \tSystem.out.println(key+\" -- \"+properties.getProperty(key));\n        }\n    }\n}\n输出结果：\n{filename=a.txt, length=209385038, location=D:\\a.txt}\na.txt\n209385038\nD:\\a.txt\nfilename -- a.txt\nlength -- 209385038\nlocation -- D:\\a.txt\n```\n\n### 与流相关的方法\n\n#### store方法\n\n- `public void store(OutputStream out, String comments)`：将此 Properties 表中的属性列表（键和元素对）写入输出流\n- `public void store(Writer writer, String comments)`：将此 Properties 表中的属性列表（键和元素对）写入输出字符。\n\n注意事项：\n\n* OutputStream out：字节输出流，不能写入中文\n\n* Writer writer：字符输出流，可以写中文\n* String comments：注释，用来解释说明保存的文件是做什么的。不能使用中文，会产生乱码，默认是Unicode编码，一般是用\"\"空字符串。\n\n使用步骤：\n\n1. 创建Properties集合，添加数据\n2. 创建字节输出流/字符输出流对象，构造方法中绑定要输出的目的地\n3. 使用Properties集合中的方法store，将集合中的临时数据，持久化写入到硬盘中存储\n4. 释放资源\n\n案例演示：\n\n```java\npublic static void show02() {\n\t\tProperties prop=new Properties();\n\t\tprop.setProperty(\"filename\", \"abc.txt\");\n\t\tprop.setProperty(\"length\",\"12345\");\n\t\tString str=\"C:\\\\Users\\\\kitchen\\\\Desktop\\\\abc\";\n\t\tprop.setProperty(\"location\", str);\n\t\t\n\t\ttry(FileWriter fw=new FileWriter(\"c:\\\\users\\\\kitchen\\\\desktop\\\\abc\\\\abc.txt\");) {\n\t\t\tprop.store(fw, \"save data\");\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n}\n```\n\n#### load方法\n\n- `public void load(InputStream inStream)`： 从字节输入流中读取键值对。 \n- `public void load(Reader reader)`：按简单的面向行的格式从输入字符流中读取键值对\n\n参数：\n\n* InputStream inStream：字节输入流，不能读取含有中文的键值对\n* Reader reader：字符输入流，能读取含有中文的键值对\n\n使用步骤：\n\n1. 创建Properties集合对象\n2. 使用Properties集合对象中的方法load读取保存键值对的文件\n3. 遍历Properties集合\n\n注意：\n\n1. 存储键值对的文件中，键与值默认的连接符号，可以使用等号或者是空格或其他符号\n2. 存储键值对的文件中，可以使用#进行注释，被注释的键值对，不会再被读取\n3. 存储键值对的文件中，键与值默认都是字符串，不用再加引号。\n\n案例演示：\n\n```java\npublic static void show03() {\n\t\tProperties prop=new Properties();\n\t\ttry(FileReader fw=new FileReader(\"C:\\\\users\\\\kitchen\\\\desktop\\\\abc\\\\abc.txt\")){\n\t\t\tprop.load(fw);\n\t\t\tfor(String s:prop.stringPropertyNames()) {\n\t\t\t\tSystem.out.println(s+\"=\"+prop.getProperty(s));\n\t\t\t}\n\t\t}catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n}\n```\n\n","tags":["java"]},{"title":"异常","url":"/blog/2019/exception/","content":"\n有关异常的一系列知识点\n\n<!--more-->\n\n# 第一章    异常\n\n## 1.1 异常概念\n\n异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是：\n\n* **异常** ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。\n\n在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。\n\n> 异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行.\n\n## 1.2 异常体系\n\n异常机制其实是帮助我们**找到**程序中的问题，异常的根类是`java.lang.Throwable`，其下有两个子类：`java.lang.Error`与`java.lang.Exception`，平常所说的异常指`java.lang.Exception`。\n\n{% asset_img 异常体系.png 异常体系 %}\n\n**Throwable体系：**\n\n* **Error**:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。\n* **Exception**:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。\n\n**Throwable中的常用方法：**\n\n* `public void printStackTrace()`:打印异常的详细信息。\n\n  *包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。*\n\n* `public String getMessage()`:获取发生异常的原因。\n\n  *提示给用户的时候,就提示错误原因。*\n\n* `public String toString()`:获取异常的类型和异常描述信息(不用)。\n\n***出现异常,不要紧张,把异常的简单类名,拷贝到API中去查。***\n\n{% asset_img 简单的异常查看.png 简单的异常查看 %}\n\n## 1.3 异常分类\n\n我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。\n\n**异常(Exception)的分类**:根据在编译时期还是运行时期去检查异常?\n\n* **编译时期异常**:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)\n* **运行时期异常**:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)\n\n{% asset_img 异常的分类.png 异常的分类 %}\n\n## 1.4     异常的产生过程解析\n\n先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。\n\n 工具类\n\n~~~java\npublic class ArrayTools {\n    // 对给定的数组通过给定的角标获取元素。\n    public static int getElement(int[] arr, int index) {\n        int element = arr[index];\n        return element;\n    }\n}\n~~~\n\n 测试类\n\n~~~java\npublic class ExceptionDemo {\n    public static void main(String[] args) {\n        int[] arr = { 34, 12, 67 };\n        intnum = ArrayTools.getElement(arr, 4)\n        System.out.println(\"num=\" + num);\n        System.out.println(\"over\");\n    }\n}\n~~~\n\n上述程序执行过程图解：\n\n{% asset_img 异常产生过程.png 异常产生过程 %}\n\n# 第二章 异常的处理\n\nJava异常处理的五个关键字：**try、catch、finally、throw、throws**\n\n## 2.1 \t抛出异常throw\n\n在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。\n\n在java中，提供了一个**throw**关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？\n\n1. 创建一个异常对象。封装一些提示信息(信息可以自己编写)。\n\n2. 需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。\n\n   throw**用在方法内**，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。\n\n**使用格式：**\n\n~~~\nthrow new 异常类名(参数);\n~~~\n\n**注意事项:**\n\n * 1.throw关键字必须是写在方法的内部\n * 2.throw关键字后面new的对象必须是Exception或者Exception的子类对象\n * 3.throw关键字抛出指定的异常对象，就必须处理这个异常对象\n * 3.1 throw关键字后面**如果创建的是RuntimeException或者RuntimeException的子类对象**，我们可以不处理，默认交给jvm处理(打印异常，终端程序)\n * 3.2 throw关键字后面**如果创建的是编译异常（写代码的时候报错）**，那我们就必须处理这个异常，要么throws，要么try..catch\n\n例如：\n\n~~~java\nthrow new NullPointerException(\"要访问的arr数组不存在\");\n\nthrow new ArrayIndexOutOfBoundsException(\"该索引在数组中不存在，已超出范围\");\n~~~\n\n学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。\n\n~~~java\npublic class ThrowDemo {\n    public static void main(String[] args) {\n        //创建一个数组 \n        int[] arr = {2,4,52,2};\n        //根据索引找对应的元素 \n        int index = 4;\n        int element = getElement(arr, index);\n\n        System.out.println(element);\n        System.out.println(\"over\");\n    }\n    /*\n     * 根据 索引找到数组中对应的元素\n     */\n    public static int getElement(int[] arr,int index){ \n       \t//判断  索引是否越界\n        if(index<0 || index>arr.length-1){\n             /*\n             判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。\n             这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 \n              */\n             throw new ArrayIndexOutOfBoundsException(\"哥们，角标越界了~~~\");\n        }\n        int element = arr[index];\n        return element;\n    }\n}\n~~~\n\n> 注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。\n>\n> 那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。\n\n## 2.2 Objects非空判断\n\n还记得我们学习过一个类Objects吗，曾经提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。\n\n* `public static <T> T requireNonNull(T obj)`:查看指定引用对象不是null。\n\n查看源码发现这里对为null的进行了抛出异常操作：\n\n~~~java\npublic static <T> T requireNonNull(T obj) {\n    if (obj == null)\n      \tthrow new NullPointerException();\n    return obj;\n}\n~~~\n\n## 2.3  声明异常throws\n\n**声明异常**：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。\n\n关键字**throws**运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).\n\n**声明异常格式：**\n\n~~~\n修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…{   }\t\n~~~\n\n声明异常的代码演示：\n\n~~~java\npublic class ThrowsDemo {\n    public static void main(String[] args) throws FileNotFoundException {\n        read(\"a.txt\");\n    }\n\n    // 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明\n    public static void read(String path) throws FileNotFoundException {\n        if (!path.equals(\"a.txt\")) {//如果不是 a.txt这个文件 \n            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw\n            throw new FileNotFoundException(\"文件不存在\");\n        }\n    }\n}\n~~~\n\nthrows用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。\n\nFileNotFoundException extends IOException extends Exception\n\n如果抛出的多个异常对象有子父类关系，那么直接声明父类异常即可。\n\n~~~java\npublic class ThrowsDemo2 {\n    public static void main(String[] args) throws IOException {\n        read(\"a.txt\");\n    }\n\n    public static void read(String path)throws FileNotFoundException, IOException {\n        if (!path.equals(\"a.txt\")) {//如果不是 a.txt这个文件 \n            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw\n            throw new FileNotFoundException(\"文件不存在\");\n        }\n        if (!path.equals(\"b.txt\")) {\n            throw new IOException();\n        }\n    }\n}\n~~~\n\n## 2.4  捕获异常try…catch\n\n如果异常出现的话,会立刻终止程序,所以我们得处理异常:\n\n1. 该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。\n2. 在方法中使用try-catch的语句块来处理异常。\n\n**try-catch**的方式就是捕获异常。\n\n* **捕获异常**：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。\n\n捕获异常语法如下：\n\n~~~java\ntry{\n     编写可能会出现异常的代码\n}catch(定义异常变量，用来接收try中抛出的异常对象){\n     处理异常的代码\n     //记录日志/打印异常信息/继续抛出异常\n}\n~~~\n\n注意：\n\n1. try中可能会抛出多个异常对象，那么就可以使用多个catch来处理这些异常对象\n2. 如果try中产生了异常，那么就会执行catch中的异常处理逻辑，执行完毕catch中的处理逻辑，继续执行trycatch之后的代码。\n   如果try中没有产生异常，那么就不会执行catch中的异常处理逻辑，执行完try中的代码，继续执行trycatch之后的代码\n\n**try：**该代码块中编写可能产生异常的代码。\n\n**catch：**用来进行某种异常的捕获，实现对捕获到的异常进行处理。\n\n> 注意:try和catch都不能单独使用,必须连用。\n\n演示如下：\n\n~~~java\npublic class TryCatchDemo {\n    public static void main(String[] args) {\n        try {// 当产生异常时，必须有处理方式。要么捕获，要么声明。\n            read(\"b.txt\");\n        } catch (FileNotFoundException e) {// 括号中需要定义什么呢？\n          \t//try中抛出的是什么异常，在括号中就定义什么异常类型\n            System.out.println(e);\n        }\n        System.out.println(\"over\");\n    }\n    /*\n     *\n     * 我们 当前的这个方法中 有异常  有编译期异常\n     */\n    public static void read(String path) throws FileNotFoundException {\n        if (!path.equals(\"a.txt\")) {//如果不是 a.txt这个文件 \n            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw\n            throw new FileNotFoundException(\"文件不存在\");\n        }\n    }\n}\n~~~\n\n如何获取异常信息：\n\nThrowable类中定义了一些查看方法:\n\n* `public String getMessage()`:获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。\n\n\n* `public String toString()`:获取异常的类型和异常描述信息(不用)。直接输出e时，就是默认调用了toString()方法，重写了Object类的toString\n* `public void printStackTrace()`:打印异常的跟踪栈信息并输出到控制台。jvm打印异常信息，默认调用此方法\n\n​            *包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。*\n\n## 2.4 finally 代码块\n\n**finally**：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。\n\n什么时候的代码必须最终执行？\n\n当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。\n\nfinally的语法:\n\n```\t\n try {\n  可能产生异常的代码\n }catch(定义异常变量，用来接收try中抛出的异常对象){\n  异常处理逻辑 \n }finally {\n  无论是否出现异常都会执行\n }\n```\n\n注意：\n\n1. finally不能单独使用，必须与try连用\n\n2. finally一般用于资源释放（资源回收），无论程序是否出现异常，最后都要资源释放（IO ）\n\n> 注意:finally不能单独使用。\n\n比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。\n\nfinally代码参考如下：\n\n~~~java\npublic class TryCatchDemo4 {\n    public static void main(String[] args) {\n        try {\n            read(\"a.txt\");\n        } catch (FileNotFoundException e) {\n            //抓取到的是编译期异常  抛出去的是运行期 \n            throw new RuntimeException(e);\n        } finally {\n            System.out.println(\"不管程序怎样，这里都将会被执行。\");\n        }\n        System.out.println(\"over\");\n    }\n    /*\n     *\n     * 我们 当前的这个方法中 有异常  有编译期异常\n     */\n    public static void read(String path) throws FileNotFoundException {\n        if (!path.equals(\"a.txt\")) {//如果不是 a.txt这个文件 \n            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw\n            throw new FileNotFoundException(\"文件不存在\");\n        }\n    }\n}\n~~~\n\n> 当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。\n\n{% asset_img 死了都要try.png 死了都要try %}\n\n## 2.5   异常注意事项\n\n* 多个异常使用捕获又该如何处理呢？\n\n  1. 多个异常分别处理。\n  2. 多个异常一次捕获，多次处理。\n  3. 多个异常一次捕获一次处理。\n\n  一般我们是使用**一次捕获多次处理**方式，格式如下：\n\n  ```java\n  try{\n       编写可能会出现异常的代码\n  }catch(异常类型A  e){  当try中出现A类型异常,就用该catch来捕获.\n       处理异常的代码\n       //记录日志/打印异常信息/继续抛出异常\n  }catch(异常类型B  e){  当try中出现B类型异常,就用该catch来捕获.\n       处理异常的代码\n       //记录日志/打印异常信息/继续抛出异常\n  }\n  ```\n\n  > 注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么**子类异常要求在上面的catch处理，父类异常在下面的catch处理**。\n\n  理解这个过程：\n\n  {% asset_img 一次捕获多次处理过程解析.png 一次捕获多次处理过程解析 %}\n\n* 运行时异常被抛出可以不处理。即不捕获也不声明抛出。默认给虚拟机处理，让它终止程序，什么时候不抛出运行时异常了，再来继续执行程序\n* 如果finally有return语句,永远返回finally中的结果,避免该情况(尽量不要再finally中写return语句).\n* 如果父类抛出了多个异常,子类重写父类方法时,抛出**和父类相同的异常**或者是**父类异常的子类**或者**不抛出异常**。\n* 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能**捕获处理**，不能声明异常抛出异常\n\n\n\n\n# 第三章 自定义异常\n\n## 3.1 概述\n\n**为什么需要自定义异常类:**\n\n我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题,考试成绩负数问题等等。\n\n在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？\n\n**什么是自定义异常类:**\n\n在开发中根据自己业务的异常情况来定义异常类.\n\n自定义一个业务逻辑异常: **RegisterException**。一个注册异常类。\n\n**异常类如何定义:**\n\n1. 自定义一个编译期异常: 自定义类 并继承于`java.lang.Exception`。\n2. 自定义一个运行时期的异常类:自定义类 并继承于`java.lang.RuntimeException`。\n\n## 3.2 自定义异常的练习\n\n要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。\n\n首先定义一个登陆异常类RegisterException：\n\n~~~java\n// 业务逻辑异常\npublic class RegisterException extends Exception {\n    /**\n     * 空参构造\n     */\n    public RegisterException() {\n    }\n\n    /**\n     *\n     * @param message 表示异常提示\n     */\n    public RegisterException(String message) {\n        super(message); \n    }\n}\n~~~\n\n模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。\n\n~~~java\npublic class Demo {\n    // 模拟数据库中已存在账号\n    private static String[] names = {\"bill\",\"hill\",\"jill\"};\n   \n    public static void main(String[] args) {     \n        //调用方法\n        try{\n              // 可能出现异常的代码\n            checkUsername(\"nill\");\n            System.out.println(\"注册成功\");//如果没有异常就是注册成功\n        }catch(RegisterException e){\n            //处理异常\n            e.printStackTrace();\n        }\n    }\n\n    //判断当前注册账号是否存在\n    //因为是编译期异常，又想调用者去处理 所以声明该异常\n    public static boolean checkUsername(String uname) throws LoginException{\n        for (String name : names) {\n            if(name.equals(uname)){//如果名字在这里面 就抛出登陆异常\n                throw new RegisterException(\"亲\"+name+\"已经被注册了！\");\n            }\n        }\n        return true;\n    }\n}\n~~~\n\n\n","tags":["java"]},{"title":"final关键字与权限修饰符","url":"/blog/2019/final-and-permission/","content":"\n教你如何使用final关键字，以及权限修饰符\n\n<!--more-->\n\n## 一、final关键字\n\nfinal关键字代表最终、不可改变的的。\n\n常见四种用法：\n\n1. 可以用来修饰一个类\n2. 还可以修饰一个方法\n3. 还可以用来修饰一个局部变量\n4. 还可以用来修饰一个成员变量\n\n#### 修饰类\n\n当final关键字用来修饰一个类的时候，\n\n格式：\n\n```\npublic final class 类名称 {\n//...\n}\n```\n\n含义：当前这个类，不能有任何子类，也就是太监类（继承就会报错）\n\n注意：一个类如果是final的，那么其中的所有的成员方法都不能进行覆盖重写（因为没有儿子）\n\n#### 修饰方法\n\n当final关键字用来修饰一个方法的时候，这个方法就是最终方法，也就是不能被覆盖重写。\n\n格式：\n\n```\n修饰符 final 返回值类型 方法列表(参数列表){\n//方法体\n}\n```\n\n注意事项：\n\n对于类、方法来说，abstract和final关键字不能同时使用，因为矛盾(abstract是一定要被重写的，final关键字是不能被重写的)\n\n#### 修饰局部变量\n\nStudent.java\n\n```\npublic class Student {\n\tprivate String name;\n\n\tpublic Student() {\n\n\t}\n\n\tpublic Student(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n}\n```\n\nMain.java\n\n```\npublic static void main(String[] args) {\n\t\tint num=10;\n\t\tSystem.out.println(num);//10\n\t\tnum=20;\n\t\tSystem.out.println(num);//20\n\t\t\n\t\t\n\t\t//一旦使用final来修饰局部变量，那么这个变量就不能进行更改\n\t\t//一次赋值，终身不变\n\t\tfinal int num1=10;\n\t\tSystem.out.println(num1);//10\n\t\t//num1=20;//错误写法，不能改变\n\t\t//num1=10;//即使数值一样也是错误写法，只能赋值一次\n\t\t\n\t\tfinal int num2;\n\t\tnum2=10;//这个是正确写法，只要保证赋值一次即可\n\t\tSystem.out.println(num2);\n\t\t\n\t\t//对于基本类型来说，不可变，指的是变量当中的值不可改变\n\t\t//对于引用类型来说，不可变，指的是变量当中的地址值不可改变，但是存储的值是可以变的\n\t\tStudent stu1 = new Student(\"哈哈\");\n\t\tSystem.out.println(stu1);\n\t\tSystem.out.println(stu1.getName());//哈哈\n\t\tstu1=new Student(\"呵呵\");\n\t\tSystem.out.println(stu1);\n\t\tSystem.out.println(stu1.getName());//呵呵\n\t\t\n\t\tfinal Student stu2=new Student(\"娃哈哈\");\n\t\tSystem.out.println(stu2+stu2.getName());//地址不变+娃哈哈\n//\t\tstu2=new Student(\"哦呵呵\");//报错\n//\t\tSystem.out.println(stu2+stu2.getName());\n\t\t\n\t\tstu2.setName(\"哦呵呵\");\n\t\tSystem.out.println(stu2+stu2.getName());//地址不变+哦呵呵\n\t}\n```\n\n#### 修饰成员变量\n\n对于成员变量来说，如果使用final关键字来修饰，那么这个变量也不可变\n\n1. 由于成员变量具有默认值，所以用了final之后，必须手动赋值，不然就是默认值，且无法改变\n2. 对于final的成员变量，要不直接赋值，要不通过构造方法赋值。二者选其一\n3. 必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值，如果不能用，就直接赋值\n\n```\npublic class Person {\n\t//方案一\n\t//private final String name=\"八戒\";\n\t\n\t\n\t//方案二\n\tprivate final String name;\n\n\n\tpublic Person() {\n\t\tthis.name=\"八戒\";\n\t}\n\n\tpublic Person(String name) {\n\t\tthis.name = name;\n\t}\n\t\n}\n```\n\n## 二、权限修饰符\n\nJava中有四种权限修饰符\n\n|                        | public | protected | (default) | private |\n| :--------------------: | :----: | :-------: | :-------: | :-----: |\n|   同一个类（我自己）   |  Yes   |    Yes    |    Yes    |   Yes   |\n|   同一个包（我邻居）   |  Yes   |    Yes    |    Yes    |   No    |\n|  不同包子类（我儿子）  |  Yes   |    Yes    |    No     |   No    |\n| 不同包非子类（陌生人） |  Yes   |    No     |    No     |   No    |\n\n注意事项：\n\n(default)不是关键字，而是根本不写","tags":["java"]},{"title":"《集结号》观后感","url":"/blog/2019/feeling/","content":"\n今天下午上近代史课，悄悄地把《集结号》看完了。说感动，肯定有的，我佩服这47个人；有愤恨，我讨厌那些理直气壮来问谷子地怎么活下来的官员的嘴脸。因此有不少感悟。\n\n<!--more-->\n\n为啥写这篇玩意呢？\n\n今天下午上近代史课，悄悄地把《集结号》看完了。说感动，肯定有的，我佩服这47个人；有愤恨，我讨厌看到那些理直气壮来问谷子地怎么活下来的官员的嘴脸。因此有不少感悟。\n\n现在是2019年11月7号下午17点29分，我现在记录下来我此时的心情。希望`不惑之年`后的我，看到此时的感悟，会觉得`青涩`，希望吧！\n\n我属于那种自小看金庸小说长大的那种人，`“侠之大者，为国为民“` 这句话我也是从金庸老先生的书里学来的。\n\n侠气我没有，书生气还是有的。\n\n我一直想在后面加上一句话，这句话应该说成，`”侠之大者，为国为民，死无全尸“` 。\n\n侠之大者，大多数都是`死脑筋`的，结局也没见有几个好的。别的我不了解，毕竟尚未踏足社会，我就以金庸世界里的人来说。\n\n---\n\n\n\n> 萧峰\n\n乔峰生于辽国，长于大宋，实为契丹人。之后知道自己身世，改名萧峰。\n\n一生有情有义，为情坚贞，为国忠诚。\n\n萧峰生为契丹人，又被宋人所养，无论是家国兴亡，还是儿女情长，夹在辽宋之间，都备受煎熬。向着契丹人，还是向着宋人？怎么选，都是错，怎么选，都是折磨。\n\n最好的结果，就是化解辽宋之战，纵不能改天换地，起码能换十年两国太平，也算对得起自己一场英雄气节。\n\n最后，成功阻止并胁迫辽国皇帝耶律洪基下令”终生不许辽军一兵一卒越过宋辽疆界“。\n\n<u>“人不是该死的时候死的，而是能死的时候死的”</u>，萧峰说的。\n\n萧峰觉得保了大宋，对不起大辽，更对不起自己的内心。自尽了。\n\n还有一种可能，不自杀。萧峰武功独步天下，声明远播，就算我不自尽，又能如何，谁奈我何？我保了大宋十年和平，让你辽国十年不再争斗，不应该感谢我吗？\n\n其实，有这样的想法的人，他成不了大侠。\n\n大侠，说实话，只是傻得彻底罢了。\n\n---\n\n\n\n> 郭靖、杨过\n\n<u>郭靖又道:\"我辈练功学武，所为何事？行侠仗义、济人困厄固然乃是本分，但这只是侠之小者。江湖上所以尊称我一声郭大侠，实因敬我为国为民、奋不顾身的驻守襄阳。然我才力有限，不能为民解困，是在愧当大侠两字。你聪明智慧过我十倍，将来成就定然远超于我，这是不消说的。只盼你心头牢牢记着**为国为民，侠之大者**这八个字，日后名扬天下，成为受万民敬仰的真正大侠。\" 这一番说诚挚恳切，杨过只听得耸然动容，见郭靖神色庄严，虽知他是自己杀父之仇，却也不禁肃然起敬。</u>\n\n杨过虽然觉得郭靖说得有道理，对他肃然起敬，但是杨过毕竟不同于郭靖。因为本身杨过之父杨康就与郭靖不是一类人。杨康聪明，杨过自然不差。而郭靖是个死脑筋，认死理那种。\n\n听了别人的一些牛逼事情，我们肃然起敬，为啥？**因为我们有自知之明。**\n\n就比方说，我们尊敬马云，是因为我们知道自己达不到人家的那种程度；如果你有自信能够成为世界首富，或者已经是了，你可能会认为，呵，他有什么了不起，就是个垃圾。\n\n**因为我们知道，他们做的事，我们是做不到的，由此而来的敬畏之情。**\n\n郭靖与黄蓉双双殉国；杨过跟小龙女退隐江湖。\n\n如果郭靖是杨过的话，我不说可能，我说一定，他一定还会为国而死的。这货是个死脑筋，认死理，傻逼玩意儿，傻得让人可怜、可畏。\n\n郭靖太傻了，杨过太精了，两者是个很鲜明的对比。\n\n---\n\n\n\n> 谷子地\n\n谷子地是个大侠，因为他认死理，死脑筋，不知变通，死守阵地掩护部队撤退。\n\n从刘泽水下令，47人死守阵地掩护大部队撤退的时候，就注定要团灭了。别跟我说，军令如山，不得不守。扯尼玛的淡！\n\n排长焦大鹏死得时候，说自己听见了集结号，他的部下也说听到了，并且指明山那边早已经没了自家部队的动静，肯定是早撤退了。谷子地说自己没听见。他太傻了。其实他的部下知道根本守不住了，再守只能团灭。\n\n谷子地就是个傻子，守到队伍里打得一个子儿不剩。47人，打退敌人三次进攻，炸毁两辆坦克，歼敌无数。\n\n兄弟都是好兄弟。存活下来的谷子地想为兄弟们正名，享受应得的待遇。辗转十年，终于找到了老部队，才知道，不是没听到集结号声，而是人家根本就没打算吹号。\n\n我们为了保一个团，牺牲你47人咋地了！\n\n对对对，从大局来看，您说的没毛病。\n\n十年之后，所有人都得到了正名，发了荣誉，然而有什么用？\n\n这十年内，有烈士待遇的亲属，享受700斤粮食；带着失踪标签的军人，只能享受200斤粮食，并且还要受到身边人的闲言碎语。\n\n是，你们是大侠，但，有什么用？\n\n---\n\n其实，我最佩服的人是令狐冲、马云这种的人，我感觉他们把事情看得很清楚。令狐冲剑术独步天下，归隐山林。马云激流勇退，衣锦还乡。\n\n为什么马云被人称为风清扬（令狐冲的师父），我觉得，就是因为他的这种性格。\n\n激流勇退，不仅是一种勇气，还是一种远见。获得潇洒，自由。何乐而不为？\n\n大侠固然好，但我觉得，不应该是现在价值观一直推崇宣扬的，隐士不值得推崇吗？\n\n做大侠好，可我就是不想做大侠，老子做个开开心心的垃圾，不好吗？\n\n军令如山，我可去尼玛的吧，说给谁听呢。","tags":["life","movie"]},{"title":"函数式接口","url":"/blog/2020/functional-interface/","content":"\n学习一下函数式接口！才发现java的jdk都特么更新到14了！\n\n<!--more-->\n\n# 第一章 函数式接口\n\n## 1.1 概念\n\n函数式接口在java中是指：有且仅有一个抽象方法的接口。\n\n函数式接口，即适用于函数式编程场景的接口。而java中的函数式编程提现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，java中的Lambda才能顺利地进行推导。\n\n> 备注：语法糖是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的for-each语法，其实底层的实现原理仍然是迭代器，这便是语法糖。从应用层面来讲，java中的Lambda可以被当做是匿名内部类的语法糖，但是二者在原理上是不同的。\n\n## 1.2 格式\n\n只要确保接口中有且仅有一个抽象方法即可，当然，接口中可以包含其他方法：默认方法、静态方法、私有方法\n\n```java\n修饰符 interface 接口名称 {\n    public abstract 返回值类型 方法名称（可选参数信息）;\n    //其他非抽象方法内容\n}\n```\n\n由于接口当中抽象方法的`public abstract`是可以省略的，所以定义一个函数式接口其实很简单。\n\n```java\npublic interface MyFunctionalInterface {\n    void myMethod();\n}\n```\n\n## 1.3 @FunctionalInterface注解\n\n与`@Override`注解的作用类似，java8中专门为函数式接口引入了一个新的注解：`@FunctionalInterface`。该注解可用于一个接口的定义上\n\n```java\n@FunctionalInterface\npublic interface MyFunctionalInterface {\n    void myMethod();\n}\n```\n\n一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。需要注意的是，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样。\n\n## 1.4 自定义函数式接口\n\n对于刚刚定义好的`MyFunctionalInterface`函数式接口，典型使用场景就是作为方法的参数\n\n```java\npublic class Demo02 {\n\t//定义一个方法，参数使用函数式接口Demo01FunctionalInterface\n\tpublic static void show(Demo01FunctionalInterface myInter) {\n\t\tmyInter.method();\n\t}\n\tpublic static void main(String[] args) {\n\t\t//调用show方法，方法的参数是一个接口，所以可以传递接口的实现类对象\n\t\tshow(new Demo01FunctionalInterfaceImpl());\n\t\t\n\t\t//调用show方法，方法的参数是一个接口，所以可以传递接口的匿名内部类\n\t\tshow(new Demo01FunctionalInterface() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void method() {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\tSystem.out.println(\"使用匿名内部类重写接口中的抽象方法\");\n\t\t\t}\n\t\t});\n\t\t\n\t\t//调用show方法，方法的参数是一个函数式接口，所以，我们可以，传递Lambda表达式\n\t\tshow(()->{\n\t\t\tSystem.out.println(\"使用Lambda表达式重写接口中的抽象方法\");\n\t\t});\n\t\t\n\t\t//简化Lambda表达式\n\t\tshow(()->System.out.println(\"使用Lambda简化表达式重写\"));\n\t}\n}\n\n```\n\n\n\n# 第二章 函数式编程\n\n在兼顾面向对象特性的基础上，java语言通过Lambda表达式与方法引用等，为开发者打开了函数式编程的大门。\n\n## 2.1 Lambda的延迟执行\n\n有些场景的代码执行后，结果不一定会被使用，从而造成性能浪费，而Lambda表达式是延迟执行的，这正好可以作为解决方法，提升性能。\n\n### 性能浪费的日志案例\n\n一种典型的场景就是对参数进行有条件使用，例如对日志消息进行拼接后，在满足条件的情况下进行打印输出。\n\n> 注：日志可以帮助我们快速的定位问题，记录程序运行过程中的情况，以便项目的监控和优化。\n\n```java\npublic class Demo03Logger {\n\t//定义一个根据日志的级别，显示日志信息的方法\n\tpublic static void showLog(int level,String message) {\n\t\t//对日志等级进行判断，如果是1级别，那么输出日志信息\n\t\tif(level==1) {\n\t\t\tSystem.out.println(message);\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\t//定义三个日志信息\n\t\tString msg1=\"Hello\";\n\t\tString msg2=\"World\";\n\t\tString msg3=\"Java\";\n\t\t\n\t\t//调用showLog方法，传递日志级别和日志信息\n\t\tshowLog(1,msg1+msg3+msg3);\n\t}\n}\n```\n\n上面这样的写法，就存在浪费，用showLog方法，传递的第二个参数是一个拼接后的字符串，先把字符串拼接好，再调用showLog方法，showLog方法中，如果传递的等级不是1级，那么就不会输出拼接后的字符串，所以，就是白拼接了，存在了性能浪费\n\n### 体验Lambda的更优写法\n\n```java\n//MessageBuilder.java\n@FunctionalInterface\npublic interface MessageBuilder {\n\t//定义一个拼接消息的抽象方法，方法返回被拼接的消息\n\tpublic abstract String builderMessage();\n}\n\n//Demo01Lambda.java\npublic class Demo04Lambda {\n\t// 定义一个显示日志的方法，方法的参数显示日志的等级，和MessageBuilder接口\n\tpublic static void showLog(int level, MessageBuilder mb) {\n\t\t// 对日志的等级进行判断，如果是1级，则调用MessageBuilder接口的builderMessage方法\n\t\tif (level == 1) {\n\t\t\tmb.builderMessage();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// 定义三个日志信息\n\t\tString msg1 = \"Hello\";\n\t\tString msg2 = \"World\";\n\t\tString msg3 = \"Java\";\n\n\t\t// 调用showLog方法，参数MessageBuilder是一个函数式接口，所以可以传递Lambda表达式\n\t\tshowLog(1,()->msg1+msg2+msg3);\n\t}\n}\n\n```\n\n使用Lambda表达式作为参数传递，仅仅是把参数传递到showLog方法中\n\n只有满足条件，日志的等级是1级，才会调用接口中的方法\n\n如果条件不满足，那么就不会调用执行方法，所以拼接字符串的代码也不会执行，就不会存在性能浪费问题了\n\n### 证明Lambda的延迟\n\n```java\npublic class Demo04Lambda {\n\t// 定义一个显示日志的方法，方法的参数显示日志的等级，和MessageBuilder接口\n\tpublic static void showLog(int level, MessageBuilder mb) {\n\t\t// 对日志的等级进行判断，如果是1级，则调用MessageBuilder接口的builderMessage方法\n\t\tif (level == 1) {\n\t\t\tmb.builderMessage();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// 定义三个日志信息\n\t\tString msg1 = \"Hello\";\n\t\tString msg2 = \"World\";\n\t\tString msg3 = \"Java\";\n\n\t\t// 调用showLog方法，参数MessageBuilder是一个函数式接口，所以可以传递Lambda表达式\n\t\tshowLog(1,()->{\n            System.out.println(\"不满足条件不执行\");\n            return msg1+msg2+msg3\n        });\n\t}\n}\n\n```\n\n从结果中可以看出，在不符合级别要求的情况下，Lambda将不会执行。从而达到节省性能的效果\n\n> 扩展：实际上使用内部类也可以达到同样的效果，只是将代码操作延迟到了另外一个对象当中，通过调用方法来完成。而是否调用其所在方法是在条件判断之后才执行的。\n\n## 2.2 使用Lambda作为参数和返回值\n\n如果抛开实现原理不说，java中的Lambda表达式可以被当做是匿名内部类的替代品。如果方法的参数是一个函数式接口类型，那么就可以使用Lambda表达式进行替代。使用Lambda表达式作为方法参数，其实就是使用函数式接口作为方法参数。\n\n例如`java.lang.Runnable`接口就是一个函数式接口，假设有一个`startThread`方法使用该接口作为参数，那么就可以使用Lambda进行传参。这种情况其实和`Thread`类的构造方法参数为`Runnable`没有本质区别。\n\n```java\npublic class Demo05Runnable {\n\tpublic static void startThread(Runnable run) {\n\t\tnew Thread(run).start();\n\t}\n\tpublic static void main(String[] args) {\n\t\t//调用startThread方法，方法的参数是一个接口，那么我们可以传递这个接口的匿名内部类\n\t\tstartThread(new Runnable() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\tSystem.out.println(Thread.currentThread().getName()+\"-->\"+\"线程启动了\");\n\t\t\t}\n\t\t});\n\t\t\n\t\t//调用startThread方法，方法的参数是一个函数式接口，所以可以传递Lambda表达式\n\t\tstartThread(()->{\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"-->\"+\"线程启动了\");\n\t\t});\n\t\t\n\t\t//优化Lambda表达式\n\t\tstartThread(()->System.out.println(Thread.currentThread().getName()+\"-->\"+\"线程启动了\"));\n\t}\n}\n```\n\n类似地，如果一个方法的返回值类型是一个函数式接口，那么就可以直接返回一个Lambda表达式，当需要通过一个方法来获取一个java.util.Comparator接口类型的对象作为排序器时，就可以调用该方法获取。\n\n```java\npublic class Demo06Comparator {\n\t//定义一个方法，方法的返回值类型使用函数式接口Comparator\n\tpublic static Comparator<String> getComparator(){\n\t\t//方法的返回值类型是一个接口，那么我们可以返回接口的匿名内部类\n//\t\treturn new Comparator<String>() {\n//\n//\t\t\t@Override\n//\t\t\tpublic int compare(String o1, String o2) {\n//\t\t\t\t// TODO Auto-generated method stub\n//\t\t\t\treturn o2.length()-o1.length();\n//\t\t\t}\n//\t\t};\n\t\t\n\t\t//方法的返回值类型是一个函数式接口，所以我们可以返回一个Lambda表达式\n//\t\treturn (String o1,String o2)->{return o2.length()-o1.length();};\n\t\t\n\t\t//优化Lambda表达式\n\t\treturn (o1,o2)->o2.length()-o1.length();\n\t}\n\tpublic static void main(String[] args) {\n\t\tString[] arr= {\n\t\t\t\t\"bbb\",\"aaa\",\"b\",\"ccc\",\"dddddd\"\n\t\t};\n\t\t//输出原顺序\n\t\tSystem.out.println(Arrays.toString(arr));\n\t\t//调用Arrays中的sort方法，对字符串数组进行排序\n\t\tArrays.sort(arr,getComparator());\n\t\t//输出排序后的结果\n\t\tSystem.out.println(Arrays.toString(arr));\n\t}\n}\n```\n\n\n\n# 第三章 常用函数式接口\n\nJDK提供了大量常用的函数式接口以及丰富的Lambda的典型使用场景，它们主要在`java.util.function`包中被提供，下面是最简单的几个接口以及使用示例。\n\njava14官方文档，请[点击](https://docs.oracle.com/en/java/javase/14/docs/api/java.base/module-summary.html)\n\n`java.util.function.Supplier<T>`接口包含一个无参的方法：`T get()`。用来获取一个泛型参数指定类型的对象数据。由于这是一个函数式接口，这也就意味着对应的Lambda表达式需要“对外提供”一个符合泛型类型的对象数据。\n\n`Supplier<T>`接口被称之为生产型接口，指定接口的泛型是什么类型，那么接口中的get方法就会生产什么类型的数据\n\n```java\npublic class Demo07Supplier {\n\t//定义一个方法，方法的参数传递Supplier<T>接口，泛型指定String，get方法就会返回一个字符串\n\tpublic static String getString(Supplier<String> sup) {\n\t\treturn sup.get();\n\t}\n\tpublic static void main(String[] args) {\n\t\t//调用getString方法，方法的参数Supplier是一个函数式接口，所以可以传递Lambda表达式\n//\t\tString s=getString(()->{\n//\t\t\t//生产一个字符串，并返回\n//\t\t\treturn \"胡歌\";\n//\t\t});\n\t\t\n\t\t//优化Lambda表达式\n\t\tString s=getString(()->\"胡歌\");\n\t\tSystem.out.println(s);\n\t}\n}\n```\n\n\n\n## 3.2 练习：求数组元素最大值\n\n### 题目\n\n使用`Supplier`接口作为方法参数类型，通过Lambda表达式求出int数组中的最大值。提示：接口的泛型使用`java.lang.Integer`类\n\n### 解答\n\n```java\npublic class Demo07SupplierPractice {\n\t//定义一个方法，用于获取int类型数组中元素的最大值，方法的参数传递Supplier接口，泛型使用Integer\n\tpublic static int getMax(Supplier<Integer> sup) {\n\t\treturn sup.get();\n\t}\n\tpublic static void main(String[] args) {\n\t\tint[] arr= {\n\t\t\t\t1,3,1,5,6,7,8,33\n\t\t};\n\t\t//调用getMax方法，方法的参数是一个函数式接口，所以可以传递Lambda表达式\n\t\tint max=getMax(()->{\n\t\t\t//获取数组的最大值，并且返回\n\t\t\t//定义一个变量，把数组中的第一个元素赋值给该变量，让他记录数组中元素的最大值\n\t\t\tint num=arr[0];\n\t\t\t//遍历数组，获取数组中的其他元素\n\t\t\tfor(int i:arr) {\n\t\t\t\tif(i>num)\n\t\t\t\t\tnum=i;\n\t\t\t}\n\t\t\treturn num;\n\t\t});\n\t\tSystem.out.println(max);\n\t\t\n\t\t\n\t}\n}\n```\n\n\n\n## 3.3 Consumer接口\n\n`java.util.function.Consumer<T>`接口则正好与Supplier接口相反，它不是生产一个数据，而是消费一个数据，其数据类型由泛型决定\n\n### 抽象方法：accept\n\nConsumer接口中包含抽象方法`void accept(T t)`，意为消费一个指定泛型的数据。\n\nConsumer接口是一个消费型几口，泛型执行什么类型，就可以使用accept方法，消费什么类型的数据。\n\n至于具体怎么消费（使用），就需要自定义（输出，计算，...）\n\n基本使用如\n\n```java\npublic class Demo08Consumer {\n\t/*\n\t * 定义一个方法\n\t * 方法的参数传递一个字符串的姓名\n\t * 方法的参数传递Consumer接口，泛型使用字符串\n\t * 可以使用Consumer接口来消费字符串的姓名\n\t */\n\tpublic static void method(String name,Consumer<String> con) {\n\t\tcon.accept(name);\n\t}\n\tpublic static void main(String[] args) {\n\t\t//调用method方法，传递字符串姓名，方法的另一个参数是Consumer接口，是一个函数式接口，所以可以传递Lambda表达式\n\t\tmethod(\"任盈盈\",(name)->{\n\t\t\t//对传递的字符串进行消费\n\t\t\t//消费方式：直接输出字符串\n\t\t\tSystem.out.println(name);\n\t\t\t//消费方式：把字符串进行反转输出\n\t\t\tSystem.out.println(new StringBuilder(name).reverse().toString());\n\t\t});\n\t}\n\n}\n\n```\n\n当然，更好的方法是使用方法引用。\n\n### 默认方法：andThen\n\n如果一个方法的参数和返回值全都是Consumer类型，那么就可以实现效果：消费数据的时候，首先做一个操作，然后再做一个操作，实现组合。而这个方法就是`Consumer`接口中的default方法`andThen`。下面是jdk的源代码\n\n```java\ndefault Consumer<T> andThen(Consumer<? super T> after) {\n        Objects.requireNonNull(after);\n        return (T t) -> { accept(t); after.accept(t); };\n}\n```\n\n\n> 备注：`java.util.Objects`的`requireNonNull`静态方法将会在参数为null时主动抛出\n>\n> `NullPointerException`异常，这省去了重复编写if语句和抛出空指针异常的麻烦。\n\n要想实现组合，需要两个或多个Lambda表达式即可，而andThen的语义正式“一步接一步”操作。\n\n`con1.andThen(con2).accept(s)`谁写前边谁先消费\n\n例如两个步骤组合的情况。\n\n```java\npublic class Demo09Consumer {\n\t//定义一个方法，方法的参数传递一个字符串和两个Consumer接口，Consumer接口也是用字符串\n\tpublic static void method(String s,Consumer<String> con1,Consumer<String> con2) {\n//\t\tcon1.accept(s);\n//\t\tcon2.accept(s);\n\t\t\n\t\tcon2.andThen(con1).accept(s);\n\t}\n\tpublic static void main(String[] args) {\n\t\t//调用method方法，传递一个字符串和两个Lambda表达式\n\t\tmethod(\"hello\",(s)->{\n\t\t\t//消费方式：把字符串转换为大写输出\n\t\t\tSystem.out.println(s.toUpperCase());\n\t\t},(s)->{\n\t\t\t//消费方式：把字符串转换为小写输出\n\t\t\tSystem.out.println(s.toLowerCase());\n\t\t});\n\t}\n\n}\n```\n\n通过链式写法可以实现更多步骤的组合。\n\n## 3.4 练习：格式化打印信息\n\n### 题目\n\n下面的字符串数组当中有多条信息，请按照格式“姓名：xx。性别：xx。“的格式将信息打印出来。要求将打印姓名的动作作为第一个Consumer接口的Lambda实例，将打印性别的动作作为第二个Consumer接口的Lambda实例，将两个Consumer接口按照顺序”拼接“到一起。\n\n```java\nString[] arr= {\n\t\"迪丽热巴，女\",\"古力娜扎，女\",\"马尔扎哈，男\"\n};\n```\n\n解答\n\n```java\npublic class Demo10FormatPrint {\n\t//定义一个方法，参数传递String类型的数组和两个Consumer接口，泛型使用String\n\tpublic static void printInfo(String[] arr,Consumer<String> con1,Consumer<String> con2) {\n\t\tfor(String s:arr) {\n\t\t\tcon1.andThen(con2).accept(s);\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tString[] arr= {\n\t\t\t\t\"迪丽热巴，女\",\"古力娜扎，女\",\"马尔扎哈，男\"\n\t\t};\n\t\tprintInfo(arr, (s)->{\n\t\t\tSystem.out.println(\"姓名：\"+s.split(\"，\")[0]);\n\t\t}, (s)->{\n\t\t\tSystem.out.println(\"性别：\"+s.split(\"，\")[1]);\n\t\t});\n\t}\n}\n```\n\n\n\n## 3.5 Predicate接口\n\n有时候我们需要对某种类型的数据进行判断，从而得到一个boolean值结果。这是可以使用`java.util.function.Predicate<T>`接口。\n\n### 抽象方法：test\n\nPredicate接口中包含一个抽象方法：boolean test(T t)。用于条件判断的场景：\n\n```java\npublic class Demo11Predicate {\n\t//定义一个方法，参数传递一个String类型的字符串，传递一个Predicate接口，泛型使用String\n\t//使用Predicate中的test()，对字符串进行判断，并把判断的结果返回\n\tpublic static boolean checkString(String s,Predicate<String> pre) {\n\t\treturn pre.test(s);\n\t}\n\tpublic static void main(String[] args) {\n\t\t//定义一个字符串\n\t\tString s=\"abcde\";\n\t\t\n\t\t//调用checkString方法，对字符串进行校验，参数传递字符串和Lambda表达式\n\t\tboolean bool=checkString(s,(str)->{\n\t\t\t//对参数传递的字符串进行判断，判断字符串的长度是否大于5\n\t\t\t//并把判断的结果返回\n\t\t\treturn str.length()>5;\n\t\t});\n        //上面这个Lambda表达式是可以优化的\n        \n\t\tSystem.out.println(bool);\n\t}\n}\n\n```\n\n条件判断的标准是传入的Lambda表达式逻辑，只要字符串长度大于5则认为很长。\n\n### 默认方法：and\n\n既然是条件判断，就会存在与、或、非三种常见的逻辑关系。其中将两个Predicate条件使用\"与\"逻辑谅解起来实现\"并且\"的效果时，可以使用default方法and。其jdk源码：\n\n```java\ndefault Predicate<T> and(Predicate<? super T> other) {\n        Objects.requireNonNull(other);\n        return (t) -> test(t) && other.test(t);\n}\n```\n\n如果要判断一个字符串既要长度大于5，又要包含大写\"a\"，那么：\n\n```java\npublic class Demo11Predicate_and {\n\t//定义一个方法，方法的参数，传递一个字符串，传递两个Predicate接口\n\t//一个判断字符串的长度是否大于5\n\t//一个判断字符串是否包含a\n\t//两个条件必须同时满足\n\tpublic static boolean checkString(String s,Predicate<String> pre1,Predicate<String> pre2) {\n//\t\treturn pre1.test(s)&&pre2.test(s);//这是常规写法\n\t\treturn pre1.and(pre2).test(s);\n\t}\n\tpublic static void main(String[] args) {\n\t\t//定义一个字符串\n\t\tString s=\"abcdef\";\n\t\t//调用checkString方法，参数传递字符串和两个Lambda表达式\n\t\tboolean b=checkString(s,(t)->{\n\t\t\treturn t.length()>5;\n\t\t},(t)->{\n\t\t\treturn t.contains(\"a\");\n\t\t});\n\t\tSystem.out.println(b);\n\t}\n}\n```\n\n### 默认方法：or\n\n与and的\"与\"类似，默认方法or实现逻辑关系中的\"或\"。jdk源码\n\n```java\ndefault Predicate<T> or(Predicate<? super T> other) {\n     Objects.requireNonNull(other);\n     return (t) -> test(t) || other.test(t);\n}\n```\n\n如果希望实现逻辑\"字符串包含大写H或者大写W\"，那么代码只需要将\"and\"修改为\"or\"名称即可，其他都不变\n\n```java\npublic class Demo13Predicate_or {\n\t//定义一个方法，方法的参数，传递一个字符串，传递两个Predicate接口\n\t//一个判断字符串的长度是否大于5\n\t//一个判断字符串是否包含a\n\t//两个条件满足一个即可\n\tpublic static boolean checkString(String s,Predicate<String> pre1,Predicate<String> pre2) {\n//\t\treturn pre1.test(s)||pre2.test(s);//这是常规写法\n\t\treturn pre1.or(pre2).test(s);\n\t}\n\tpublic static void main(String[] args) {\n\t\t//定义一个字符串\n\t\tString s=\"abcdef\";\n\t\t//调用checkString方法，参数传递字符串和两个Lambda表达式\n\t\tboolean b=checkString(s,(t)->{\n\t\t\treturn t.length()>5;\n\t\t},(t)->{\n\t\t\treturn t.contains(\"a\");\n\t\t});\n\t\tSystem.out.println(b);\n\t}\n}\n\n```\n\n### 默认方法：negate\n\n\"与\"、\"或\"已经了解了，剩下的\"非\"（取反）也会简单。默认方法negate的jdk源码\n\n```java\n default Predicate<T> negate() {\n        return (t) -> !test(t);\n    }\n```\n\n从实现中很容易看出，它是执行了test方法之后，对结果Boolean值进行\"!\"取反而已。一定要在test方法调用之前调用negate方法，正如and和or方法一样\n\n```java\n/*\n * 需求：判断一个字符串长度是否大于5\n * 如果长度大于5，那么返回false，如果字符串的长度不大于5，那么返回true\n * 所以，我们可以使用取反符号，对判断的结果进行取反\n */\npublic class Demo14Predicate_negate {\n\tpublic static boolean checkString(String s,Predicate<String> pre) {\n//\t\treturn !pre.test(s);\n\t\treturn pre.negate().test(s);\n\t}\n\tpublic static void main(String[] args) {\n\t\tString s=\"abcdef\";\n\t\tboolean bool=checkString(s,(t)->{\n\t\t\treturn t.length()>5;\n\t\t});\n\t\tSystem.out.println(bool);\n\t}\n}\n\n```\n\n\n\n## 3.6 练习：集合信息筛选\n\n### 题目\n\n数组当中有多条\"姓名+性别\"的信息如下，请通过Predicate接口的拼装将符合要求的字符串筛选到集合ArrayList中，需要同时满足两个条件：\n\n1. 必须为女生\n2. 姓名为4个子\n\n```java\nString[] array={\n    \"迪丽热巴，女\",\"马尔扎哈，男\",\"古力娜扎，女\",\"任盈盈，女\"\n};\n```\n\n### 解答\n\n```java\npublic class Demo15Predicate {\n\tpublic static ArrayList<String> filter(String[] array,Predicate<String> pre1,Predicate<String> pre2) {\n\t\tArrayList<String> list=new ArrayList<String>();\n\t\tfor(String s:array) {\n\t\t\tboolean b=pre1.and(pre2).test(s);\n\t\t\tif(b)\n\t\t\t\tlist.add(s);\n\t\t}\n\t\treturn list;\n\t}\n\tpublic static void main(String[] args) {\n\t\tString[] array= {\n\t\t\t\t\"迪丽热巴，女\",\"马尔扎哈，男\",\"任盈盈，女\",\"古力娜扎，女\"\n\t\t};\n\t\tArrayList<String> list=filter(array, (s)->{\n\t\t\treturn s.split(\"，\")[0].length()==4;\n\t\t}, (s)->{\n\t\t\treturn s.split(\"，\")[1].equals(\"女\");\n\t\t});\n\t\tSystem.out.println(list.toString());\n\t}\n}\n```\n\n\n\n## 3.7 Function接口\n\n`java.util.function.Function<T,R>`接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件\n\n### 抽象方法：apply\n\n`Function`接口中最主要的抽象方法为：`R apply(T t)`，根据类型T的参数获取类型R的结果。\n\n使用的场景例如：将`String`类型转换为`Integer`类型\n\n```java\npublic class Demo16Function {\n\t/*\n\t * 定义一个方法\n\t * 方法的参数传递一个字符串类型的整数\n\t * 方法的参数传递一个Function接口，泛型使用<String,Integer>\n\t * 使用Function接口中的方法apply，把字符串类型的整数，转换为Integer类型的整数\n\t * \n\t */\n\tpublic static void change(String s,Function<String, Integer> func) {\n//\t\tInteger in=func.apply(s);\n\t\tint in=func.apply(s);//自动拆箱\n\t\tSystem.out.println(in);\n\t}\n\tpublic static void main(String[] args) {\n\t\t//定义一个字符串类型的整数\n\t\tString s=\"1234\";\n\t\t//调用change方法，传递字符串类型的整数，和Lambda表达式\n//\t\tchange(s, (t)->{\n//\t\t\treturn Integer.parseInt(t);\n//\t\t});\n\t\t\n\t\t//优化\n\t\tchange(s,t->Integer.parseInt(t));\n\t}\n}\n```\n\n当然最好是通过方法引用的写法\n\n### 默认方法：andThen\n\nFunction接口中有一个默认的andThen方法，用来进行组合操作，jdk源码如\n\n```java\ndefault <V> Function<T, V> andThen(Function<? super R, ? extends V> after) {\n        Objects.requireNonNull(after);\n        return (T t) -> after.apply(apply(t));\n}\n```\n\n该方法同样用于\"先做什么，再做什么\"的场景，和Consumer中的andThen差不多\n\n```java\npublic class Demo17Function_andThen {\n\tpublic static String change(String s,Function<String, Integer> func1,Function<Integer, String> func2) {\n//\t\tint n=func1.apply(s);\n//\t\treturn func2.apply(n);\n\t\t//func1先调用apply方法，把字符串转换为Integer，func2调用apply方法，把Integer转换为字符串\n\t\treturn func1.andThen(func2).apply(s);\n\t}\n\tpublic static void main(String[] args) {\n\t\tString s=\"10\";\n//\t\tSystem.out.println(change(s,(t)->{\n//\t\t\treturn Integer.parseInt(s)+10;\n//\t\t},(t)->{\n//\t\t\treturn t.toString();\n//\t\t}));\n\t\t\n\t\t//优化Lambda\n\t\tSystem.out.println(change(s,t->Integer.parseInt(s)+10,t->t.toString()));\n\t}\n}\n\n```\n\n第一个操作是将字符串解析成为int数字后加10，第二个操作是将int转为字符串。两个操作通过andThen按照前后顺序组合到了一起\n\n> 注意：Function的前置条件泛型和后置条件泛型可以相同\n\n## 3.8 练习：自定义函数模型拼接\n\n### 题目\n\n请使用Function进行函数模型的拼接，按照顺序需要执行的多个函数操作为：\n\n```java\nString s=\"任盈盈，18\";\n```\n\n1. 将字符串截取数字年龄部分，得到字符串\n2. 将上一步的字符串转换成int类型的数字\n3. 将上一步的int数字累加100,得到结果int数字\n\n### 解答\n\n```java\n/*\n * 1. 将字符串截取数字年龄部分，得到字符串\n *   Function<String,String> \"任盈盈，18\"->\"18\"\n * 2. 将上一步的字符串转换成int类型的数字\n *   Function<String,Integer> \"18\"->18\n * 3. 将上一步的int数字累加100,得到结果int数字\n *   Function<Integer,Integer> 18->118\n */\npublic class Demo18Practice {\n\tpublic static void main(String[] args) {\n\t\tString s=\"任盈盈，18\";\n\t\tSystem.out.println(change(s,t->t.split(\"，\")[1],t->Integer.parseInt(t),t->t+100));\n\t}\n\tpublic static int change(String s,Function<String, String> func1,Function<String, Integer> func2,Function<Integer, Integer> func3) {\n\t\treturn func1.andThen(func2).andThen(func3).apply(s);\n\t}\n}\n```\n\n","tags":["java"]},{"title":"Filter和Listener","url":"/blog/2020/filter-and-listener/","content":"\n今天整下，javaweb的三大核心组件中的两个，Filter和Listener\n\n<!--more-->\n\njavaweb三大组件，Servlet、Filter和Listener。这三者都需要配置，都可以通过web.xml或者注解来配置\n\n# 一、Filter过滤器\n\n## 1.1 概念\n\n生活中的过滤器：如净水器、空气净化器，打劫。\n\nweb中的过滤器：在浏览器到服务器的请求之间，或者服务器对浏览器的响应之间，进行拦截，以此来完成特殊的功能。\n\n过滤器的作用：一般用于完成通过的操作。如登录验证、统一编码处理、敏感字符过滤\n\n## 1.2 快速入门\n\n步骤：\n\n1. 定义一个类，实现Filter接口\n2. 重写方法\n3. 配置拦截路径\n\n两种配置方式：\n\n1. web.xml配置（参照1.3）\n2. 注解配置（下面使用的就是注解配置）\n\n> 在过滤器中，要考虑是否放行，如果不放行，访问的资源内容就不会被加载\n>\n> 放行执行的代码filterChain.doFilter(servletRequest, servletResponse); 将request跟response传进去。\n\njsp\n\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>Title</title>\n</head>\n<body>\n测试过滤器..\n</body>\n</html>\n```\n\njava\n\n```java\n/**\n * 过滤器快速入门\n */\n/*\n/* 表示访问所有资源之前，都会执行该过滤器\n/index.jsp 表示访问index.jsp之前，执行该过滤器\n */\n@WebFilter(\"/*\")\npublic class Demo01Filter implements Filter {\n\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        System.out.println(\"filter被执行了...\");\n\n        //考虑是否放行，如果不放行，访问的资源内容就不会被加载\n        //下面进行放行\n        filterChain.doFilter(servletRequest, servletResponse);\n    }\n\n    @Override\n    public void destroy() {\n\n    }\n}\n```\n\n## 1.3 过滤器细节\n\n### web.xml配置\n\n此处带有之前的servlet的配置，我就不删掉了。为了方便阅读，删掉其实比较好。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n    <!--配置Servlet-->\n    <servlet>\n        <servlet-name>demo01</servlet-name>\n        <servlet-class>demo01_servlet.Demo01Servlet</servlet-class>\n    </servlet>\n    <!--Servlet映射-->\n    <servlet-mapping>\n        <servlet-name>demo01</servlet-name>\n        <url-pattern>/demo01</url-pattern>\n    </servlet-mapping>\n\n    <!--配置Servlet-->\n    <servlet>\n        <servlet-name>demo02</servlet-name>\n        <servlet-class>demo01_servlet.Demo02Servlet</servlet-class>\n        <!--指定Servlet的创建时机\n        1. 第一次被访问时，创建。<load-on-startup>为负数，一般为-1\n        2. 在服务器启动时，创建。<load-on-startup>为0或正整数，一般为0-10\n        -->\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n    <!--Servlet映射-->\n    <servlet-mapping>\n        <servlet-name>demo02</servlet-name>\n        <url-pattern>/demo02</url-pattern>\n    </servlet-mapping>\n\n    <!--配置Filter-->\n    <filter>\n        <filter-name>filter01</filter-name>\n        <filter-class>demo10_filter.Demo02Filter</filter-class>\n    </filter>\n    <filter-mapping>\n        <filter-name>filter01</filter-name>\n        <!-- 拦截路径， /* 表示，访问所有资源都要经过过滤器 -->\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n</web-app>\n```\n\n### 过滤器执行流程\n\n如果去了解整个底层工作原理，会发现，本质就是一个方法的顺序执行。\n\n1. 执行过滤器\n2. 放行\n3. 执行放行后的资源\n4. 回来执行过滤器\n\njava\n\n```java\n@WebFilter(\"/*\")\npublic class Demo03Filter implements Filter {\n    public void destroy() {\n    }\n\n    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {\n        //在放行之前，可以对request消息对象进行增强\n        System.out.println(\"filter03执行..\");\n\n        chain.doFilter(req, resp);\n\n        //在放行之后，可以对response消息对象进行增强\n        System.out.println(\"filter03回来了..\");\n    }\n\n    public void init(FilterConfig config) throws ServletException {\n\n    }\n\n}\n```\n\njsp\n\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>Title</title>\n</head>\n<body>\n测试过滤器..\n<%\n    System.out.println(\"访问到index.jsp\");\n%>\n</body>\n</html>\n```\n\n{% asset_img 1.png %}\n\n### 过滤器生命周期方法\n\n1. init：在服务器启动后，就会创建Filter对象，然后调用init方法，只执行一次。用于加载资源。\n   * Servlet中默认是Servlet第一次被访问创建时，仅执行一次。此时Filter的init会比Servlet的先执行\n   * Servlet也可以配置在启动服务器即执行，一般用于加载资源。经过测试，此时也仍然是Filter的init先执行\n2. doFilter：每一次请求，被拦截资源时执行。具体的拦截操作逻辑，放在这里\n3. destroy：在服务器正常关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次，用于释放资源\n\n### 过滤器配置详解\n\n1. 拦截路径配置\n\n   * 具体的资源路径：/index.jsp，只有访问index.jsp资源时，过滤器才会被执行。不过这种情况一般比较少，因为过滤器通常是用来拦截通用操作的。比方说，登录验证、敏感词过滤、统一编码\n   * 目录拦截：/user/*，访问/user下的所有资源时，过滤器都会被执行\n   * 后缀名拦截：*.jsp，访问所有后缀名为jsp资源时，过滤器都会被执行\n   * 拦截所有资源：/*，访问所有资源时，过滤器都会被执行\n\n2. 拦截方式配置：资源被访问的方式\n\n   * 注解配置：设置dispatcherTypes属性\n\n     * REQUEST：默认值。浏览器直接请求资源\n\n     * FORWARD：转发访问资源\n     * INCLUDE：包含访问资源\n     * ASYNC：异步访问资源\n     * ERROR：错误跳转资源\n\n   * web.xml配置：在filter-mapping下配置`<dispatcher>REQUEST</dispatcher>`，取值也是上面5个\n\n```java\n//浏览器请求资源时，该过滤器会被执行\n//@WebFilter(value=\"/filter/index.jsp\",dispatcherTypes = DispatcherType.REQUEST)\n//浏览器转发资源时，该过滤器会被执行\n//@WebFilter(value=\"/filter/index.jsp\",dispatcherTypes = DispatcherType.FORWARD)\n\n//浏览器请求资源或者转发资源时，该过滤器会被执行\n@WebFilter(value=\"/filter/index.jsp\",dispatcherTypes = {DispatcherType.FORWARD,DispatcherType.REQUEST})\npublic class Demo05Filter implements Filter {\n    public void destroy() {\n    }\n\n    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {\n        System.out.println(\"filter05..\");\n        chain.doFilter(req, resp);\n    }\n\n    public void init(FilterConfig config) throws ServletException {\n\n    }\n\n}\n```\n\n\n\n### 过滤器链（配置多个过滤器）\n\n#### 执行顺序\n\n执行顺序：如果有两个过滤器，分别为过滤器1和过滤器2\n\n1. 过滤器1\n2. 过滤器2\n3. 资源执行\n4. 过滤器2\n5. 过滤器1\n\n{% asset_img 2.png %}\n\n#### 过滤器先后顺序\n\n注解配置：按照类型的字符串比较规则，值小的先执行。\n\n* 如AFilter和BFilter，A小，故A先执行；Demo6和Demo17比较，Demo17先执行\n\nweb.xml配置：`<filter-mapping>`哪个定义在上边，哪个先执行\n\n## 1.4 过滤器案例\n\n## 登录验证\n\n### 需求分析\n\n需求：\n\n1. 如果登录，则放行\n2. 如果没有登录，则跳转登录页\n\n分析：\n\n1. 判断是否是登录相关资源。如果不排除登录资源，会陷入死循环。\n   * 是，放行\n   * 否，验证是否登录\n2. 判断是否登录\n   * 是，放行\n   * 否，返回登录页\n\n### 代码实现\n\nLoginFilter.java\n\n```java\n/**\n * 登录验证过滤器\n */\n@WebFilter(\"/filter/*\")\npublic class LoginFilter implements Filter {\n    public void destroy() {\n    }\n\n    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {\n        //强制转换，不然没法使用其子类方法\n        HttpServletRequest request= (HttpServletRequest) req;\n\n        //1.获取资源请求路径\n        String requestURI = request.getRequestURI();\n        //2.判断是否包含登录相关的资源\n        if (requestURI.contains(\"/filter/login.jsp\") || requestURI.contains(\"/filter/loginServlet\")||requestURI.contains(\"/filter/checkCodeServlet\")||requestURI.contains(\"/css/\")||requestURI.contains(\"/js/\")) {\n            //放行\n            System.out.println(\"登录资源，放行\");\n            chain.doFilter(req,resp);\n        }else{\n            //验证是否登录\n            HttpSession session = request.getSession();\n            if(session.getAttribute(\"user\")!=null){\n                System.out.println(\"已登录，放行\");\n                chain.doFilter(req,resp);\n            }else{\n                request.setAttribute(\"login_error\",\"您尚未登录\");\n                request.getRequestDispatcher(\"login.jsp\").forward(request,resp);\n            }\n        }\n\n    }\n\n    public void init(FilterConfig config) throws ServletException {\n\n    }\n\n}\n```\n\nLoginServlet.java\n\n```java\n@WebServlet(\"/filter/loginServlet\")\npublic class LoginServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n//        1. 设置request编码\n        request.setCharacterEncoding(\"utf-8\");\n        HttpSession session = request.getSession();\n//        2. 获取参数Map集合\n//        Map<String, String[]> map = request.getParameterMap();\n        String username = request.getParameter(\"username\");\n        String password = request.getParameter(\"password\");\n        String checkcode = request.getParameter(\"checkcode\");\n//        3. 获取验证码\n        String code = (String)session.getAttribute(\"checkcode\");\n        //这是为了使验证码保持一次性使用\n        session.removeAttribute(\"checkcode\");\n        //忽略大小写\n        if(code!=null&&code.equalsIgnoreCase(checkcode)){\n            if(\"胡列娜\".equals(username)&&\"fairy\".equals(password)){\n                //存储信息\n                session.setAttribute(\"user\",username);\n                //重定向\n                response.sendRedirect(\"/filter/success.jsp\");\n            }else{\n                //存储信息\n                request.setAttribute(\"login_error\",\"用户名或者密码错误\");\n                //转发\n                request.getRequestDispatcher(\"/filter/login.jsp\").forward(request,response);\n            }\n        }else{\n            //存储信息\n            request.setAttribute(\"cc_error\",\"验证码错误\");\n            //转发\n            request.getRequestDispatcher(\"/filter/login.jsp\").forward(request,response);\n        }\n//        4. 将用户信息封装到User对象\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n}\n```\n\nCheckCodeServlet.java\n\n```java\n@WebServlet(\"/filter/checkCodeServlet\")\npublic class CheckCodeServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        int width=100;\n        int height=30;\n\n        //1.创建对象，在内存中画图（验证码图片对象）\n        BufferedImage image=new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);\n        //2.美化图片\n        //2.1填充背景色\n        Graphics g=image.getGraphics();//绘图对象\n        g.setColor(new Color(255,255,255,255));\n        g.fillRect(0,0,width,height);\n        //2.2画边框\n        g.setColor(Color.RED);\n        g.drawRect(0,0,width-1,height-1);\n        //2.3写验证码\n        String str=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz\";\n        Random r=new Random();\n        //StringBuilder在处理多个字符串拼接的时候，效率要比+拼接要高很多。\n        StringBuilder stringBuilder = new StringBuilder();\n        for (int i = 0; i < 4; i++) {\n            //设置字体,绘制字符\n            g.setFont(new Font(Font.SANS_SERIF,Font.BOLD,20));\n            char c = str.charAt(r.nextInt(str.length()));\n            stringBuilder.append(c);\n            g.drawString(String.valueOf(c),width/5*(i+1),height/2+10);\n        }\n        //将验证码存入session\n        String checkcode=stringBuilder.toString();\n        request.getSession().setAttribute(\"checkcode\",checkcode);\n        //2.4 画干扰线\n        g.setColor(Color.green);\n        for (int i = 0; i < 10; i++) {\n            int x1=r.nextInt(width);\n            int y1=r.nextInt(height);\n            int x2=r.nextInt(width);\n            int y2=r.nextInt(height);\n            g.drawLine(x1,y1,x2,y2);//画线\n            //画点\n//            g.drawOval(x1,y1,5,5);\n//            g.fillOval(x1,y1,5,5);\n//            g.drawOval(x2,y2,5,5);\n//            g.fillOval(x2,y2,5,5);\n        }\n        //3.将图片输出到页面展示\n        ImageIO.write(image,\"jpg\",response.getOutputStream());\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request,response);\n    }\n}\n```\n\nlogin.jsp\n\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>登录</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n        }\n\n        .box {\n            background-color: #74C3B5;\n            color: #fff;\n            width:100vw;\n            height:100vh;\n            position:fixed;\n        }\n        .container {\n            width: 600px;\n            margin: 80px auto;\n            text-align: center;\n        }\n\n        .logo {\n            width: 250px;\n            height: 70px;\n            margin: auto;\n            border-radius: 5px;\n            margin-bottom: 40px;\n            font-size:44px;\n        }\n\n\n        input {\n            color: #fff;\n            width: 250px;\n            height: 40px;\n            /*opacity:.5;*/\n            transition: all ease .4s;\n            background-color: rgba(255, 255, 255, .2);\n            text-align: center;\n            font-size: 20px;\n            border: 2px solid rgba(255, 255, 255, .4);\n            outline: none;\n            border-radius: 5px;\n        }\n        img {\n            outline: 0;\n            border: 1px solid rgba(255, 255, 255, 0.4);\n            background-color: rgba(255, 255, 255, 0.2);\n            width: 250px;\n            height: 70px;\n            border-radius: 3px;\n            padding: 5px 8px;\n            margin: 0 auto 5px auto;\n            display: block;\n            text-align: center;\n            color: white;\n            opacity: .9;\n            box-sizing: border-box;\n        }\n\n        input:focus {\n            color: #75DFB7;\n            width: 300px;\n            background-color: #fff;\n        }\n\n        button {\n            width: 250px;\n            height: 40px;\n            border: none;\n            background-color: rgba(255, 255, 255, .9);\n            font-size: 20px;\n            color: #75DFB7;\n            cursor: pointer;\n            border-radius: 5px;\n        }\n\n        ul {\n            list-style: none;\n        }\n\n        li {\n            line-height: 50px;\n        }\n\n        form a {\n            text-decoration: none;\n            color: #fff;\n        }\n\n        input::placeholder {\n            color:#fff;\n        }\n        .bg-bubbles {\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            z-index: 1;\n            pointer-events: none;\n        }\n        .bg-bubbles li {\n            position: absolute;\n            list-style: none;\n            display: block;\n            width: 40px;\n            height: 40px;\n            background-color: rgba(255, 255, 255, 0.15);\n            bottom: -160px;\n            -webkit-animation: square 25s infinite;\n            animation: square 25s infinite;\n            -webkit-transition-timing-function: linear;\n            transition-timing-function: linear;\n        }\n        .bg-bubbles li:nth-child(1) {\n            left: 10%;\n        }\n        .bg-bubbles li:nth-child(2) {\n            left: 20%;\n            width: 80px;\n            height: 80px;\n            -webkit-animation-delay: 2s;\n            animation-delay: 2s;\n            -webkit-animation-duration: 17s;\n            animation-duration: 17s;\n        }\n        .bg-bubbles li:nth-child(3) {\n            left: 25%;\n            -webkit-animation-delay: 4s;\n            animation-delay: 4s;\n        }\n        .bg-bubbles li:nth-child(4) {\n            left: 40%;\n            width: 60px;\n            height: 60px;\n            -webkit-animation-duration: 22s;\n            animation-duration: 22s;\n            background-color: rgba(255, 255, 255, 0.25);\n        }\n        .bg-bubbles li:nth-child(5) {\n            left: 70%;\n        }\n        .bg-bubbles li:nth-child(6) {\n            left: 80%;\n            width: 120px;\n            height: 120px;\n            -webkit-animation-delay: 3s;\n            animation-delay: 3s;\n            background-color: rgba(255, 255, 255, 0.2);\n        }\n        .bg-bubbles li:nth-child(7) {\n            left: 32%;\n            width: 160px;\n            height: 160px;\n            -webkit-animation-delay: 7s;\n            animation-delay: 7s;\n        }\n        .bg-bubbles li:nth-child(8) {\n            left: 55%;\n            width: 20px;\n            height: 20px;\n            -webkit-animation-delay: 15s;\n            animation-delay: 15s;\n            -webkit-animation-duration: 40s;\n            animation-duration: 40s;\n        }\n        .bg-bubbles li:nth-child(9) {\n            left: 25%;\n            width: 10px;\n            height: 10px;\n            -webkit-animation-delay: 2s;\n            animation-delay: 2s;\n            -webkit-animation-duration: 40s;\n            animation-duration: 40s;\n            background-color: rgba(255, 255, 255, 0.3);\n        }\n        .bg-bubbles li:nth-child(10) {\n            left: 90%;\n            width: 160px;\n            height: 160px;\n            -webkit-animation-delay: 11s;\n            animation-delay: 11s;\n        }\n        @-webkit-keyframes square {\n            0% {\n                -webkit-transform: translateY(0);\n                transform: translateY(0);\n            }\n            100% {\n                -webkit-transform: translateY(-700px) rotate(600deg);\n                transform: translateY(-700px) rotate(600deg);\n            }\n        }\n        @keyframes square {\n            0% {\n                -webkit-transform: translateY(0);\n                transform: translateY(0);\n            }\n            100% {\n                -webkit-transform: translateY(-700px) rotate(600deg);\n                transform: translateY(-700px) rotate(600deg);\n            }\n        }\n        error {\n            color:deeppink;\n        }\n    </style>\n</head>\n<body>\n<%\n    String login_error = (String) request.getAttribute(\"login_error\");\n    String cc_error = (String) request.getAttribute(\"cc_error\");\n%>\n<div class=\"box\">\n    <div class=\"container\">\n        <div class=\"logo\">\n            住房公积金\n        </div>\n        <%\n            if(login_error!=null){\n                out.write(\"<error>\"+login_error+\"</error>\");\n            }\n            if(cc_error!=null){\n                out.write(\"<error>\"+cc_error+\"</error>\");\n            }\n        %>\n        <form action=\"/filter/loginServlet\" method=\"post\">\n            <ul>\n                <li><input type=\"text\" name=\"username\" placeholder=\"用户名\" autocomplete=\"off\"></li>\n                <li><input type=\"text\" name=\"password\" placeholder=\"密码\" autocomplete=\"off\"></li>\n                <li><input type=\"text\" name=\"checkcode\" placeholder=\"不区分大小写\"></li>\n                <li><img id=\"checkcode\" src=\"/filter/checkCodeServlet\" alt=\"\"></li>\n                <li>\n                    <button>登录</button>\n                </li>\n            </ul>\n        </form>\n    </div>\n    <ul class=\"bg-bubbles\">\n        <li></li>\n        <li></li>\n        <li></li>\n        <li></li>\n        <li></li>\n        <li></li>\n        <li></li>\n        <li></li>\n        <li></li>\n        <li></li>\n    </ul>\n</div>\n<script>\n    document.querySelector(\"#checkcode\").onclick=function (){\n        let url = \"/filter/checkCodeServlet\";\n        let date=new Date().getTime();\n        this.setAttribute(\"src\", url+\"?\"+date)\n    }\n</script>\n</body>\n</html>\n```\n\nsuccess.jsp\n\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>主页</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n        }\n\n        .box {\n            background-color: #74C3B5;\n            color: #fff;\n            width: 100vw;\n            height: 100vh;\n            position: fixed;\n        }\n    </style>\n</head>\n<body>\n<div class=\"box\">\n    <%\n        String user = (String) request.getSession().getAttribute(\"user\");\n        out.write(user+\"欢迎你\");\n\n    %>\n</div>\n</body>\n</html>\n\n```\n\n> 注意事项：\n>\n> 应当注意，像login.jsp，LoginServlet.java，CheckCodeServlet.java，css，js这些都属于登录资源，访问这些的时候，直接放行。\n\n## 敏感词过滤验证\n\n### 需求分析\n\n需求：表单中含有`胡列娜`或者`江厌离`或者`邱若水`就自动转为`***`\n\n分析：在过滤器中，对request传过来的内容进行修改，将修改内容后的request进行放行（request中并没有setParameter这个方法）\n\n解决方法：\n\n1. 对request对象的getParameter方法进行增强（通过getParameter获取到的内容就是已经过滤的了）。产生一个新的request对象\n2. 放行。将新的request对象传入\n\n重点分析：如何对geParameter方法进行增强？\n\n增强对象的功能的途径：\n\n* 设计模式：一些通用的解决固定问题的方式，[参考](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)\n  * 装饰模式\n  * 代理模式\n    * 概念：真实对象（比如小米公司）、代理对象（比如小米旗舰店），代理模式（代理对象代替真实对象，达到增强真实对象的目的）\n    * 静态代理（有一个类文件描述代理模式）\n    * 动态代理（在内存中形成代理类）\n      * 实现步骤\n        * 代理对象和真实对象实现相同的接口\n        * 代理对象=Proxy.newProxyInstance()\n        * 使用代理对象调用方法\n        * 增强方法\n      * 增强方式\n        * 增强参数列表\n        * 增强返回值类型\n        * 增强方法体执行逻辑\n\n\n\n### 理解动态代理demo\n\n下面通过动态代理模拟一个现实生活中的例子，买电脑。\n\n{% asset_img 3.png %}\n\n接口SellComputer\n\n```java\npublic interface SellComputer {\n    public String sale(double money);\n\n    public void show();\n}\n```\n\n接口SellComputer的实现类\n\n```java\n/**\n * 真实类\n * @author https://github.com/meethigher\n */\npublic class Lenovo implements SellComputer {\n    @Override\n    public String sale(double money) {\n        System.out.println(\"花钱\"+money+\"买电脑\");\n        return \"联想电脑\";\n    }\n\n    @Override\n    public void show() {\n        System.out.println(\"展示电脑...\");\n    }\n}\n```\n\n动态代理增强对象\n\n```java\npublic class ProxyTest {\n    public static void main(String[] args) {\n        //1.创建真实对象\n        Lenovo lenovo = new Lenovo();\n\n\n        //2.调用方法\n        //但是我们不应该直接通过真实对象来处理，我们需要通过一个增强对象\n        //因为直接通过真实对象方法处理并不满足我们需求，就比方说request的getParameter实现敏感词过滤\n//        String sale = lenovo.sale(8000);//花钱8000买电脑\n//        System.out.println(sale);//联想电脑\n\n        //2.动态代理增强lenovo对象\n\n        /**\n         * 三个参数\n         * 1. 类加载器：真实对象.getClass().getClassLoader()\n         * 2. 接口数组：真实对象.getClass().getInterfaces()\n         * 3. 处理器：new InvocationHandler()，这个就是增强对象的核心方法\n         */\n        SellComputer proxy_lenovo = (SellComputer) Proxy.newProxyInstance(lenovo.getClass().getClassLoader(), lenovo.getClass().getInterfaces(), new InvocationHandler() {\n\n            /**\n             * 代理逻辑编写的方法：代理对象调用的所有方法，都会触发该方法执行\n             * @param proxy 代理对象，一般我们不会用\n             * @param method 代理对象调用的方法，被封装的对象\n             * @param args 代理对象调用方法时，传递的实际参数\n             * @return\n             * @throws Throwable\n             */\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                /**\n                 * 判断是否是sale方法\n                 * 若是，对其增强再返回\n                 * 若否，直接原样返回\n                 */\n                if(method.getName().equals(\"sale\")){\n                    //1.增强参数\n                    double money = (double)args[0];\n                    money=money*1.2;\n                    //使用真实对象调用该方法\n                    System.out.println(\"专车接你...\");\n                    System.out.println(\"免费送货...\");\n                    String obj = (String)method.invoke(lenovo, money);\n                    return obj+\"&&鼠标垫\";\n                }else{\n                    Object obj = method.invoke(lenovo, args);\n                    return obj;\n                }\n\n            }\n        });\n        String sale = proxy_lenovo.sale(8000);//专车接你...免费送货...花钱9600.0买电脑\n        System.out.println(\"买到了\"+sale);//买到了联想电脑&&鼠标垫\n        proxy_lenovo.show();//展示电脑...\n    }\n}\n```\n\n### 代码实现\n\nindex.jsp\n\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>Title</title>\n</head>\n<body>\n<form action=\"testServlet\" method=\"post\">\n    <textarea name=\"remark\"></textarea>\n    <input type=\"submit\" value=\"提交\">\n</form>\n</body>\n</html>\n```\n\nSensitiveFilter.java\n\n```java\n@WebFilter(\"/filter_proxy/*\")\npublic class SensitiveFilter implements Filter {\n    public void destroy() {\n    }\n\n    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {\n        //1.创建代理对象，增强getParameter方法\n        ServletRequest proxy_req = (ServletRequest)Proxy.newProxyInstance(req.getClass().getClassLoader(), req.getClass().getInterfaces(), new InvocationHandler() {\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                //判断getParameter,getParameterMap,getParameterValue\n                //此处指拿getParameter举个例子\n                if(method.getName().equals(\"getParameter\")){\n                    //增强返回值。先获取返回值，进行过滤，再返回\n//                    req.setCharacterEncoding(\"utf-8\");\n                    String value= (String)method.invoke(req, args);\n                    if(value!=null){\n                        for(String str:list){\n                            if(value.contains(str)){\n                                value=value.replaceAll(str,\"***\");\n                            }\n                        }\n                    }\n                    return value;\n                }else{\n                    return method.invoke(req,args);\n                }\n            }\n        });\n        //2.放行\n        chain.doFilter(proxy_req, resp);\n    }\n\n    private List<String> list=new ArrayList<String>();//敏感词汇集合\n    public void init(FilterConfig config) throws ServletException {\n        //加载配置文件\n        try {\n            //1.获取文件真实路径\n            ServletContext sc = config.getServletContext();\n            String realPath = sc.getRealPath(\"/WEB-INF/classes/sensitivewords.txt\");\n            //2.读取文件\n            BufferedReader br = new BufferedReader(new FileReader(realPath, StandardCharsets.UTF_8));\n            String line=null;\n            while((line=br.readLine())!=null){\n                list.add(line);\n            }\n            System.out.println(\"加载敏感词\");\n            br.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n}\n```\n\nTestServlet.java\n\n```java\n@WebServlet(\"/filter_proxy/testServlet\")\npublic class TestServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        request.setCharacterEncoding(\"utf-8\");\n        response.setContentType(\"text/html;charset=utf-8\");\n        String remark = request.getParameter(\"remark\");\n        response.getWriter().write(\"<h1>\"+remark+\"</h1>\");\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n}\n```\n\n{% asset_img 4.png %}\n\n# 二、Listener监听器\n\n## 2.1 概念\n\nweb的三大组件之一。\n\n事件监听机制\n\n* 事件：一件事情。比方说点击按钮\n* 事件源：事件发生的地方\n* 监听器：一段代码或者一个对象\n* 注册监听：将事件、事件源、监听器绑定在一起，当事件源上发生某个事件后，执行监听器代码\n\n## 2.2 ServletContextListener\n\n这是个接口，用来监听ServletContext对象的创建和销毁\n\n两个方法\n\n* void contextDestroyed(ServletContextEvent sce)：ServletConext对象被销毁之前，会调用该方法\n* void contextInitialized(ServletContextEvent sce)：ServletContext对象被创建之后，会调用该方法\n\n用途：一般用于全局资源文件的加载\n\n步骤\n\n1. 定义一个类，实现ServletContextListener接口\n2. 重写方法\n3. 配置\n   * web.xml配置\n   * 注解配置：直接在类上面添加`@WebListener`\n\nweb.xml\n\n```xml\n<!--配置监听器,此处可以通过@WebListener来代替-->\n<listener>\n    <listener-class>demo14_listener.ContextLoaderListener</listener-class>\n</listener>\n\n<!--指定要加载配置文件的初始化参数-->\n<context-param>\n    <param-name>contextConfigLocation</param-name>\n    <param-value>/WEB-INF/classes/applicationContext.xml</param-value>\n</context-param>\n```\n\ndemo演示\n\n```java\n@WebListener\npublic class ContextLoaderListener implements ServletContextListener {\n    /**\n     * 监听ServletContext对象创建的。ServletContext对象服务器启动后自动创建\n     * 在服务器启动后自动调用\n     * @param sce\n     */\n    @Override\n    public void contextInitialized(ServletContextEvent sce) {\n        //加载资源文件\n        //1.获取ServletContext对象\n        ServletContext servletContext = sce.getServletContext();\n        //2.加载资源文件\n        String contextConfigLocation = servletContext.getInitParameter(\"contextConfigLocation\");\n        //3.获取真实路径\n        String realPath = servletContext.getRealPath(contextConfigLocation);\n        //4.加载进内存\n        try {\n            FileInputStream fis = new FileInputStream(realPath);\n            System.out.println(fis);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n\n\n        System.out.println(\"ServletContext对象被创建了\");\n    }\n\n    /**\n     * 在服务器关闭后，ServletContext对象被销毁。\n     * 当服务器被正常关闭后，该方法被调用\n     * @param sce\n     */\n    @Override\n    public void contextDestroyed(ServletContextEvent sce) {\n        System.out.println(\"ServletContext对象被销毁了\");\n    }\n}\n```\n\n","tags":["web","jsp"]},{"title":"第一次拿省牌","url":"/blog/2020/game/","content":"\n王者荣耀，主玩的英雄打到了排名，记录一下。\n\n<!--more-->\n\n平时主玩韩信，孙策，狂铁，但是韩信分太高了，而且打野位巅峰赛一般拿不到，只能玩个对抗路。\n\n拿到了俩省牌子，5000多分，炫耀一下。\n\n{% asset_img 1.jpg 排名%}\n\n{% asset_img 2.jpg 选英雄 %}\n\n{% asset_img 3.jpg 胜利 %}\n\n{% asset_img 4.jpg 狂铁吊打老夫子 %}","tags":["game"]},{"title":"Git本地仓库入门教程","url":"/blog/2019/git-learn/","content":"\n使用本地仓库，对文件版本进行控制\n\n<!--more-->\n\n> 详细教程：参考[https://www.liaoxuefeng.com/wiki/896043488029600](https://www.liaoxuefeng.com/wiki/896043488029600)\n\n### \n\n#### 第一步 初始化本地仓库\n\n`git init`初始化一个本地仓库\n\n```\n$ git init\nInitialized empty Git repository in C:/Users/kitchen/Desktop/Theme/.git/\n```\n\n---\n\n\n\n#### 第二步 将文件添加到版本库\n\n1. `git add <filename>`将文件添加到版本库\n2. `git commit -m <message>`完成，<message>最好是写，而且是`英文`！\n\n```\n$ git add test.txt\n\n$ git status\nOn branch master\n\nNo commits yet\n\nChanges to be committed:\n  (use \"git rm --cached <file>...\" to unstage)\n\n        new file:   test.txt\n\n$ git commit -m \"first commit\"\n[master (root-commit) 42ce0e6] first commit\n 1 file changed, 1 insertion(+)\n create mode 100644 test.txt\n```\n\n---\n\n\n\n#### 第三步 随时掌握工作区状态\n\n如果修改了项目内容，可以通过`git status`来查看工作区的状态\n\n如果`git status` 告诉你文件被修改过，用过`git diff <filename>`可以查看修改内容\n\n```\n$ git status\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n        modified:   test.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n\n$ git diff test.txt\ndiff --git a/test.txt b/test.txt\nindex a1b78e2..aab983c 100644\n--- a/test.txt\n+++ b/test.txt\n@@ -1 +1,2 @@\n-first commit\n\\ No newline at end of file\n+first commit\n+second commit\n\\ No newline at end of file\n\n```\n\n---\n\n\n\n#### 第四步 版本回退\n\n可以通过`git log`查看***最近到远***的版本日志\n\n```\n$ git log\ncommit f6af78dc6dc5944e0e04df3ac46b83ecc667a3c4 (HEAD -> master)\nAuthor: meethigher <meethigher@qq.com>\nDate:   Thu Oct 3 18:18:28 2019 +0800\n\n    third commit\n\ncommit 535bf16545a58f9e8c6f9d29218e5c46befa9a67\nAuthor: meethigher <meethigher@qq.com>\nDate:   Thu Oct 3 18:17:25 2019 +0800\n\n    second commit\n\ncommit 5d8a7ff0c255d26df63e675393a85c756e4230ce\nAuthor: meethigher <meethigher@qq.com>\nDate:   Thu Oct 3 18:07:23 2019 +0800\n\n    first commit\n```\n\n如果想要只输出文件版本号<head>跟注释，可以通过`git log --pretty=oneline`查看\n\n```\n$ git log --pretty=oneline\nf6af78dc6dc5944e0e04df3ac46b83ecc667a3c4 (HEAD -> master) third commit\n535bf16545a58f9e8c6f9d29218e5c46befa9a67 second commit\n5d8a7ff0c255d26df63e675393a85c756e4230ce first commit\n```\n\n现在的位置是在third commit，如果想要回退到first commit，可以通过`git reset --hard <HEAD>`\n\n```\n$ git reset --hard 5d8a7ff0c255d26df63e675393a85c756e4230ce\nHEAD is now at 5d8a7ff first commit\n```\n\n可以看到现在已经回退到了first commit\n\n但是，此时如果再用`git log`会发现之后的最新的那几个版本已经看不到了！\n\n这就好比你从21世纪穿梭到19世纪，回不去了。\n\n解决办法：\n\n1. 命令行没有清空的情况下，可以找之前的版本号\n2. 命令行清空的情况下，可以通过`git reflog`来找版本号，`git reflog`用来记录你的每一次命令\n\n```\n$ git reflog\n5d8a7ff (HEAD -> master) HEAD@{0}: reset: moving to 5d8a7ff0c255d26df63e675393a85c756e4230ce\nf6af78d HEAD@{1}: commit: third commit\n535bf16 HEAD@{2}: commit: second commit\n5d8a7ff (HEAD -> master) HEAD@{3}: commit (initial): first commit\n```\n\n牛批，我又找到版本号了！\n\n### ","tags":["git"]},{"title":"逆向破解今日校园app加密值","url":"/blog/2020/hacker/","content":"\n我之前写的那个今日校园的签到脚本，是需要抓包的，昨天帮人部署的时候，我就看着那个加密值发呆...\n\n这个加密值我尝试多种方式，都获取不到，只有提交的时候，才能获取到，有点玄学啊...\n\n<!--more-->\n\n先给各位看张图（我在一个android学习群里见别人发的）。如果能有反思，那说明你是一个不会动脑的开发者；如果产生了共鸣，说明你是个会动脑的开发者；如果啥感觉也没有，那你可能就是个打酱油的。\n\n{% asset_img 1.png 如何问问题 %}\n\n写这篇文章的原因，也是因为我看网上这类教程的帖子很少，网上各式各样今日校园签到脚本已经遍地开花。但是他们没有过程，就直接模拟登录，提交，完成（一看就是抄的别人的东西）。对于加密值的加解密，他们的处理方法都是出自同一个大佬的代码，直接拿来就用的。\n\n很幸运，我找到了原大佬。大佬只留了一句话“加密值是逆向apk后得到的，本质上是一个json对象进行了des加密，然后编码为了Base64字符串”，\n\n我觉得一个牛逼的开发者，不需要别人给太多指点，只需一个思路，那就足够了。我希望我成为一个牛逼的开发者。\n\n这句话的关键词就是**逆向**，由此引发了我的一系列探索。诞生了这篇文章\n\n授人以鱼不如授人以渔，站在巨人的肩膀上，我将我自己整理的思路再分享给各位。\n\n# 正文\n\n我尝试各种方式获取加密值，包括登录时，发帖子时，私聊时，但是都没有那个加密值，只有在提交的时候，才有。\n\n我就有点纳闷了。\n\n## 反编译工具\n\n由此尝试反编译apk，今日校园新版提升了安全机制，并且被加固过了。所以需要找历史版本，就拿8.0.6来说吧，因为我用的这个。\n\n三个必备的工具\n\n1. [apktool](https://ibotpeaches.github.io/Apktool/)\n2. [dex2jar](https://github.com/pxb1988/dex2jar)\n3. [jd-gui](http://java-decompiler.github.io/)\n\n## 具体过程\n\n{% asset_img 2.png %}\n\n个人建议，三款工具，像我这样放置，会好一点\n\n### apktool\n\n具体使用过程，请参照[官方文档](https://ibotpeaches.github.io/Apktool/documentation/)\n\n首先找到你使用的app的apk文件，放置到该目录下，运行以下命令，进行decode\n\n```cmd\napktool.jar d name.apk\n```\n\n此时，会在目录下，生成相应的文件夹，里面的res是存放的资源文件和布局文件，但是你打开，可能会发现里面并没有我们要的classes.dex，而是一堆smali文件。\n\n所以，我们需要再build一下\n\n```cmd\napktool.jar b name\n```\n\n{% asset_img 3.png %}\n\n### dex2jar\n\n将我们需要进行反编译的.dex文件，移动到其根目录下，用以下命令重新打成jar包\n\n```cmd\nd2j-dex2jar.bat classes.dex\n```\n\n> 我个人理解\n>\n> dex2jar是将.dex转成.jar，jar2dex正好相反\n\n由此，我们会生成与.dex相对应的.jar，我已经将其剪切到桌面，为了方便处理\n\n{% asset_img 4.png %}\n\n### jd-gui\n\n打开这个图形界面工具，双击或者命令行输入\n\n```\njava -jar jd-gui.jar\n```\n\n依次打开指定的jar包，找你所需要的东西，我感觉这个过程应该是极费时间的。\n\n然后找到了8.0.6版的加密代码以及加密密钥\n\n{% asset_img 5.png %}\n\n从图片上，我们知道这是通过ate.V进行加密的，然后继续找。\n\n{% asset_img 6.png %}\n\n有了加密密钥，和加密的方式，接下来，我们就可以对其进行解密。\n\n# 致谢\n\n1. [逆向破解-APK反编译工具与使用](https://blog.csdn.net/qq_33608000/article/details/105372889)\n2. [ZimoLoveShuang](https://github.com/ZimoLoveShuang/auto-submit)\n3. [apk反编译](https://blog.csdn.net/android_LvQi/article/details/79030127)\n4. [今日校园自动签到](https://blog.suqir.xyz/2020/03/25/%E4%BB%8A%E6%97%A5%E6%A0%A1%E5%9B%AD%E8%87%AA%E5%8A%A8%E7%AD%BE%E5%88%B0/)\n\n通过这次亲自尝试反编译，让我更加确信，目前网络上遍地开花的那些代码，基本上都是围绕我致谢中的2和4这俩大佬展开的。这俩才是真大佬，我已经将他们博客收录到我[置顶文章](https://meethigher.top/blog/2020/blogs)里了\n\n为什么呢？\n\n因为每个版本的apk反编译之后，加密值都是不一样的，像我用的8.0.6版本的加密密钥就是XCE927==，而网上那成片成片的都是ST83=@XV。总不能每个人用的app都是同一个版本的吧，很明显，就是直接抄了别人的解密算法。\n\n总之，通过这次反编译，收获还是有的，有了值得我尊重的人，当然也有鄙视的人（大片大片的抄袭狗，尤其是那些，抄了别人代码，连个来源都不打的人）。","tags":["open","hacker","android"]},{"title":"HTML5","url":"/blog/2019/h5/","content":"\n有关html5的一系列新特性吧，这里没介绍canvas，有机会补上\n\n<!--more-->\n\n### H5-dom扩展\n\n\n##### 获取元素\n\n~~~javascript\ndocument.getElementsByClassName ('class'); \n//通过类名获取元素，以伪数组形式存在。\n\ndocument.querySelector('selector');\n//通过CSS选择器获取元素，符合匹配条件的第1个元素。\n\ndocument.querySelectorAll('selector'); \n//通过CSS选择器获取元素，以伪数组形式存在。\n~~~\n\n##### 类名操作\n\n~~~javascript\nNode.classList.add('class'); \n//添加class\n\nNode.classList.remove('class'); \n//移除class\n\nNode.classList.toggle('class'); \n//切换class，有则移除，无则添加\n\nNode.classList.contains('class'); \n//检测是否存在class\n~~~\n\n##### 自定义属性\n\n> 在HTML5中我们可以自定义属性，其格式如下data-*=\"\"\n\n~~~html\n\n<div id=\"demo\" data-my-name=\"itcast\" data-age=\"10\">\n<script>\n/*\n  Node.dataset是以对象形式存在的，当我们为同一个DOM节点指定了多个自定义属性时，\n  Node.dataset则存储了所有的自定义属性的值。\n  */\nvar demo = document.querySelector(反馈);\n//获取\n//注：当我们如下格式设置时，则需要以驼峰格式才能正确获取\nvar name = demo.dataset['myName'];\nvar age = demo.dataset['age'];\n//设置\ndemo.dataset['name'] = 'web developer';\n<script/>\n~~~\n\n\n### H5-新增API\n\n##### 全屏方法\n> HTML5规范允许用户自定义网页上任一元素全屏显示。\n\n- Node.requestFullScreen() 开启全屏显示\n- Node.cancelFullScreen() 关闭全屏显示\n- 由于其兼容性原因，不同浏览器需要添加前缀如：\n  webkit内核浏览器：webkitRequestFullScreen、webkitCancelFullScreen，如chrome浏览器。\n  Gecko内核浏览器：mozRequestFullScreen、mozCancelFullScreen，如火狐浏览器。\n- document.fullScreen检测当前是否处于全屏\n  不同浏览器需要添加前缀\n  document.webkitIsFullScreen、document.mozFullScreen\n\n##### 多媒体\n\n> 自定义播放器\n\n方法\n\n| 方法           | 描述                                    |\n| -------------- | --------------------------------------- |\n| addTextTrack() | 向音频/视频添加新的文本轨道             |\n| canPlayType()  | 检测浏览器是否能播放指定的音频/视频类型 |\n| load()         | 重新加载音频/视频元素                   |\n| play()         | 开始播放音频/视频                       |\n| pause()        | 暂停当前播放的音频/视频                 |\n\n\n属性\n\n\n| 属性                | 描述                                                       |\n| ------------------- | ---------------------------------------------------------- |\n| audioTracks         | 返回表示可用音轨的 AudioTrackList 对象                     |\n| autoplay            | 设置或返回是否在加载完成后随即播放音频/视频                |\n| buffered            | 返回表示音频/视频已缓冲部分的 TimeRanges 对象              |\n| controller          | 返回表示音频/视频当前媒体控制器的 MediaController 对象     |\n| controls            | 设置或返回音频/视频是否显示控件（比如播放/暂停等）         |\n| crossOrigin         | 设置或返回音频/视频的 CORS 设置                            |\n| currentSrc          | 返回当前音频/视频的 URL                                    |\n| currentTime         | 设置或返回音频/视频中的当前播放位置（以秒计）              |\n| defaultMuted        | 设置或返回音频/视频默认是否静音                            |\n| defaultPlaybackRate | 设置或返回音频/视频的默认播放速度                          |\n| duration            | 返回当前音频/视频的长度（以秒计）                          |\n| ended               | 返回音频/视频的播放是否已结束                              |\n| error               | 返回表示音频/视频错误状态的 MediaError 对象                |\n| loop                | 设置或返回音频/视频是否应在结束时重新播放                  |\n| mediaGroup          | 设置或返回音频/视频所属的组合（用于连接多个音频/视频元素） |\n| muted               | 设置或返回音频/视频是否静音                                |\n| networkState        | 返回音频/视频的当前网络状态                                |\n| paused              | 设置或返回音频/视频是否暂停                                |\n| playbackRate        | 设置或返回音频/视频播放的速度                              |\n| played              | 返回表示音频/视频已播放部分的 TimeRanges 对象              |\n| preload             | 设置或返回音频/视频是否应该在页面加载后进行加载            |\n| readyState          | 返回音频/视频当前的就绪状态                                |\n| seekable            | 返回表示音频/视频可寻址部分的 TimeRanges 对象              |\n| seeking             | 返回用户是否正在音频/视频中进行查找                        |\n| src                 | 设置或返回音频/视频元素的当前来源                          |\n| startDate           | 返回表示当前时间偏移的 Date 对象                           |\n| textTracks          | 返回表示可用文本轨道的 TextTrackList 对象                  |\n| videoTracks         | 返回表示可用视频轨道的 VideoTrackList 对象                 |\n| volume              | 设置或返回音频/视频的音量                                  |\n\n事件\n\n| 事件           | 描述                                         |\n| -------------- | -------------------------------------------- |\n| abort          | 当音频/视频的加载已放弃时                    |\n| canplay        | 当浏览器可以播放音频/视频时                  |\n| canplaythrough | 当浏览器可在不因缓冲而停顿的情况下进行播放时 |\n| durationchange | 当音频/视频的时长已更改时                    |\n| emptied        | 当目前的播放列表为空时                       |\n| ended          | 当目前的播放列表已结束时                     |\n| error          | 当在音频/视频加载期间发生错误时              |\n| loadeddata     | 当浏览器已加载音频/视频的当前帧时            |\n| loadedmetadata | 当浏览器已加载音频/视频的元数据时            |\n| loadstart      | 当浏览器开始查找音频/视频时                  |\n| pause          | 当音频/视频已暂停时                          |\n| play           | 当音频/视频已开始或不再暂停时                |\n| playing        | 当音频/视频在已因缓冲而暂停或停止后已就绪时  |\n| progress       | 当浏览器正在下载音频/视频时                  |\n| ratechange     | 当音频/视频的播放速度已更改时                |\n| seeked         | 当用户已移动/跳跃到音频/视频中的新位置时     |\n| seeking        | 当用户开始移动/跳跃到音频/视频中的新位置时   |\n| stalled        | 当浏览器尝试获取媒体数据，但数据不可用时     |\n| suspend        | 当浏览器刻意不获取媒体数据时                 |\n| timeupdate     | 当目前的播放位置已更改时                     |\n| volumechange   | 当音量已更改时                               |\n| waiting        | 当视频由于需要缓冲下一帧而停止               |\n\n##### 地理定位\n\n>在HTML规范中，增加了获取用户地理信息的API，\n>这样使得我们可以基于用户位置开发互联网应用，\n>即基于位置服务 (Location Base Service)\n\n- 获取当前地理信息\n~~~\nnavigator.geolocation.getCurrentPosition(successCallback, errorCallback) \n~~~\n- 重复获取当前地理信息\n~~~\nnavigator. geolocation.watchPosition(successCallback, errorCallback)\n~~~\n- 当成功获取地理信息后，会调用succssCallback，并返回一个包含位置信息的对象position。\n  position.coords.latitude纬度\n  position.coords.longitude经度\n  position.coords.accuracy精度\n  position.coords.altitude海拔高度\n- 当获取地理信息失败后，会调用errorCallback，并返回错误信息error\n- 在现实开发中，通过调用第三方API（如百度地图）来实现地理定位信息，这些API都是基于用户当前位置的，并将用位置位置（经/纬度）当做参数传递，就可以实现相应的功能。\n\n##### 本地存储\n\n>随着互联网的快速发展，基于网页的应用越来越普遍，\n>同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，\n>HTML5规范提出了相关解决方案。\n\n+ 特性\n    - 设置、读取方便\n    - 容量较大，sessionStorage约5M、localStorage约20M\n    - 只能存储字符串，可以将对象JSON.stringify() 编码后存储\n+ window.sessionStorage\n    - 生命周期为关闭浏览器窗口\n    - 在同一个窗口(页面)下数据可以共享\n+ window.localStorage\n    - 永久生效，除非手动删除（服务器方式访问然后清除缓存）\n    - 可以多窗口（页面）共享\n+ 方法\n    - setItem(key, value) 设置存储内容\n    - getItem(key) 读取存储内容\n    - removeItem(key) 删除键值为key的存储内容\n    - clear() 清空所有存储内容\n\n##### 历史管理\n>提供window.history，对象我们可以管理历史记录，\n>可用于单页面应用，Single Page Application，可以无刷新改变网页内容。\n\n- pushState(data, title, url) 追加一条历史记录  \n    + data用于存储自定义数据，通常设为null\n      + title网页标题，基本上没有被支持，一般设为空\n      + url 以当前域为基础增加一条历史记录，不可跨域设置\n- replaceState(data, title, url) 与pushState()基本相同，\n  不同之处在于replaceState()，只是替换当前url，不会增加/减少历史记录。\n- onpopstate事件，当前进或后退时则触发  \n\n##### 离线应用\n\n> HTML5中我们可以轻松的构建一个离线（无网络状态）应用，只需要创建一个cache manifest文件。\n\n+ 优势\n    - 1、可配置需要缓存的资源\n    - 2、网络无连接应用仍可用\n    - 3、本地读取缓存资源，提升访问速度，增强用户体验\n    - 4、减少请求，缓解服务器负担\n+ 缓存清单\n    - 一个普通文本文件，其中列出了浏览器应缓存以供离线访问的资源，推荐使用.appcache为后缀名\n    - 例如我们创建了一个名为demo.appcache的文件，然后在需要应用缓存在页面的根元素(html)添加属性manifest=\"demo.appcache\"，路径要保证正确。\n\n+ manifest文件格式\n    - 1、顶行写CACHE MANIFEST\n    - 2、CACHE: 换行 指定我们需要缓存的静态资源，如.css、image、js等\n    - 3、NETWORK: 换行 指定需要在线访问的资源，可使用通配符\n    - 4、FALLBACK: 换行 当被缓存的文件找不到时的备用资源\n\n+ 其它\n    - 1、CACHE: 可以省略，这种情况下将需要缓存的资源写在CACHE MANIFEST\n    - 2、可以指定多个CACHE: NETWORK: FALLBACK:，无顺序限制\n    - 3、#表示注释，只有当demo.appcache文件内容发生改变时或者手动清除缓存后，才会重新缓存。\n    - 4、chrome 可以通过chrome://appcache-internals/工具和离线（offline）模式来调试管理应用缓存\n\n##### 文件读取\n\n> HTML5新增内建对象，可以读取本地文件内容。\n\n##### 网络状态\n\n- 我们可以通过window.onLine来检测，用户当前的网络状况，返回一个布尔值\n    + window.online用户网络连接时被调用\n    + window.offline用户网络断开时被调用","tags":["web"]},{"title":"就从现在开始吧","url":"/blog/2019/hello-world/","content":"这是我的第一天博客，也是我第一次尝试自己搭建博客\n\n<!--more-->\n\n一开始，并没有写博客的习惯。\n\n这学期开学，软件工程老师，让我们写博客，慢慢地，发现挺有意思。\n\n每次接触到别人的博客，看到别人的一些开发历程，就会发现自己的不足。\n\n所以，就想把这个习惯坚持下去。\n\n然后，由此诞生了，现在这个网站。\n\n本主题已开源，并且已经被收录到了官方——[Starry](https://github.com/meethigher/hexo-theme-starry)。这算是我的第一个项目。\n\n之后，又开发出了[个人音乐网站](https://meethigher.top/music/)，已经开源——[music-player](https://github.com/meethigher/music-player)。\n\n感谢软件工程老师！","tags":["life"]},{"title":"开源住房公积金系统","url":"/blog/2020/house-fund/","content":"\n\n最近有个课程设计，做个住房公积金系统，从6月27号开始做，记录过程。\n\n<!--more-->\n\n手速太快，用idea的时候，经常会弹出全局搜索，很烦。\n\n[代码地址](https://github.com/meethigher/house-fund)\n\n`ctrl+shift+a`打开搜索框输入`registry`，点击进入之后，将`ide.suppress.double.click.handler`打上对号，表示禁用，`close`即可。\n\n说点题外话，跑步的时候，配周杰伦的《稻香》；写代码的时候，配罗志祥的《精舞门》，简直燃得不要不要的，踩点到极致。\n\n最近，也在回顾《极限挑战》，在节目中，罗志祥经常照顾张艺兴，还是很暖的。虽然罗志祥私生活确实不咋地，但是说实话，他这首精舞门真的很燃。我还是很欣赏他对音乐的态度的。\n\n# 一、27号进度\n\n登录功能\n\n* 账号密码报错提示\n* 验证码报错提示\n\n{% asset_img 1.png %}\n\n# 二、28号进度\n\n今天上午家里升级宽带，由50M网线升级成了100M光纤，一年360。交了13个月的，收了400，应该10块钱是安装费了。50M的时候，封顶能跑个2m/s，现在能跑个4m/s，用的铁通宽带，是真的有点垃圾。\n\n说说今天进度。\n\n1. 登录功能：\n   * 顶号处理（通过ServletContext设置username为键，sessionid为值，登录时，会自动更新，判断当前的username的sessionid是否与获取的一致。若一致，登录成功；否则，登录失败）\n2. 修改管理员密码功能：\n   * 修改结果提示\n\n通过jsp获取当前页面，来决定哪个标签是active\n\n总览页面\n\n{% asset_img 2.png %}\n\n单位页面\n\n{% asset_img 3.png %}\n\n# 三、29号进度\n\n完成功能：\n\n1. 优化登录验证码\n2. 单位开户页面：\n   * 类型输入框采用下拉菜单\n   * 部分输入限制，采用[js正则表达式](https://blog.csdn.net/sirobot/article/details/101030392)，注册按键松开事件，用正则替换掉不符要求的内容\n3. 单位开户\n\n{% asset_img 4.png %}\n\n# 四、30号没进度\n\n今天基本上没啥进度。\n\n上午上课，特么的，一上课就头疼，老师给我的感觉就是她自己都不会。我就纳闷了，现在的老师，是连备课的习惯都没有了吗？\n\n讲着讲着就卡壳了，我认为好的老师，至少带着学生完整的过一遍例子吧？她直接拿上节课的例子接着写，你知道那是啥样式吗？\n\n讲注解，所有的结果都运行在一个jsp页面上，密密麻麻的，服了。\n\n下午，整了整seo，我不知道为啥我这个这么难收录，26号提交的百度和谷歌，结果一个也没有收录，头疼。顺便又优化了一下网页的关键字跟描述。\n\n喂鸡喂鸭喂鹅，洗澡、洗衣服，打了一个小时游戏，看了一个小时极限挑战，已经晚上9点了。\n\n说实话，现在只要一上课我就很头疼，我自学，都能学得比老师讲得都明白。\n\n什么狗屁半吊子老师，讲啥讲不明白，写三行代码，找错误找10分钟，mmp的。你哪怕是课下备课，都不至于这样。\n\n我呢，也就是为了不挂科而已，不然，谁特么听这些人的破课？\n\n以后当个老师混日子也不错，一边混日子领工资，一边还能做自己感兴趣的事，啧啧...\n\n{% asset_img 5.png %}\n\n这是后人整合鲁迅的文章，改写的诗。“从你开始学习并改变身边的人”，从我开始改变这些混日子的老师？怎么改变，除非你给我个炮弹，我把这些混日子的老师都给轰了，杀鸡儆猴。\n\n现在上课有两种人，极好的学生，是不会听的，有的直接逃课；极差的学生，也是不会听的，也逃课。教师为了让自己的课不沦落到没人听的地步，点名，在的就给你成绩。这是不是违背了教学的初衷？\n\n<u>**一个好的老师，不应该强迫学生必须听你的课。你可以期中考试、期末考试，通过考试来决定学生成绩如何；而不是通过别人是否上你的课来给成绩。至于学生如何获取知识，你不需要管，因为你未必是个好老师，学生需要的是好老师。教学的初衷是为了让学生掌握更扎实的知识，有更强的能力，如果你不能给他们这些，请不要束缚他们选择老师的权利。如果说，职场是优胜劣汰，那么教师这个铁饭碗，好多人拿着不应得的薪水，有着普通人很努力也达不到的生活水准，这是不是太不公平了？**</u>。\n\n我的专业课老师，群里发上课了，结果我进去，尼玛的显示下课状态。他自己随机开课，也就是我想做个按时出勤的好学生得一直刷新才行。老子8点就到了，结果还要一直刷新等尼玛的到点上课？直接脚本处理。定时8点30进入课堂，自动监测签到。管尼玛的迟不迟到，反正也不听，布置的作业我都没做。\n\n我之前的数学老师，提前快1个小时，就把课堂打开，让学生进去，这是好老师。\n\n# 五、6号没进度\n\n七月一号到五号，在准备英语跟数学的期末考试，所以没有进度。\n\n从今天开始，全心全意好好整。\n\n此处应该画一道分割线。\n\n考完试了，也不着急去做实训，把我这小博客又优化了一下，添加了本地搜索内容加载动画。\n\n之后，又整了个每天定时刷步数能量的脚本，这样，一天就过去咯！\n\n# 六、7号进度\n\n完成功能：\n\n1. 个人开户：添加用户，需要更新单位表下的人数、单位月缴总额和个人月缴总额的数据。有两个思路\n   * 代码完成\n   * MySQL触发器\n\n{% asset_img 7.png %}\n\n我采用的MySQL触发器，[学习地址](https://www.cnblogs.com/phpper/p/7587031.html)\n\n```sql\ncreate trigger insert_trigger after insert on tb003 for EACH row\nbegin\nupdate tb002 as a join (select unitaccnum,sum(basenumber) sum from tb003 where peraccstate=0 GROUP BY unitaccnum) as b on a.unitaccnum=b.unitaccnum set a.basenumber=b.sum;\nupdate tb002 as a join (select unitaccnum,sum(unitmonpaysum) as sum from tb003 where peraccstate=0 GROUP BY unitaccnum) as b on a.unitaccnum=b.unitaccnum set a.unitpaysum=b.sum;\nupdate tb002 as a join (select unitaccnum,sum(permonpaysum) as sum from tb003 where peraccstate=0 GROUP BY unitaccnum) as b on a.unitaccnum=b.unitaccnum set a.perpaysum=b.sum;\nupdate tb002 as a join (select unitaccnum,count(accnum) as sum from tb003 where peraccstate=0 GROUP BY unitaccnum) as b on a.unitaccnum=b.unitaccnum set a.persnum=b.sum;\nend\n\ncreate trigger update_trigger after UPDATE on tb003 for EACH row\nbegin\nupdate tb002 as a join (select unitaccnum,sum(basenumber) sum from tb003 where peraccstate=0 GROUP BY unitaccnum) as b on a.unitaccnum=b.unitaccnum set a.basenumber=b.sum;\nupdate tb002 as a join (select unitaccnum,sum(unitmonpaysum) as sum from tb003 where peraccstate=0 GROUP BY unitaccnum) as b on a.unitaccnum=b.unitaccnum set a.unitpaysum=b.sum;\nupdate tb002 as a join (select unitaccnum,sum(permonpaysum) as sum from tb003 where peraccstate=0 GROUP BY unitaccnum) as b on a.unitaccnum=b.unitaccnum set a.perpaysum=b.sum;\nupdate tb002 as a join (select unitaccnum,count(accnum) as sum from tb003 where peraccstate=0 GROUP BY unitaccnum) as b on a.unitaccnum=b.unitaccnum set a.persnum=b.sum;\nend\n\ncreate trigger delete_trigger after DELETE on tb003 for EACH row\nbegin\nupdate tb002 as a join (select unitaccnum,sum(basenumber) sum from tb003 where peraccstate=0 GROUP BY unitaccnum) as b on a.unitaccnum=b.unitaccnum set a.basenumber=b.sum;\nupdate tb002 as a join (select unitaccnum,sum(unitmonpaysum) as sum from tb003 where peraccstate=0 GROUP BY unitaccnum) as b on a.unitaccnum=b.unitaccnum set a.unitpaysum=b.sum;\nupdate tb002 as a join (select unitaccnum,sum(permonpaysum) as sum from tb003 where peraccstate=0 GROUP BY unitaccnum) as b on a.unitaccnum=b.unitaccnum set a.perpaysum=b.sum;\nupdate tb002 as a join (select unitaccnum,count(accnum) as sum from tb003 where peraccstate=0 GROUP BY unitaccnum) as b on a.unitaccnum=b.unitaccnum set a.persnum=b.sum;\nend\n```\n\n# 七、8号进度\n\n完成功能：\n\n1. 单位修改\n2. 个人修改\n   * 反显数据\n   * 多表连接查询\n\n多表连接查询的时候，我直接懵了。\n\n需求是查个人数据的时候，需要将单位的数据一并反显出来。\n\n我一开始是想查询两次，封装成Javabean，存储session。但是太麻烦了，就百度了一下，[数据库采用多表连接查询，对应javaBean文件连接方式](https://www.cnblogs.com/chen-lhx/p/5002026.html)\n\n# 八、9号进度\n\n完成功能：\n\n1. 单位查询\n2. 个人查询\n3. 单位销户\n   * 若总人数>0，则不可销户\n4. 个人销户\n\n> 销户：并没有将数据删除，而是将状态码修改为销户，在查询修改的时候，只查询状态为正常的数据\n>\n> 在全部内容查询的时候，需要将数据查出来。\n>\n> 感受：触发器真好用！\n\n{% asset_img 10.png %}\n\n查询需要用到分页，思路就是，创建一个Page对象，里面存储当前页码，总页码，总条数，行数，以及存储bean对象的list集合\n\n```java\npublic class Page<T> {\n    private int totalCount;\n    private int totalPage;\n    private int currentPage;\n    private int rows;//每页显示记录数\n    private List<T> list;//每页的数据\n    \n    ...getter and setter...\n}\n```\n\n在jsp页面实现分页显示，类似于这样\n\n{% asset_img 8.png %}\n\n在jsp页面显示中，需要用到一个begin和end值，来求出其中的应该显示的条数。我在servlet中设置了这两个值\n\n```java\n//分页的开始跟结束\nint visibility = 4;//设置分页中间显示的个数，4就表示中间有5个\nint totalPage = personByPage.getTotalPage();\nint current = personByPage.getCurrentPage();\ncurrent = current > totalPage ? totalPage : current;\ncurrent = current < 1 ? 1 : current;\nint begin = current - visibility / 2;\nint end = current + visibility / 2;\n/**\n * 如果页数多于visibility，则按visibility正常显示\n * 如果页数少用visibility，则按实际情况展示\n */\nif (totalPage > visibility) {\n    begin = begin < 1 ? 1 : begin;\n    end = begin + visibility;\n    end = end > totalPage ? totalPage : end;\n    begin = end - visibility;\n} else {\n    begin = begin < 1 ? 1 : begin;\n    end = end > totalPage ? totalPage : end;\n}\n```\n\n然后，在jsp页面中，通过jstl来控制生成页数\n\n```jsp\n<ul class=\"pagination pagination-sm pull-right mt-3\">\n    <li><a href=\"findPersonByPage?currentPage=1\">首页</a></li>\n    <c:forEach begin=\"${requestScope.begin}\" end=\"${requestScope.end}\" step=\"1\" var=\"i\">\n        <li${requestScope.personByPage.currentPage==i?\" class=\\\"active\\\"\":\"\"}><a href=\"findPersonByPage?currentPage=${i}\">${i}</a></li>\n    </c:forEach>\n    <li><a href=\"findPersonByPage?currentPage=${requestScope.personByPage.totalPage}\">尾页</a></li>\n</ul>\n```\n\n本来还有几个功能，我看得很懵逼，问问老师，老师说不用实现了，那我就不客气了，下班，哈哈\n\n{% asset_img 9.png %}\n\n写完这些的时候，一看时间\n\n{% asset_img 6.png %}\n\n在使用过程中，还碰到了ssl的问题，解决方案[在这](https://blog.csdn.net/qq_38454176/article/details/104066348)","tags":["open","web","jsp"]},{"title":"hexo提交项目","url":"/blog/2019/hexo-submit/","content":"\n这几天碰到一个贼傻逼的情况。用了两天半的时间写完了主题，打算开源并且上传的时候，整了好几天。看了文档看得一脸懵逼，各种搜索资料以后，稍微明白了一点。\n\n<!--more-->\n\n先看[官方文档](https://hexo.io/zh-cn/docs/contributing.html#%E6%9B%B4%E6%96%B0%E6%96%87%E6%A1%A3)，是这样描述的。\n\n{% asset_img 工作流程.png 工作流程 %}\n\n# 1. Fork [hexojs/hexo](hexojs/hexo)\n\n当时整了一上午，没整明白。当时git clone下来之后，修改完了打算上传上去，发现一直提示没有权限。越想越想不通。然后下午就去忙别的事情了，当时随意看了一眼官方文档，发现，原来需要`fork`！`fork`理解为`分支`的意思吧\n\n{% asset_img fork.png fork %}\n\n然后再去自己的项目里，就会看到已经`fork`到自己的项目了。\n\n{% asset_img fork2.png fork %}\n\n# 2. 把库（respository）复制到电脑上，并安装所依赖的插件\n\n将你的`fork`的库下载到你的电脑上，并安装所依赖的插件\n\n```git\n$ git clone https://github.com/meethigher/site\n$ cd hexo \n$ npm install\n$ git submodule update --init\n```\n\n当时在这一步也出了问题，`npm install`的时候出现了卡顿的情况，后来翻墙了也没用，看来我大清国闭关锁国得挺严重啊！不过国内提供了[淘宝镜像](https://npm.taobao.org/)\n\n```npm\n//查看npm的默认安装源\n$ npm config get registry\nhttps://registry.npmjs.org/\n\n//修改npm的默认安装源为淘宝npm镜像\n$ npm config set registry https://registry.npm.taobao.org\n```\n\n# 3. 新增一个功能分支\n\n新增功能分支\n\n```npm\n$ git checkout -b new_feature\n```\n\n# 4. 开始开发\n\ncoding......\n\n# 5. 推送（push）分支\n\n```git\n$ git add .\n$ git commit -m \"更新日志\"\n$ git push origin new_feature\n```\n\n我在推送分支的时候，碰到了一堆错误，后来网上搜了一下，发现是`检测代码规范机制`。\n\n详情点击链接：[git commit前检测husky与pre-commit](https://www.jianshu.com/p/f0d31f92bfab)\n\n这里提供一种解决方案，在提交时加入`--no-verify`参数，用来跳过检测机制\n\n```git\n$ git commit --no-verify -m \"更新日志\"\n```\n\n# 6. 建立一个新的合并申请（pull request）并描述改动\n\n点击项目上的`pull request`去请求\n\n{% asset_img pullrequest.png pullrequest %}\n\n写上我们的更新日志和更改了啥东西，然后点击`create pull request`\n\n然后就没我们啥事了，我们只要等待作者收到邮件同意我们的更新就好了。\n\n# 7. 激动人心的时刻\n\n经过一天的折腾，成功被大佬approve到master了\n\n{% asset_img happy.png happy %}","tags":["git","hexo"]},{"title":"intel命名规则","url":"/blog/2019/intel-rules/","content":"\nintel命名规则\n\n<!--more-->\n\n先说数字：\n第一位代表第几代CPU，一般越大，架构更优。i7-4770K>i7-3770K\n第二位代表处理器等级，数字越大，性能越好。i7-4810mq>i7-4710mq\n第三位代表核显，可忽略不比\n第四位代表功耗可忽略不比\n\n再说后缀：\nH，M,U，表示功耗，字母越小，功耗越大，性能越好。所以后缀：H>M>U。比如：i5-5350H>i7-4610m,i5-4330m>i7-4558U\nH：i7少见，i5的比较多\nM：笔记本专用，双核，M前的数字代表电压高低。比较复杂觉得可以不用太比较\nU：笔记本专用低电压，双核，性能比M差，其前的数字代表功耗。比较复杂觉得可以不用太比较\n\nQM（MQ）：笔记本专用，Q代表quad，即四核CPU。其前的数字代表功耗，数字越小，功耗越大，性能越好。比如3630qm>3635qm\nHQ：HQ与MQ的区别在于封装方式不一样，MQ可拆卸，而HQ不可拆卸。HQ性能略好于MQ。比如：i7-4710hq>i7-4710mq\nXM（MX）：旗舰级CPU。\n\n此外带有MQ，HQ，XM的通常要比带有H,M,U的性能要好很多！\n\n还有一些CPU后面只跟了一个字母X,K,S,T的。\nX代表顶级至尊版（6核12线程）\n而K,S,T代表功耗，字母越小，功耗越大，性能越好。\n另外K还表示可超频，性能大大的上升\n比如：i7-4770K>i7-4790S","tags":["intel"]},{"title":"内部类及其相关知识点","url":"/blog/2019/inner-class/","content":"\n内部类？成员内部类？局部内部类？匿名内部类？类以及接口作为成员变量？\n\n<!--more-->\n\n#### 1. 内部类的概念与分类\n\n如果一个事物的内部包含了另一个事物，那么就是一个类内部包含了另外一个类。\n\n例如：身体和心脏的关系，汽车和发动机的关系。\n\n分类：\n\n1. 成员内部类\n2. 局部内部类（包含匿名内部类）\n\n#### 2. 成员内部类的定义及其使用\n\n成员内部类的定义格式：\n\n```\n修饰符 class 类名称 {\n   修饰符 class 内部类名称 {\n   //..\n   }\n   //..\n}\n```\n\n如何使用成员内部类？两种方式：\n\n1. 间接方式：在外部类的方法当中，使用内部类；然后main只是调用外部类的方法\n\n2. 直接方式：记住公式\n\n   ```\n   类名称 对象名 = new 类名称();//一般的对象创建方式\n   外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();\n   ```\n\n注意：\n\n内用外，随意访问；\n\n外用内，一定需要借助内部类对象\n\nBody.java\n\n```java\npublic class Body {//外部类\n\tpublic void methodBody() {\n\t\tSystem.out.println(\"外部类的方法\");\n\t\tnew Heart().beat();\n\t}\n\tprivate String name;\n\t\n\tpublic Body() {\n\t\tthis.name=\"娃哈哈\";\n\t}\n\t\n\tpublic Body(String name) {\n\t\tthis.name=name;\n\t}\n\tpublic class Heart{//内部类，而且是成员内部类\n\t\t//内部类方法\n\t\tpublic void beat() {\n\t\t\tSystem.out.println(\"心脏跳动：嘭嘭嘭\");\n\t\t\tSystem.out.println(\"我叫：\"+name);//娃哈哈\n\t\t}\n\t}\n}\n```\n\nMain.java\n\n```java\npublic static void main(String[] args) {\n\tnew Body().methodBody();//间接方式访问\n\t\t\n\t//直接方式访问\n\tnew Body().new Heart().beat();\n}\n```\n\n如果外部类跟内部类的成员变量重复了咋整？\n\n```java\npublic class Outer {\n    int num=10;//外部类的成员变量\n    public class Inner /*extends Object*/ {//这个地方表示所有的东西其实都是继承自Object\n        int num=20;//内部类的成员变量\n        public void methodInner(){\n            int num=30;//内部类的局部变量\n            System.out.println(num);//30\n            System.out.println(this.num);//20\n            System.out.println(Outer.this.num);//30\n        }\n    }\n}\n```\n\n如果重现重名现象\n\n```注释\n外部类名称.this.外部类成员变量名//访问外部类里面的变量\n```\n\nMain.java\n\n```java\npublic static void main(String[] args){\n    new Outer().new Inner().methodInner();\n    //上下这两个其实是等价的\n    Outer.Inner inner = new Outer().new Inner();\n}\n```\n\n\n\n#### 3. 局部内部类的定义及其使用\n\n如果一个类是定义在一个**方法内部**的，那么这就是一个**局部内部类**\n\n局部：只有当前所属的方法才能使用他，出了这个方法外面就不能用了\n\n\n\n定义格式：\n\n```注释\n修饰符 class 外部类名称 {\n 修饰符 返回值类型 外部类方法名称（参数列表）{\n  class 局部内部类名称 {\n   //....\n  }\n }\n}\n```\n\n类的权限修饰符：\n\npublic>protected>(default)>private\n\n定义一个类，权限修饰符规则：\n\n1. 外部类：只能用public/(default)\n2. 成员内部类：public/protected/(default)/private\n3. 局部内部类：什么都不写\n\nOuter01.java\n\n```java\npublic class Outer01 {\n\tpublic void methodOuter() {\n\t\tclass Inner {//局部内部类\n\t\t\tint num=10;\n\t\t\tpublic void innerMethod() {\n\t\t\t\tSystem.out.println(num);//10\n\t\t\t}\n\t\t}\n\t\t\n\t\t//局部内部类，只有在这个范围内才能使用，所以，看下面\n\t\tnew Inner().innerMethod();\n\t}\n}\n```\n\nMain.java\n\n```java\npublic static void main(String[] args) {\n\tnew Outer01().methodOuter();\n}\n```\n\n局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是**有效final**的\n\n有效final:即使没写final，如果只赋值一次，也是有效final。写上final会更保险，更好\n\n备注：从Java 8开始，只要局部变量不变，那么final就可以省略。\n\n原因：\n\n1. new出来的对象在堆内存中\n2. 局部变量是跟着方法走的，在栈内存中\n3. 方法运行结束之后，立刻出栈，局部变量就会消失\n4. new出来的对象会在堆中持续存在，直至垃圾回收消失\n\nOuter02.java\n\n```java\npublic class Outer02 {\n\tpublic void methodOuter() {\n\t\tint num=10;//所在方法的局部变量\n\t\t//num=20;//如果再加上这一句，就会报错了,因为必须是有效final\n\t\tclass Inner {\n\t\t\tpublic void methodInner() {\n\t\t\t\tSystem.out.println(num);\n\t\t\t}\n\t\t}\n\t\tnew Inner().methodInner();\n\t}\n}\n```\n\nMain.java\n\n```java\npublic static void main(String[] args) {\n\tnew Outer02().methodOuter();\n}\n```\n\n\n\n#### 4. 匿名内部类(属于局部内部类)的定义及其使用\n\n如果接口的实现类，或者是父类的子类，只需要**使用唯一的一次**。\n\n那么这种情况下，就可以省略该类的定义，而使用匿名内部类。\n\n\n\n匿名内部类的定义格式：\n\n```注释\n接口名称 对象名 = new 接口名称(){\n//覆盖重写接口中所有的抽象方法\n}\n```\n\nnew 接口名称()表示要继承的接口，后面的{}才是匿名内部类\n\n对格式“new 接口名称(){...}”进行解析：\n\n1. new代表创建对象的动作\n2. 接口名称就是匿名内部类要实现的接口\n3. {...}才是匿名内部类的内容\n\n注意：\n\n1. 匿名内部类，在创建对象的时候，只能使用唯一一次。\n   如果希望多次创建对象，而且类的内容一样的话，那么就必须使用单独定义的实现类了\n2. 匿名对象，在调用方法的时候，只能调用唯一一次\n   如果希望同一个对象，调用多次方法，那么必须给对象起名\n3. 匿名内部类是省略了实现类或者子类，匿名对象是省略了对象名称\n   强调：匿名内部类和匿名对象不是一回事\n   匿名内部类有对象名称，匿名对象没有\n\nMyInterface.java\n\n```java\npublic interface MyInterface {\n\tvoid methodAbs();//抽象方法，隐藏了public abstract\n\t\n\tvoid method();\n}\n```\n\nMyInterfaceImpl.java\n\n```java\npublic class MyInterfaceImpl implements MyInterface {\n\n\t@Override\n\tpublic void methodAbs() {\n\t\tSystem.out.println(\"实现类覆盖重写了方法\");\n\t}\n\n\t@Override\n\tpublic void method() {\n\t\tSystem.out.println(\"实现类覆盖重写了方法\");\n\t}\n\n}\n```\n\nMain.java\n\n```java\npublic static void main(String[] args) {\n\t//MyInterfaceImpl impl=new MyInterfaceImpl();\n\t//MyInterface impl=new MyInterfaceImpl();//多态写法\n\t//impl.methodAbs();\n\t\t\n\t\t\n\t//可以使用匿名内部类写\n\tMyInterface impl=new MyInterface() {\n\t\t@Override\n\t\tpublic void methodAbs() {\n\t\t\tSystem.out.println(\"匿名内部类覆盖重写了方法\");\n\t\t}\n\n\t\t@Override\n\t\tpublic void method() {\n\t\t\tSystem.out.println(\"匿名内部类覆盖重写了方法\");\n\t\t}\n\t};\n\t\t\n\timpl.methodAbs();\n\timpl.method();\n\t\t\n\tSystem.out.println(\"===============\");\n\t\t\n\t//使用了匿名内部类，并且省略了对象名称，也就是匿名对象\n\tnew MyInterface() {\n\n\t\t@Override\n\t\tpublic void methodAbs() {\n\t\t\tSystem.out.println(\"匿名内部类覆盖重写了方法\");\n\t\t}\n\n\t\t@Override\n\t\tpublic void method() {\n\t\t\tSystem.out.println(\"匿名内部类覆盖重写了方法\");\n\t\t}\n\t}.methodAbs();\n\t//因为匿名对象无法调用第二次方法，所以需要再创建一个匿名内部类的匿名对象\n\tnew MyInterface() {\n\t\t@Override\n\t\tpublic void methodAbs() {\n\t\t\tSystem.out.println(\"匿名内部类覆盖重写了方法\");\n\t\t}\n\n\t\t@Override\n\t\tpublic void method() {\n\t\t\tSystem.out.println(\"匿名内部类覆盖重写了方法\");\n\t\t}\n\t}.method();\n}\n```\n\n\n\n#### 5. 类以及接口作为成员变量\n\nSkill.java\n\n```java\npublic interface Skill {\n\tvoid useSkill();\n}\n```\n\nSkillImpl.java\n\n```java\npublic class SkillImpl implements Skill {\n\n\t@Override\n\tpublic void useSkill() {\n\t\tSystem.out.println(\"释放技能：国士无双\");\n\t}\n\n}\n```\n\nWeapon.java\n\n```java\npublic class Weapon {\n\tprivate String code;// 武器代号\n\n\tpublic Weapon() {\n\t\t\n\t}\n\n\tpublic Weapon(String code) {\n\t\tthis.code = code;\n\t}\n\n\tpublic String getCode() {\n\t\treturn code;\n\t}\n\n\tpublic void setCode(String code) {\n\t\tthis.code = code;\n\t}\n}\n```\n\nHero.java\n\n```java\npublic class Hero {\n\tprivate String name;// 英雄名字\n\tprivate int age;// 英雄的年龄\n\tprivate Weapon weapon;// 武器\n\tprivate Skill skill;//技能\n\n\tpublic Hero() {\n\t\t\n\t}\n\n\tpublic Hero(String name, int age, Weapon weapon,Skill skill) {\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t\tthis.weapon = weapon;\n\t\tthis.skill=skill;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n\n\tpublic Weapon getWeapon() {\n\t\treturn weapon;\n\t}\n\n\tpublic void setWeapon(Weapon weapon) {\n\t\tthis.weapon = weapon;\n\t}\n\t\n\tpublic Skill getSkill() {\n\t\treturn skill;\n\t}\n\n\tpublic void setSkill(Skill skill) {\n\t\tthis.skill = skill;\n\t}\n\t\n\tpublic void attack() {\n\t\tSystem.out.println(\"英雄\");\n\t\tSystem.out.println(\"年龄:\"+this.getAge()+\" 名称:\"+this.getName()+\" 武器:\"+this.getWeapon().getCode());\n\t\tthis.getSkill().useSkill();\n\t\tSystem.out.println(\"Attack enemy！\");\n\t}\n\n}\n\n```\n\nMain.java\n\n```java\npublic class Demo06Main {\n\tpublic static void main(String[] args) {\n\t\t//创建一个英雄角色\n\t\tHero hero =new Hero();\n\t\t\n\t\t//为英雄起名、设置年龄\n\t\thero.setName(\"韩信\");\n\t\thero.setAge(20);\n\t\t\n\t\t//创建一个Weapon对象\n\t\tWeapon weapon =new Weapon();\n\t\tweapon.setCode(\"枪\");\n\t\t\n\t\t//为英雄配备武器\n\t\thero.setWeapon(weapon);\n\t\t\n\t\t//设置技能：1.可以使用单独定义的实现类 2.可以使用匿名内部类\n\t\thero.setSkill(new SkillImpl());//使用单独定义的实现类\n\t\t\n\t\t//还可以使用匿名内部类（下面使用的是匿名内部类和匿名对象）\n\t\thero.setSkill(new Skill() {\n\t\t\t@Override\n\t\t\tpublic void useSkill() {\n\t\t\t\tSystem.out.println(\"释放技能：背水一战\");\n\t\t\t}\n\t\t});\n\t\t\n\t\t//英雄Attack\n\t\thero.attack();\n\t}\n}\n```\n\n","tags":["java"]},{"title":"来自穷逼对HttpCanary的蹂躏","url":"/blog/2020/httpcanary/","content":"\nHttpCanary一直强制升级，国内又禁止翻墙，我只能如此了\n\n<!--more-->\n\n主要是，我经常用到HttpCanary，目前最新版的是3.3.6，而我用的是3.1.5，一直提示让我更新，不更新不给用。\n\n我尝试反编译了，但是人家有360加固，没得办法。\n\n最后，实在受不了，就想到android能不能像pc一样，设置hosts屏蔽指定的站点。\n\n由此就有了下面的一系列尝试。\n\n# 一、屏蔽host\n\n首先，每次打开，app会有提示\n\n{% asset_img 1.png %}\n\n然后，我就想着，那我抓个包，看看他获取更新的[链接地址](https://raw.githubusercontent.com/MegatronKing/HttpCanary/master/config/premium/version.json)。\n\n{% asset_img 2.png %}\n\n访问一下链接，原来，他更新是通过一串json代码来对比版本号的。\n\n```json\n{\n    \"min\": \"3.3.0\",\n    \"latest\": \"3.3.5\",\n    \"url\": \"https://httpcanary.com/app/httpcanary_premium_v3.3.5.apk\",\n    \"en_notes\": \" • Important: The 3.2.x version was expired, please upgrade to v3.3+.\\n • New features: search, sort and multi selection.\\n • New features: batch save, zip save and batch add black/white list.\\n • Refactor filter and record save.\\n • Redesign icons in list and title texts.\\n • Fixed the long loading issue.\\n • Fixed the issue where the sub menu icon is invisible.\\n • Fixed certificate installation issue.\\n • Minor bugfixes and other improvements.\\n\",\n    \"zh_notes\": \" • 重要：3.2.x版本已失效，请升级至3.3.x以上版本。\\n • 新增全局搜索、排序、多选等功能。\\n • 新增批量保存、压缩保存、批量添加黑白名单等功能。\\n • 重构和优化过滤、保存功能。\\n • 重新设计列表非应用类Icon、标题栏内容等样式。\\n • 修复启动加载时间过长的bug。\\n • 修复标题栏子菜单图标不显示的bug。\\n • 修复安装证书横竖屏切换等场景出现无限循环安装证书的bug。\\n • 其它细节问题修复和优化。\\n\",\n    \"md5\": \"49c4ddbb2bafd7150a49cdbe35443744\"\n}\n```\n\n> 其实也可以通过静态注入，将返回的最低版本3.3.0修改成低版本，就不会强制退出了。不过需要一直开着抓包软件，进行静态注入，就很麻烦，不如直接hosts屏蔽。\n\n接下来，手机进行修改hosts，路径是`/system/etc/hosts`\n\n我尝试用MT管理器直接进行修改，但是没法保存，提示`failed on '/etc/hosts' - Device or resource busy`\n\n后来发现，用命令终端是可以的。还是用MT管理器，左侧找到终端模拟器\n\n具体命令\n\n```powershell\nsu\n```\n\nsu是为了获取root权限\n\n```powershell\nvi /system/etc/hosts\n```\n\n然后键盘点i进入编辑模式，编辑完了之后，按esc，输入`:wq`进行保存\n\n> 如果提示hosts readonly的话，打开Magisk Manager里面的Systemless hosts即可。\n\n{% asset_img 3.png %}\n\n如此就ok了。\n\n{% asset_img 4.png %}\n\n最后如何测试呢？\n\n修改之后，再次访问[该链接地址](https://raw.githubusercontent.com/MegatronKing/HttpCanary/master/config/premium/version.json)\n\n会直接提示，无法打开\n\n{% asset_img 5.png %}\n\n# 二、修改hosts文件权限\n\n还是用命令行，在用`su`获取root权限的情况下，执行下面的代码\n\n```powershell\nchmod 666 /system/etc/hosts\n```\n\n意思就是授予hosts文件所有权限\n\n> 666表示所有者、用户组、其他都有读写权限","tags":["android"]},{"title":"Java常用API以及包装类的装箱拆箱","url":"/blog/2019/java-api/","content":"\njava中常用的api\n\n<!--more-->\n\n# 第一章 Object类\n\n## 1.1 概述\n\n`java.lang.Object`类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。\n\n如果一个类没有特别指定父类，\t那么默认则继承自Object类。例如：\n\n```java\npublic class MyClass /*extends Object*/ {\n  \t// ...\n}\n```\n\n根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的2个：\n\n* `public String toString()`：返回该对象的字符串表示。\n* `public boolean equals(Object obj)`：指示其他某个对象是否与此对象“相等”。\n\n## 1.2 toString方法\n\n### 方法摘要\n\n* `public String toString()`：返回该对象的字符串表示。\n\ntoString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。\n\n由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。\n\n### 覆盖重写\n\n如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类：\n\n```java\npublic class Person {  \n    private String name;\n    private int age;\n\n    @Override\n    public String toString() {\n        return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}';\n    }\n\n    // 省略构造器与Getter Setter\n}\n```\n\n在IntelliJ IDEA中，可以点击`Code`菜单中的`Generate...`，也可以使用快捷键`alt+insert`，点击`toString()`选项。选择需要包含的成员变量并确定。如下图所示：\n\n> 小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。\n>\n\n## 1.3 equals方法\n\n### 方法摘要\n\n* `public boolean equals(Object obj)`：指示其他某个对象是否与此对象“相等”。\n\n调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。\n\n### 默认地址比较\n\n如果没有覆盖重写equals方法，那么Object类中默认进行`==`运算符的对象地址比较，只要不是同一个对象，结果必然为false。\n\n### 对象内容比较\n\n如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如：\n\n```java\nimport java.util.Objects;\n\npublic class Person {\t\n\tprivate String name;\n\tprivate int age;\n\t\n    @Override\n    public boolean equals(Object o) {\n        // 如果对象地址一样，则认为相同\n        if (this == o)\n            return true;\n        // 如果参数为空，或者类型信息不一样，则认为不同\n        if (o == null || getClass() != o.getClass())\n            return false;\n        // 转换为当前类型\n        Person person = (Person) o;\n        // 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果\n        return age == person.age && Objects.equals(name, person.name);\n    }\n}\n```\n\n这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用`Code`菜单中的`Generate…`选项，也可以使用快捷键`alt+insert`，并选择`equals() and hashCode()`进行自动代码生成。如下图所示：\n\n> tips：Object类当中的hashCode等其他方法，今后学习。\n\n## 1.4 Objects类\n\n在刚才IDEA自动重写equals代码中，使用到了`java.util.Objects`类，那么这个类是什么呢？\n\n在**JDK7**添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。\n\n在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下：\n\n* `public static boolean equals(Object a, Object b)`:判断两个对象是否相等。\n\n我们可以查看一下源码，学习一下：\n\n~~~java\npublic static boolean equals(Object a, Object b) {  \n    return (a == b) || (a != null && a.equals(b));  \n}\n~~~\n\n# 第二章 日期时间类\n\n## 2.1 Date类\n\n### 概述\n\n` java.util.Date`类 表示特定的瞬间，精确到毫秒。\n\n继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。\n\n- `public Date()`：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。\n- `public Date(long date)`：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。\n\n> tips: 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。\n\n简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如：\n\n```java\nimport java.util.Date;\n\npublic class Demo01Date {\n    public static void main(String[] args) {\n        // 创建日期对象，把当前的时间\n        System.out.println(new Date()); // Tue Jan 16 14:37:35 CST 2018\n        // 创建日期对象，把当前的毫秒值转成日期对象\n        System.out.println(new Date(0L)); // Thu Jan 01 08:00:00 CST 1970\n    }\n}\n```\n\n> tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。\n>\n\n### 常用方法\n\nDate类中的多数方法已经过时，常用的方法有：\n\n* `public long getTime()` 把日期对象转换成对应的时间毫秒值。\n\n## 2.2 DateFormat类\n\n`java.text.DateFormat` 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。\n\n* **格式化**：按照指定的格式，从Date对象转换为String对象。\n* **解析**：按照指定的格式，从String对象转换为Date对象。\n\n### 构造方法\n\n由于DateFormat为抽象类，不能直接使用，所以需要常用的子类`java.text.SimpleDateFormat`。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为：\n\n* `public SimpleDateFormat(String pattern)`：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。\n\n参数pattern是一个字符串，代表日期时间的自定义格式。\n\n### 格式规则\n\n常用的格式规则为：\n\n| 标识字母（区分大小写） | 含义   |\n| ----------- | ---- |\n| y           | 年    |\n| M           | 月    |\n| d           | 日    |\n| H           | 时    |\n| m           | 分    |\n| s           | 秒    |\n\n> 备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档0。\n\n创建SimpleDateFormat对象的代码如：\n\n```java\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\n\npublic class Demo02SimpleDateFormat {\n    public static void main(String[] args) {\n        // 对应的日期格式如：2018-01-16 15:06:38\n        DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n    }    \n}\n```\n\n### 常用方法\n\nDateFormat类的常用方法有：\n\n- `public String format(Date date)`：将Date对象格式化为字符串。\n- `public Date parse(String source)`：将字符串解析为Date对象。 \n  public Date parse(String source) throws ParseException\n  \t * 声明了一个异常ParseException\n  \t * 如果字符串和构造方法的模式不一样，那么程序就会抛出异常\n  \t * 调用了一个抛出异常的方法，就必须处理异常，处理异常两种方式：\n  \t * 1.throws继续抛出异常；\n  \t * 2.要么try catch自己处理\n\n#### format方法\n\n使用format方法的代码为：\n\n```java\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n/*\n 把Date对象转换成String\n*/\npublic class Demo03DateFormatMethod {\n    public static void main(String[] args) {\n        Date date = new Date();\n        // 创建日期格式化对象,在获取格式化对象时可以指定风格\n        DateFormat df = new SimpleDateFormat(\"yyyy年MM月dd日\");\n        String str = df.format(date);\n        System.out.println(str); // 2008年1月23日\n    }\n}\n```\n\n#### parse方法\n\n使用parse方法的代码为：\n\n```java\nimport java.text.DateFormat;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n/*\n 把String转换成Date对象\n*/\npublic class Demo04DateFormatMethod {\n    public static void main(String[] args) throws ParseException {\n        DateFormat df = new SimpleDateFormat(\"yyyy年MM月dd日\");\n        String str = \"2018年12月11日\";\n        Date date = df.parse(str);\n        System.out.println(date); // Tue Dec 11 00:00:00 CST 2018\n    }\n}\n```\n\n## 2.3 练习\n\n请使用日期时间相关的API，计算出一个人已经出生了多少天。\n\n**思路：**\n\n1.获取当前时间对应的毫秒值\n\n2.获取自己出生日期对应的毫秒值\n\n3.两个时间相减（当前时间– 出生日期）\n\n**代码实现：**\n\n```java\npublic static void function() throws Exception {\n\tSystem.out.println(\"请输入出生日期 格式 YYYY-MM-dd\");\n\t// 获取出生日期,键盘输入\n\tString birthdayString = new Scanner(System.in).next();\n\t// 将字符串日期,转成Date对象\n\t// 创建SimpleDateFormat对象,写日期模式\n\tSimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n\t// 调用方法parse,字符串转成日期对象\n\tDate birthdayDate = sdf.parse(birthdayString);\t\n\t// 获取今天的日期对象\n\tDate todayDate = new Date();\t\n\t// 将两个日期转成毫秒值,Date类的方法getTime\n\tlong birthdaySecond = birthdayDate.getTime();\n\tlong todaySecond = todayDate.getTime();\n\tlong secone = todaySecond-birthdaySecond;\t\n\tif (secone < 0){\n\t\tSystem.out.println(\"还没出生呢\");\n\t} else {\n\t\tSystem.out.println(secone/1000/60/60/24);\n\t}\n}\n```\n\n## 2.4 Calendar类\n\n###  概念\n\n日历我们都见过\n\n`java.util.Calendar`是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。\n\n### 获取方式\n\nCalendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下：\n\nCalendar静态方法\n\n* `public static Calendar getInstance()`：使用默认时区和语言环境获得一个日历\n\n例如：\n\n```java\nimport java.util.Calendar;\n\npublic class Demo06CalendarInit {\n    public static void main(String[] args) {\n        Calendar cal = Calendar.getInstance();\n    }    \n}\n```\n\n### 常用方法\n\n根据Calendar类的API文档，常用方法有：\n\n- `public int get(int field)`：返回给定日历字段的值。\n- `public void set(int field, int value)`：将给定的日历字段设置为给定值。\n- `public abstract void add(int field, int amount)`：根据日历的规则，为给定的日历字段添加或减去指定的时间量。\n- `public Date getTime()`：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。\n\nCalendar类中提供很多成员常量，代表给定的日历字段：\n\n| 字段值          | 含义                   |\n| ------------ | -------------------- |\n| YEAR         | 年                    |\n| MONTH        | 月（从0开始，可以+1使用）       |\n| DAY_OF_MONTH | 月中的天（几号）             |\n| HOUR         | 时（12小时制）             |\n| HOUR_OF_DAY  | 时（24小时制）             |\n| MINUTE       | 分                    |\n| SECOND       | 秒                    |\n| DAY_OF_WEEK  | 周中的天（周几，周日为1，可以-1使用） |\n\n#### get/set方法\n\nget方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示：\n\n```java\nimport java.util.Calendar;\n\npublic class CalendarUtil {\n    public static void main(String[] args) {\n        // 创建Calendar对象\n        Calendar cal = Calendar.getInstance();\n        // 设置年 \n        int year = cal.get(Calendar.YEAR);\n        // 设置月\n        int month = cal.get(Calendar.MONTH) + 1;\n        // 设置日\n        int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH);\n        System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\");\n    }    \n}\n```\n\n```java\nimport java.util.Calendar;\n\npublic class Demo07CalendarMethod {\n    public static void main(String[] args) {\n        Calendar cal = Calendar.getInstance();\n        cal.set(Calendar.YEAR, 2020);\n        System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2020年1月17日\n    }\n}\n```\n\n#### add方法\n\nadd方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如：\n\n```java\nimport java.util.Calendar;\n\npublic class Demo08CalendarMethod {\n    public static void main(String[] args) {\n        Calendar cal = Calendar.getInstance();\n        System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2018年1月17日\n        // 使用add方法\n        cal.add(Calendar.DAY_OF_MONTH, 2); // 加2天\n        cal.add(Calendar.YEAR, -3); // 减3年\n        System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2015年1月18日; \n    }\n}\n```\n\n#### getTime方法\n\nCalendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。\n\n```java\nimport java.util.Calendar;\nimport java.util.Date;\n\npublic class Demo09CalendarMethod {\n    public static void main(String[] args) {\n        Calendar cal = Calendar.getInstance();\n        Date date = cal.getTime();\n        System.out.println(date); // Tue Jan 16 16:03:09 CST 2018\n    }\n}\n```\n\n> 小贴士：\n>\n> ​     西方星期的开始为周日，中国为周一。\n>\n> ​     在Calendar类中，月份的表示是以0-11代表1-12月。\n>\n> ​     日期是有大小关系的，时间靠后，时间越大。\n>\n\n# 第三章 System类\n\n`java.lang.System`类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有：\n\n- `public static long currentTimeMillis()`：返回以毫秒为单位的当前时间。\n- `public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)`：将数组中指定的数据拷贝到另一个数组中。\n\n## 3.1 currentTimeMillis方法\n\n实际上，currentTimeMillis方法就是 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值\n\n```java\nimport java.util.Date;\n\npublic class SystemDemo {\n    public static void main(String[] args) {\n       \t//获取当前时间毫秒值\n        System.out.println(System.currentTimeMillis()); // 1516090531144\n    }\n}\n```\n\n### 练习\n\n验证for循环打印数字1-9999所需要使用的时间（毫秒）\n\n~~~java\npublic class SystemTest1 {\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        for (int i = 0; i < 10000; i++) {\n            System.out.println(i);\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(\"共耗时毫秒：\" + (end - start));\n    }\n}\n~~~\n\n## 3.2 arraycopy方法\n\n* `public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)`：将数组中指定的数据拷贝到另一个数组中。\n\n数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为：\n\n| 参数序号 | 参数名称    | 参数类型   | 参数含义       |\n| ---- | ------- | ------ | ---------- |\n| 1    | src     | Object | 源数组        |\n| 2    | srcPos  | int    | 源数组索引起始位置  |\n| 3    | dest    | Object | 目标数组       |\n| 4    | destPos | int    | 目标数组索引起始位置 |\n| 5    | length  | int    | 复制元素个数     |\n\n### 练习\n\n将src数组中前3个元素，复制到dest数组的前3个位置上复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10]\n\n```java\nimport java.util.Arrays;\n\npublic class Demo11SystemArrayCopy {\n    public static void main(String[] args) {\n        int[] src = new int[]{1,2,3,4,5};\n        int[] dest = new int[]{6,7,8,9,10};\n        System.arraycopy( src, 0, dest, 0, 3);\n        /*代码运行后：两个数组中的元素发生了变化\n         src数组元素[1,2,3,4,5]\n         dest数组元素[1,2,3,9,10]\n        */\n    }\n}\n```\n\n# 第四章 StringBuilder类\n\n## 4.1 字符串拼接问题\n\n由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如：\n\n~~~java\npublic class StringDemo {\n    public static void main(String[] args) {\n        String s = \"Hello\";\n        s += \"World\";\n        System.out.println(s);\n    }\n}\n~~~\n\n在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。\n\n根据这句话分析我们的代码，其实总共产生了三个字符串，即`\"Hello\"`、`\"World\"`和`\"HelloWorld\"`。引用变量s首先指向`Hello`对象，最终指向拼接出来的新字符串对象，即`HelloWord` 。\n\n由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用`java.lang.StringBuilder`类。\n\n## 4.2 StringBuilder概述\n\n查阅`java.lang.StringBuilder`的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。\n\n原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。\n\n它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充)\n\n{% asset_img StringBuilder的原理.png StringBuilder的原理 %}\n\n## 4.3 构造方法\n\n根据StringBuilder的API文档，常用构造方法有2个：\n\n- `public StringBuilder()`：构造一个空的StringBuilder容器。\n- `public StringBuilder(String str)`：构造一个StringBuilder容器，并将字符串添加进去。\n\n```java\npublic class StringBuilderDemo {\n    public static void main(String[] args) {\n        StringBuilder sb1 = new StringBuilder();\n        System.out.println(sb1); // (空白)\n        // 使用带参构造\n        StringBuilder sb2 = new StringBuilder(\"itcast\");\n        System.out.println(sb2); // itcast\n    }\n}\n```\n\n## 4.4 常用方法\n\nStringBuilder常用的方法有2个：\n\n- `public StringBuilder append(...)`：添加任意类型数据的字符串形式，并返回当前对象自身。\n- `public String toString()`：将当前StringBuilder对象转换为String对象。\n\n### append方法\n\nappend方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如：\n\n```java\npublic class Demo02StringBuilder {\n\tpublic static void main(String[] args) {\n\t\t//创建对象\n\t\tStringBuilder builder = new StringBuilder();\n\t\t//public StringBuilder append(任意类型)\n\t\tStringBuilder builder2 = builder.append(\"hello\");\n\t\t//对比一下\n\t\tSystem.out.println(\"builder:\"+builder);\n\t\tSystem.out.println(\"builder2:\"+builder2);\n\t\tSystem.out.println(builder == builder2); //true\n\t    // 可以添加 任何类型\n\t\tbuilder.append(\"hello\");\n\t\tbuilder.append(\"world\");\n\t\tbuilder.append(true);\n\t\tbuilder.append(100);\n\t\t// 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。\n        // 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下\n\t\t//链式编程\n\t\tbuilder.append(\"hello\").append(\"world\").append(true).append(100);\n\t\tSystem.out.println(\"builder:\"+builder);\n\t}\n}\n```\n\n> 备注：StringBuilder已经覆盖重写了Object当中的toString方法。\n\n### toString方法\n\n通过toString方法，StringBuilder对象将会转换为不可变的String对象。如：\n\n```java\npublic class Demo16StringBuilder {\n    public static void main(String[] args) {\n        // 链式创建\n        StringBuilder sb = new StringBuilder(\"Hello\").append(\"World\").append(\"Java\");\n        // 调用方法\n        String str = sb.toString();\n        System.out.println(str); // HelloWorldJava\n    }\n}\n```\n\n# 第五章 包装类\n\n## 5.1 概述\n\nJava提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：\n\n| 基本类型    | 对应的包装类（位于java.lang包中） |\n| ------- | --------------------- |\n| byte    | Byte                  |\n| short   | Short                 |\n| int     | **Integer**           |\n| long    | Long                  |\n| float   | Float                 |\n| double  | Double                |\n| char    | **Character**         |\n| boolean | Boolean               |\n\n## 5.2 装箱与拆箱\n\n基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：\n\n* **装箱**：从基本类型转换为对应的包装类对象。\n\n* **拆箱**：从包装类对象转换为对应的基本类型。\n\n用Integer与 int为例：（看懂代码即可）\n\n基本数值---->包装对象\n\n~~~java\nInteger i = new Integer(4);//使用构造函数函数\nInteger iii = Integer.valueOf(4);//使用包装类中的valueOf方法\n~~~\n\n包装对象---->基本数值\n\n~~~java\nint num = i.intValue();\n~~~\n## 5.3自动装箱与自动拆箱\n\n由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：\n\n```java\nInteger i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);\ni = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;\n//加法运算完成后，再次装箱，把基本数值转成对象。\n```\n\n## 5.3 基本类型与字符串之间的转换\n\n### 基本类型转换为String\n\n   基本类型转换String总共有三种方式，查看课后资料可以得知，这里只讲最简单的一种方式： \n\n~~~\n基本类型直接与””相连接即可；如：34+\"\"\n~~~\n\nString转换成对应的基本类型 \n\n除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：\n\n- `public static byte parseByte(String s)`：将字符串参数转换为对应的byte基本类型。\n- `public static short parseShort(String s)`：将字符串参数转换为对应的short基本类型。\n- `public static int parseInt(String s)`：将字符串参数转换为对应的int基本类型。\n- `public static long parseLong(String s)`：将字符串参数转换为对应的long基本类型。\n- `public static float parseFloat(String s)`：将字符串参数转换为对应的float基本类型。\n- `public static double parseDouble(String s)`：将字符串参数转换为对应的double基本类型。\n- `public static boolean parseBoolean(String s)`：将字符串参数转换为对应的boolean基本类型。\n\n代码使用（仅以Integer类的静态方法parseXxx为例）如：\n\n```java\npublic class Demo18WrapperParse {\n    public static void main(String[] args) {\n        int num = Integer.parseInt(\"100\");\n    }\n}\n```\n\n> 注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出`java.lang.NumberFormatException`异常。\n>\n\n","tags":["java"]},{"title":"java算法题","url":"/blog/2019/java-algorithm/","content":"\n记录从codewars刷算法的过程\n\n<!--more-->\n\n### 1. Take a Ten Minute Walk\n\n##### 描述\n\n```\nYou live in the city of Cartesia where all roads are laid out in a perfect grid. You arrived ten minutes too early to an appointment, so you decided to take the opportunity to go for a short walk. The city provides its citizens with a Walk Generating App on their phones -- everytime you press the button it sends you an array of one-letter strings representing directions to walk (eg. ['n', 's', 'w', 'e']). You always walk only a single block in a direction and you know it takes you one minute to traverse one city block, so create a function that will return true if the walk the app gives you will take you exactly ten minutes (you don't want to be early or late!) and will, of course, return you to your starting point. Return false otherwise.\n\nNote: you will always receive a valid array containing a random assortment of direction letters ('n', 's', 'e', or 'w' only). It will never give you an empty array (that's not a walk, that's standing still!).\n```\n\n##### 思路\n\n判断一个数组长度是否为10，里面n的数量等于s，w的数量等于s，则返回true，否则false\n\n##### 实现\n\n###### 我的解决方案\n\n```java\npublic class TenMinWalk {\n\tpublic static boolean isValid(char[] walk) {\n\t\tboolean flag=true;\n\t\tint[] directions =new int[4];\n\t\tif(walk.length!=10) \n\t\t\tflag=false;\n\t\tfor (int i = 0; i < walk.length; i++) {\n\t\t\tif(walk[i]=='n') {\n\t\t\t\tdirections[0]++;\n\t\t\t}else if(walk[i]=='s') {\n\t\t\t\tdirections[1]++;\n\t\t\t}else if(walk[i]=='e') {\n\t\t\t\tdirections[2]++;\n\t\t\t}else if(walk[i]=='w') {\n\t\t\t\tdirections[3]++;\n\t\t\t}\n\t\t}\n\t\tif(!(directions[0]==directions[1]&&directions[2]==directions[3]))\n\t\t\tflag=false;\n\t\t\n\t\treturn flag;\n\t}\n}\n```\n\n###### 大佬的解决方案\n\n```java\npublic class TenMinWalk {\n  public static boolean isValid(char[] walk) {\n    if (walk.length != 10) {\n      return false;\n    }\n    int x = 0, y = 0;\n    for (int i = 0; i < 10; i++) {\n      switch (walk[i]) {\n        case 'n':\n          y++;\n          break;\n        case 'e':\n          x++;\n          break;\n        case 's':\n          y--;\n          break;\n        case 'w':\n          x--;\n          break;\n      }\n    }\n    return x == 0 && y == 0;\n  }\n}\n```\n\n### 2. Find the odd int\n\n##### 描述\n\n```\nGiven an array, find the int that appears an odd number of times.\n\nThere will always be only one integer that appears an odd number of times.\n```\n\n##### 思路\n\nmap集合，key存储数字，value存储次数。遍历集合，将value为奇数的key输出\n\n##### 实现\n\n###### 我的解决方案\n\n```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class FindOdd {\n\tpublic static int findIt(int[] a) {\n\t    Map<Integer,Integer> map=new HashMap<Integer,Integer>();\n\t    for (int i = 0; i < a.length; i++) {\n\t\t\tmap.put(a[i], 0);\n\t\t}\n\t    for (int i = 0; i < a.length; i++) {\n\t    \tint count=map.get(a[i]);\n\t    \t++count;\n\t\t\tmap.put(a[i], count);\n\t\t}\n\t    for(Integer key:map.keySet()) {\n\t    \tif(map.get(key)%2==0)\n\t    \t\tcontinue;\n\t    \treturn key;\n\t    }\n\t    return 0;\n\t  }\n}\n```\n\n\n\n###### 大佬的解决方案\n\n```java\npublic class FindOdd {\n  public static int findIt(int[] A) {\n    int xor = 0;\n    for (int i = 0; i < A.length; i++) {\n      xor ^= A[i];\n    }\n    return xor;\n  }\n}\n```\n\n异或的运算规则：相同为0，不同为1\n\n异或要将运算的两个数字转换为二进制进行运算\n\n```\n// 比方说 1⊕2⊕1=2\n0 0 0 1 -----1\n0 0 1 0 -----2\n-------------\n0 0 1 1 -----3\n0 0 0 1 -----1\n-------------\n0 0 1 0 -----2\n```\n\n### 3. Simple Encryption #1 - Alternating Split\n\n##### 描述\n\n```\nFor building the encrypted string:\nTake every 2nd char from the string, then the other chars, that are not every 2nd char, and concat them as new String.\nDo this n times!\n\nExamples:\n\n\"This is a test!\", 1 -> \"hsi  etTi sats!\"\n\"This is a test!\", 2 -> \"hsi  etTi sats!\" -> \"s eT ashi tist!\"\nWrite two methods:\n\nString encrypt(final String text, final int n)\nString decrypt(final String encryptedText, final int n)\nFor both methods:\nIf the input-string is null or empty return exactly this value!\nIf n is <= 0 then return the input text.\n\nThis kata is part of the Simple Encryption Series:\nSimple Encryption #1 - Alternating Split\nSimple Encryption #2 - Index-Difference\nSimple Encryption #3 - Turn The Bits Around\nSimple Encryption #4 - Qwerty\n```\n\n##### 思路\n\n```\n加密：将字符串转换成字符数组，然后String1存储every 2nd，剩下的给String2，然后将String1跟String2拼接起来。\n\n解密：将字符串分割成两部分，即分割成加密中的String1跟String2，然后将String1跟String2依次拼接。\n```\n\n##### 实现\n\n###### 我的解决方案\n\n```java\n public class Kata {\n\n\tpublic static String encrypt(final String text, final int n) {\n\t\tif(n<1)\n\t\t\treturn text;\n\t\tString[] arr=text.split(\"\");\n\t\tString str1=\"\";//存储every 2nd\n\t\tString str2=\"\";\n\t\tString str=\"\";\n\t\tint m=n;\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tif((i&1)==1) {\n\t\t\t\tstr1+=arr[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstr2+=arr[i];\n\t\t}\n\t\tstr=str1+str2;\n\t\tif(m>1) \n\t\t\tstr=encrypt(str,--m);\n\t\treturn str;\n\t}\n\n\tpublic static String decrypt(final String encryptedText, final int n) {\n\t\tif(n<1)\n\t\t\treturn encryptedText;\n\t\tString[] arr=encryptedText.split(\"\");\n\t\tint splitNum=arr.length/2;\n\t\tString str1=\"\";\n\t\tString str2=\"\";\n\t\tString str=\"\";\n\t\tint m=n;\n\t\tfor(int i=0;i<splitNum;i++) {\n\t\t\tstr2+=arr[i];\n\t\t}\n\t\tfor(int i=splitNum;i<arr.length;i++) {\n\t\t\tstr1+=arr[i];\n\t\t}\n\t\tfor(int i=0;i<splitNum;i++) {\n\t\t\tstr+=str1.charAt(i);\n\t\t\tstr+=str2.charAt(i);\n\t\t}\n\t\tif(str1.length()>str2.length()) {\n\t\t\tstr+=str1.charAt(splitNum);\n\t\t}\n\t\tif(m>1)\n\t\t\tstr=decrypt(str,--m);\n\t\treturn str;\n\t}\n}\n\n```\n\n\n\n###### 大佬的解决方案\n\n```java\npublic class Kata {\n\n\tpublic static String encrypt(final String text, int n) {\n\t\tif (n <= 0 || text == null || text.isEmpty()) {\n\t\t\treturn text;\n\t\t}\n\n\t\tStringBuilder firstPart = new StringBuilder();\n\t\tStringBuilder secondPart = new StringBuilder();\n\t\tfor (int i = 0; i < text.length(); i++) {\n\t\t\tchar aChar = text.charAt(i);\n\t\t\tif (i % 2 == 1) {\n\t\t\t\tfirstPart.append(aChar);\n\t\t\t} else {\n\t\t\t\tsecondPart.append(aChar);\n\t\t\t}\n\t\t}\n\n\t\treturn encrypt(firstPart.append(secondPart).toString(), --n);\n\t}\n\n\tpublic static String decrypt(final String encryptedText, int n) {\n\t\tif (n <= 0 || encryptedText == null || encryptedText.isEmpty()) {\n\t\t\treturn encryptedText;\n\t\t}\n\n\t\tStringBuilder text = new StringBuilder();\n\t\tfinal int half = encryptedText.length() / 2;\n\t\tfor (int i = 0; i < half; i++) {\n\t\t\ttext.append(encryptedText.charAt(half + i)).append(encryptedText.charAt(i));\n\t\t}\n\t\tif (encryptedText.length() % 2 == 1) {\n\t\t\ttext.append(encryptedText.charAt(encryptedText.length() - 1));\n\t\t}\n\n\t\treturn decrypt(text.toString(), --n);\n\t}\n\n}\n```\n\nStringBuilder是一个可变的字符序列\n\n### 4. [Maximum subarray sum](https://www.codewars.com/kata/maximum-subarray-sum/train/java)\n\n[^时间]: 2019-10-13 周日\n\n##### 描述\n\n```\nThe maximum sum subarray problem consists in finding the maximum sum of a contiguous subsequence in an array or list of integers:\n\nMax.sequence(new int[]{-2, 1, -3, 4, -1, 2, 1, -5, 4});\n// should be 6: {4, -1, 2, 1}\nEasy case is when the list is made up of only positive numbers and the maximum sum is the sum of the whole array. If the list is made up of only negative numbers, return 0 instead.\n\nEmpty list is considered to have zero greatest sum. Note that the empty list or array is also a valid sublist/subarray.\n```\n\n##### 思路\n\n```\n解决方案：\n1. 暴力破解\n2. 分治法\n分治法的核心思想就是将大问题分解为小问题，再将小问题逐个解决，然后从小问题的解得到原问题的解\n如果把数组从任一点（一般取中点）分为两个数组，那最大子数组只能存在于三个位置\na.左数组 b.右数组 3.中间数组（左数组最大后缀和右数组最大前缀的拼接）\n然后把分得的两个数组使用递归算法继续进行分割，直到每个子数组只含有一个元素\n\n太难了，我放弃了\n3. 动态规划\n```\n\n##### 实现\n\n###### 我的解决方案\n\n```java\npublic static int sequence(int[] arr) {\n\t\tint max=-9999;\n\t\tfor(int i=0;i<arr.length;i++) {\n\t\t\tfor(int j=i;j<arr.length;j++) {\n\t\t\t\tint sum=0;\n\t\t\t\tfor(int k=i;k<=j;k++) {\n\t\t\t\t\tsum+=arr[k];\n\t\t\t\t}\n\t\t\t\tif(max<sum)\n\t\t\t\t\tmax=sum;\n\t\t\t}\n\t\t}\n\t\treturn max<0?0:max;\n}\n```\n\n###### 大佬的解决方案\n\n```\tjava\npublic class Max {\n\n    public static int sequence(int[] arr) {\n        int max_ending_here = 0, max_so_far = 0;\n        for (int v : arr) {\n            max_ending_here = Math.max(0, max_ending_here + v);\n            max_so_far = Math.max(max_so_far, max_ending_here);\n        }\n        return max_so_far;\n    }\n}\n\n//可以这样理解\npublic static int sequence(int[] arr) {\n\t\t int max=-9999,cur=0;\n\t\t for(int i=0;i<arr.length;i++) {\n\t\t\t if(cur<0) {\n\t\t\t\t cur=arr[i];\n\t\t\t }else {\n\t\t\t\t cur+=arr[i];\n\t\t\t }\n\t\t\t if(cur>=max) {\n\t\t\t\t max=cur;\n\t\t\t }\n\t\t }\n\t\t return max<0?0:max;\n}\n```\n\n### 5. [Double Cola](https://www.codewars.com/kata/double-cola/train/java)\n\n[^时间]: 2019-10-13 周日\n\n##### 描述\n\n```\nSheldon, Leonard, Penny, Rajesh and Howard are in the queue for a \"Double Cola\" drink vending machine; there are no other people in the queue. The first one in the queue (Sheldon) buys a can, drinks it and doubles! The resulting two Sheldons go to the end of the queue. Then the next in the queue (Leonard) buys a can, drinks it and gets to the end of the queue as two Leonards, and so on.\n\nFor example, Penny drinks the third can of cola and the queue will look like this:\n\nRajesh, Howard, Sheldon, Sheldon, Leonard, Leonard, Penny, Penny\nWrite a program that will return the name of the person who will drink the n-th cola.\n\nInput\nThe input data consist of an array which contains at least 1 name, and single integer n which may go as high as the biggest number your language of choice supports (if there's such limit, of course).\n\nOutput / Examples\nReturn the single line — the name of the person who drinks the n-th can of cola. The cans are numbered starting from 1.\n\nstring[] names = new string[] { \"Sheldon\", \"Leonard\", \"Penny\", \"Rajesh\", \"Howard\" };\nLine.WhoIsNext(names, 1) == \"Sheldon\"\nLine.WhoIsNext(names, 52) == \"Penny\"\nLine.WhoIsNext(names, 7230702951) == \"Leonard\"\n```\n\n##### 思路\n\n```\n每到一个人，喝下后会拥有分身术，并且移动到末尾\n其实就是一个等比数列，a1=5,q=2,an=5*Math.pow(2,n-1);\n等比数列前n项和为 sn=5*Math.pow(2,n)-5;\n如果求第六个喝饮料的人，就是6-s1==1,这时候，复制的镜像为copies=Math.pow(2,1)==2;所以1/copies向上取整即为结果\n如果求第52个喝饮料的人，就是52-s3==17,这时候，复制的镜像为copies=Math.pow(2,3)==8;所以17/copies向上取整即为结果\n```\n\n##### 实现\n\n###### 我的解决方案\n\n```java\npublic static String WhoIsNext(String[] names, int n) {\n\t\tint length = names.length;\n\t\tint i = 1;\n\t\tdouble sum=0;\n\t\tif (n < length)\n\t\t\treturn names[n - 1];\n\t\twhile (true) {\n\t\t\tsum = 5 * Math.pow(2, i) - 5;\n\t\t\tif (sum > n) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tdouble div=n-(5*Math.pow(2, i-1)-5);\n\t\tdouble copies=Math.pow(2, i-1);\n\t\t\n\t\treturn names[(int) Math.ceil(div/copies)-1];\n\t}\n```\n\n###### 大佬的解决方案\n\n```java\npublic class Line {\n  public static String WhoIsNext(String[] names, int n){\n    while ( n > names.length){\n      n = (n - (names.length - 1)) / 2;\n    }\n    return names[n-1];\n  }\n}\n```\n\n### 6. [Scramblies](https://www.codewars.com/kata/scramblies/train/java)\n\n[^时间]: 2019-10-13 周日\n\n##### 描述\n\n```\nComplete the function scramble(str1, str2) that returns true if a portion of str1 characters can be rearranged to match str2, otherwise returns false.\n\nNotes:\n\nOnly lower case letters will be used (a-z). No punctuation or digits will be included.\nPerformance needs to be considered\nInput strings s1 and s2 are null terminated.\nExamples\nscramble('rkqodlw', 'world') ==> True\nscramble('cedewaraaossoqqyt', 'codewars') ==> True\nscramble('katas', 'steak') ==> False\n```\n\n##### 思路\n\n```\n判断str1中是否有str2里面的字符。如果有，就把str1中的删掉。没有就直接false\n```\n\n##### 实现\n\n###### 我的解决方案\n\n```java\npublic class Scramblies {\n\tpublic static boolean scramble(String str1, String str2) {\n\t\t\n\t\tboolean flag=true;\n\t\tStringBuilder strbu2=new StringBuilder(str2);\n\t\tStringBuilder strbu1=new StringBuilder(str1);\n\t\tfor (int i = 0; i < strbu2.length(); i++) {\n\t\t\tint index=strbu1.indexOf(\"\"+strbu2.charAt(i));\n\t\t\tif(index>-1) {\n\t\t\t\tstrbu1.delete(index, index+1);\n\t\t\t}else {\n\t\t\t\tflag=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn flag;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(scramble(\"rkqodlw\", \"world\"));\n\t\tSystem.out.println(scramble(\"cedewaraaossoqqyt\", \"codewars\"));\n\t\tSystem.out.println(scramble(\"katas\", \"steak\"));\n\t\tSystem.out.println(scramble(\"scriptjavx\",\"javascript\"));//false\n\t}\n}\n\n```\n\n###### 大佬的解决方案\n\n```java\npublic class Scramblies {\n    \n    public static boolean scramble(String str1, String str2) {\n        if (str2.length() > str1.length()) return false;\n        for (String s: str2.split(\"\")) {\n          if (!str1.contains(s))  return false;\n          str1 = str1.replaceFirst(s,\"\");\n        }        \n       \n        return true;\n    }\n}\n```\n\n### 7. [Number of trailing zeros of N!](https://www.codewars.com/kata/number-of-trailing-zeros-of-n/train/java)\n\n[^时间]: 2019-10-13 周日\n\n##### 描述\n\n```\nWrite a program that will calculate the number of trailing zeros in a factorial of a given number.\n\nN! = 1 * 2 * 3 * ... * N\n\nBe careful 1000! has 2568 digits...\n\nFor more info, see: http://mathworld.wolfram.com/Factorial.html\n\nExamples\nzeros(6) = 1\n# 6! = 1 * 2 * 3 * 4 * 5 * 6 = 720 --> 1 trailing zero\n\nzeros(12) = 2\n# 12! = 479001600 --> 2 trailing zeros\nHint: You're not meant to calculate the factorial. Find another way to find the number of zeros.\n```\n\n##### 思路\n\n```\n这个题一个司马的坑！\n我一开始直接求阶乘，int变量接收阶乘，发现，超出了最大范围，即使改成long型，也是一样。\n所以就重新开始考虑\n6！=6*5*4*3*2*1=720--->1\n10!=10*9*8*7*6*5*4*3*2*1=3628800--->2\n14!=14*13*12*11*10*9*8*7*6*5*4*3*2*1=87178291200--->2\n15!=15*14*13*12*11*10*9*8*7*6*5*4*3*2*1=1307674368000--->3\n看上面的例子，是不是发现这个司马的坑了？还是这个司马作者牛逼！\n```\n\n##### 实现\n\n###### 我的解决方案\n\n```java\npublic class Solution {\n\tpublic static int zeros(int n) {\n\t\tint res=0;\n\t\tfor(int i=5;i<=n;i*=5) {\n\t\t\tres+=n/i;\n\t\t}\n\t\treturn res;\n\t}\n}\n```\n\n###### 大佬的解决方案\n\n```java\npublic class Solution {\n  public static int zeros(int n) {\n    int res = 0;\n    for (int i = 5; i <= n; i *= 5) {\n      res += n / i;\n    }\n    return res;\n  }\n}\n```\n\n### 8. [Range Extraction](https://www.codewars.com/kata/range-extraction/train/java)\n\n[^时间]: 2019-10-19 周六\n\n##### 描述\n\n```\nA format for expressing an ordered list of integers is to use a comma separated list of either\n\nindividual integers\nor a range of integers denoted by the starting integer separated from the end integer in the range by a dash, '-'. The range includes all integers in the interval including both endpoints. It is not considered a range unless it spans at least 3 numbers. For example (\"12, 13, 15-17\")\nComplete the solution so that it takes a list of integers in increasing order and returns a correctly formatted string in the range format.\n\nExample:\n\nSolution.rangeExtraction(new int[] {-6, -3, -2, -1, 0, 1, 3, 4, 5, 7, 8, 9, 10, 11, 14, 15, 17, 18, 19, 20})\n# returns \"-6,-3-1,3-5,7-11,14,15,17-20\"\n```\n\n##### 思路\n\n```\n这个题，刚开始理解的时候，有误区。以为连续的数字像3,2,1这种的也算，其实不是，只要1,2,3这种的才算连续的数字\n两个判断1.是否连续 2.连续数字是否>=3\n\n但是向上面这种思维方式，会把简单的问题复杂化。有时候，不能从传统的思维中去考虑。\n定义一个变量flag，如果连续，则加一。不连续的时候，就追加相应的数字\n```\n\n##### 实现\n\n###### 我的解决方案\n\n```java\npublic static String rangeExtraction(int[] arr) {\n\t\tString list=\"\";\n\t\tint flag=0;\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tif(i==arr.length-1||arr[i]+1!=arr[i+1]) {//前后两个数不连续的时候执行\n\t\t\t\tif(flag==0) {\n\t\t\t\t\tlist+=\" \"+arr[i];\n\t\t\t\t}else if(flag==1) {\n\t\t\t\t\tlist+=\" \"+arr[i-1];\n\t\t\t\t\tlist+=\" \"+arr[i];\n\t\t\t\t\tflag=0;\n\t\t\t\t}else if(flag>1) {\n\t\t\t\t\tlist+=\" \"+arr[i-flag]+\"-\"+arr[i];\n\t\t\t\t\tflag=0;\n\t\t\t\t}\n\t\t\t}else {//前后两个数连续的时候执行\n\t\t\t\tflag++;\n\t\t\t}\n\t\t}\n\t\treturn list.trim().replace(' ', ',');\n\t}\n```\n\n###### 大佬的解决方案\n\n```java\nstatic String rangeExtraction(final int[] array) {\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < array.length; i++) {\n            int rangeStart = array[i];\n            sb.append(rangeStart);\n            for (int j = i + 1; j <= array.length; j++) {\n                if (j == array.length || array[j] != rangeStart + (j - i)) {\n                    if (j - i >= 3) {\n                        sb.append('-').append(array[j - 1]);\n                        i = j - 1;\n                    }\n                    sb.append(',');\n                    break;\n                }\n            }\n        }\n        return sb.deleteCharAt(sb.length() - 1).toString();\n}\n```\n\n### 9. [Weight for weight](https://www.codewars.com/kata/weight-for-weight/train/java)\n\n[^时间]: 2019-10-19 周六\n\n##### 描述\n\n```\nMy friend John and I are members of the \"Fat to Fit Club (FFC)\". John is worried because each month a list with the weights of members is published and each month he is the last on the list which means he is the heaviest.\n\nI am the one who establishes the list so I told him: \"Don't worry any more, I will modify the order of the list\". It was decided to attribute a \"weight\" to numbers. The weight of a number will be from now on the sum of its digits.\n\nFor example 99 will have \"weight\" 18, 100 will have \"weight\" 1 so in the list 100 will come before 99. Given a string with the weights of FFC members in normal order can you give this string ordered by \"weights\" of these numbers?\n\nExample:\n\"56 65 74 100 99 68 86 180 90\" ordered by numbers weights becomes: \"100 180 90 56 65 74 68 86 99\"\n\nWhen two numbers have the same \"weight\", let us class them as if they were strings and not numbers: 100 is before 180 because its \"weight\" (1) is less than the one of 180 (9) and 180 is before 90 since, having the same \"weight\" (9), it comes before as a string.\n\nAll numbers in the list are positive numbers and the list can be empty.\n\nNotes\nit may happen that the input string have leading, trailing whitespaces and more than a unique whitespace between two consecutive numbers\nDon't modify the input\nFor C: The result is freed.\n```\n\n##### 思路\n\n```\n老子不会做！\n```\n\n##### 实现\n\n###### 我的解决方案\n\n```java\npublic static String orderWeight(String string) {\n\t\tArrayList<String> list=new ArrayList<String>(Arrays.asList(string.split(\" \")));\n\t\tString temp;\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\tfor(int j=0;j<list.size()-1;j++) {\n\t\t\t\tif(getWeight(list.get(j))>getWeight(list.get(j+1))) {\n\t\t\t\t\ttemp=list.get(j);\n\t\t\t\t\tlist.set(j, list.get(j+1));\n\t\t\t\t\tlist.set(j+1, temp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tString str=\"\";\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\tstr+=\" \"+list.get(i);\n\t\t}\n\t\treturn str.trim();\n\t}\n```\n\n###### 大佬的解决方案\n\n```java\npublic static String orderWeight(String string) {\n    String[] split = string.split(\" \");\n    Arrays.sort(split, new Comparator<String>() {\n      public int compare(String a, String b) {\n        int aWeight = a.chars().map(c -> Character.getNumericValue(c)).sum();\n        int bWeight = b.chars().map(c -> Character.getNumericValue(c)).sum();\n        return aWeight - bWeight != 0 ? aWeight - bWeight : a.compareTo(b);\n      }\n    });\n    return String.join(\" \", split);\n  }\n```\n\n### 10. [Is my friend cheating?](https://www.codewars.com/kata/is-my-friend-cheating/train/java)\n\n[^时间]: 2019-10-19 周六\n\n##### 描述\n\n```\nA friend of mine takes a sequence of numbers from 1 to n (where n > 0).\nWithin that sequence, he chooses two numbers, a and b.\nHe says that the product of a and b should be equal to the sum of all numbers in the sequence, excluding a and b.\nGiven a number n, could you tell me the numbers he excluded from the sequence?\nThe function takes the parameter: n (n is always strictly greater than 0) and returns an array or a string (depending on the language) of the form:\n\n[(a, b), ...] or [[a, b], ...] or {{a, b}, ...} or or [{a, b}, ...]\nwith all (a, b) which are the possible removed numbers in the sequence 1 to n.\n\n[(a, b), ...] or [[a, b], ...] or {{a, b}, ...} or ...will be sorted in increasing order of the \"a\".\n\nIt happens that there are several possible (a, b). The function returns an empty array (or an empty string) if no possible numbers are found which will prove that my friend has not told the truth! (Go: in this case return nil).\n\n(See examples of returns for each language in \"RUN SAMPLE TESTS\")\n\nExamples:\nremovNb(26) should return [(15, 21), (21, 15)]\nor\n\nremovNb(26) should return { {15, 21}, {21, 15} }\nor\n\nremoveNb(26) should return [[15, 21], [21, 15]]\nor\n\nremovNb(26) should return [ {15, 21}, {21, 15} ]\nor\n\nremovNb(26) should return \"15 21, 21 15\"\nor\n\nin C:\nremovNb(26) should return  **an array of pairs {{15, 21}{21, 15}}**\ntested by way of strings.\n```\n\n##### 思路\n\n```\n从1-n的n个数中，找到2个数a,b,使得除去a,b,剩下的数之和与a，b之积相等\n```\n\n##### 实现\n\n###### 我的解决方案\n\n```java\npackage source;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class RemovedNumbers {\n\n\t// 超时了\n//\tpublic static List<long[]> removNb(long n) {\n//\t\tList<long[]> list=new ArrayList<long[]>();\n//\t\tlong sum = n * (1 + n) / 2;\n//\t\tfor (long i = 1; i <= n; i++) {\n//\t\t\tfor (long j = 1; j <= n; j++) {\n//\t\t\t\tif(i*j==(sum-i-j))\n//\t\t\t\t\tlist.add(new long[] {\n//\t\t\t\t\t\ti,j\n//\t\t\t\t\t});\t\n//\t\t\t}\n//\t\t}\n//\t\t// your code\n//\t\treturn list;\n//\t}\n\n\tpublic static List<long[]> removNb(long n) {\n\t\tList<long[]> list = new ArrayList<>();\n\t\tlong sum = n * (1 + n) / 2;\n\t\tfor (long i = 1; i <= n; i++) {\n\t\t\tlong j = (sum - i) / (i + 1);\n\t\t\tif (j >= 1 && j <= n && i * j == (sum - i - j)) {\n\t\t\t\tlist.add(new long[] {\n\t\t\t\t\t\ti,j\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(System.in);\n\t\tint n = input.nextInt();\n\t\tSystem.out.println(removNb(n));\n\t}\n}\n\n```\n\n###### 大佬的解决方案\n\n```java\nimport java.util.LinkedList;\n\npublic class RemovedNumbers {\n  /*\n  We desire: ab = 1 + ... + n - a - b\n  Take advantage of b = sum - a\n                        -------\n                         a + 1\n  */\n  public static LinkedList<long[]> removNb(long n) {\n    LinkedList<long[]> numbers = new LinkedList<long[]>();\n    long sum = (n * n + n) / 2;\n    for (long a = 1; a < n; a++) {\n      double b = (sum - a) / (double) (a + 1);\n      if (b <= n && b % 1 == 0) {\n        numbers.add(new long[] {a, (long) b});\n      }\n    }\n    return numbers;\n  }\n}\n```\n\n我居然发现我的思路，跟大佬的思路是一样的，看来我也是大佬了，嘎嘎嘎\n\n\n\n### 11. [Longest Common Subsequence ]( https://www.codewars.com/kata/longest-common-subsequence/train/java )\n\n[^时间]: 2019-10-27 周日\n\n##### 描述\n\n```\nWrite a function called LCS that accepts two sequences and returns the longest subsequence common to the passed in sequences.\n\nSubsequence\nA subsequence is different from a substring. The terms of a subsequence need not be consecutive terms of the original sequence.\n\nExample subsequence\nSubsequences of \"abc\" = \"a\", \"b\", \"c\", \"ab\", \"ac\", \"bc\" and \"abc\".\n\nLCS examples\nSolution.lcs(\"abcdef\", \"abc\") => returns \"abc\"\nSolution.lcs(\"abcdef\", \"acf\") => returns \"acf\"\nSolution.lcs(\"132535365\", \"123456789\") => returns \"12356\"\nNotes\nBoth arguments will be strings\nReturn value must be a string\nReturn an empty string if there exists no common subsequence\nBoth arguments will have one or more characters (in JavaScript)\nAll tests will only have a single longest common subsequence. Don't worry about cases such as LCS( \"1234\", \"3412\" ), which would have two possible longest common subsequences: \"12\" and \"34\".\nNote that the Haskell variant will use randomized testing, but any longest common subsequence will be valid.\n\nNote that the OCaml variant is using generic lists instead of strings, and will also have randomized tests (any longest common subsequence will be valid).\n\nTips\nWikipedia has an explanation of the two properties that can be used to solve the problem:\n\nFirst property\nSecond property\n```\n\n##### 思路\n\n```\n这个问题，soeasy!就是两个字符串比较共有的最长的子串呗\n```\n\n##### 实现\n\n###### 我的解决方案\n\n```java\n\n```\n\n###### 大佬的解决方案\n\n```java\n\n```\n\n### 12. [Is my friend cheating?](https://www.codewars.com/kata/is-my-friend-cheating/train/java)\n\n[^时间]: 2019-10-27 周日\n\n##### 描述\n\n```\n\n```\n\n##### 思路\n\n```\n\n```\n\n##### 实现\n\n###### 我的解决方案\n\n```java\n\n```\n\n###### 大佬的解决方案\n\n```java\n\n```\n\n### 13. [Is my friend cheating?](https://www.codewars.com/kata/is-my-friend-cheating/train/java)\n\n[^时间]: 2019-10-27 周日\n\n##### 描述\n\n```\n\n```\n\n##### 思路\n\n```\n\n```\n\n##### 实现\n\n###### 我的解决方案\n\n```java\n\n```\n\n###### 大佬的解决方案\n\n```java\n\n```\n\n","tags":["algorithm"]},{"title":"接口","url":"/blog/2019/interface/","content":"\n啥是接口？你看了就懂！\n\n<!--more-->\n\n## 一、接口概述与生活举例\n\n啥是接口？不多bb，上图！\n\n{% asset_img 接口.png 接口 %}\n\n接口就是多个类的公共规范。\n\n接口是一种引用数据类型，最重要的内容就是其中的：抽象方法。\n\n## 二、接口的基本格式\n\n那么，**如何定义一个接口的格式**？\n\n```\npublic interface 接口名称 {\n//接口内容\n}\n```\n\n备注:如果换成了关键字interface之后，编译生成的字节码文件仍然是：.java --> .class\n\n如果是Java 7，那么接口中可以包含的内容有：\n\n1. 常量\n2. 抽象方法\n\n如果是Java 8，那么接口中还可以额外包含有：\n\n3. 默认方法\n4. 静态方法\n\n如果是Java 9，还可以额外包含有：\n\n5. 私有方法\n\n**接口使用步骤**\n\n1. 接口不能直接使用，必须有一个\"实现类\"来\"实现\"该接口。\n   格式：\n\n   ```\n   public class 实现类名称 implements 接口名称 {\n   //...\n   }\n   ```\n\n2. 接口的实现类必须覆盖重现（实现）接口中所有的**抽象方法**。\n   *实现：去掉abstract关键字，加上方法体大括号*\n\n3. 创建实现类对象，进行使用。\n\n\n## 三、接口的抽象方法\n\n在任何版本Java中，接口都能定义抽象方法。\n\n格式：\n\n```\npublic abstract 返回值类型 方法名称(参数列表);\n```\n\n注意事项：\n\n1. 接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract\n2. 这两个关键字修饰符，可以选择性地省略。（刚学的话，不推荐省略）\n3. 方法的三要素（方法名、参数列表、返回值），可以随意定义。\n\n如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。\n\nMyInterfaceAbstract.java\n\n```\npublic interface MyInterfaceAbstract {\n\n    // 这是一个抽象方法\n    public abstract void methodAbs1();\n\n    // 这也是抽象方法\n    abstract void methodAbs2();\n\n    // 这也是抽象方法\n    public void methodAbs3();\n\n    // 这也是抽象方法\n    void methodAbs4();\n\n}\n```\n\nMyInterfaceAbstractImpl.java\n\n```\npublic class MyInterfaceAbstractImpl implements MyInterfaceAbstract {\n    @Override\n    public void methodAbs1() {\n        System.out.println(\"这是第一个方法！\");\n    }\n\n    @Override\n    public void methodAbs2() {\n        System.out.println(\"这是第二个方法！\");\n    }\n\n    @Override\n    public void methodAbs3() {\n        System.out.println(\"这是第三个方法！\");\n    }\n\n    @Override\n    public void methodAbs4() {\n        System.out.println(\"这是第四个方法！\");\n    }\n}\n```\n\nDemo01Interface.java\n\n```\npublic class Demo01Interface {\n\n    public static void main(String[] args) {\n        // 错误写法！不能直接new接口对象使用。\n//        MyInterfaceAbstract inter = new MyInterfaceAbstract();\n\n        // 创建实现类的对象使用\n        MyInterfaceAbstractImpl impl = new MyInterfaceAbstractImpl();\n        impl.methodAbs1();\n        impl.methodAbs2();\n    }\n\n}\n```\n\n## 四、接口的默认方法\n\n从java 8开始，接口里允许默认方法\n\n格式：\n\n```\npublic default 返回值类型 方法名称(参数列表){\n//方法体\n}\n```\n\n1. 接口的默认方法，可以通过接口实现类对象，直接调用。\n2. 接口的默认方法，也可以被接口实现类进行覆盖重写。\n\n备注：接口当中的默认方法，可以解决接口升级的问题。\n\nMyInterfaceDefault.java\n\n```\npublic interface MyInterfaceDefault {\n\t//抽象方法\n\tpublic abstract void methodAbs();\n\t\n\t//新添加一个抽象方法，会导致两个实现类报错\n\t//public abstract void methodAbs2();\n\t\n\t//为了解决上面的问题，需要将新添加的方法，改成默认方法。public省略不写，也会默认为public\n\tpublic default void methodDefault() {\n\t\t//一定要将这个大括号写上\n\t\tSystem.out.println(\"这是新添加的默认方法\");\n\t}\n}\n```\n\nMyInterfaceDefaultA.java\n\n```\npublic class MyInterfaceDefaultA implements MyInterfaceDefault {\n\n\t@Override\n\tpublic void methodAbs() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"实现了抽象方法，AA\");\n\t}\n\t\n}\n\n```\n\nMyInterfaceDefaultB.java\n\n```\npublic class MyInterfaceDefaultB implements MyInterfaceDefault {\n\n\t@Override\n\tpublic void methodAbs() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"实现了抽象方法，BB\");\n\t}\n\t\n\t@Override\n\tpublic void methodDefault() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"实现类B覆盖重写了接口的默认方法\");\n\t}\n\n}\n\n```\n\nDemo02Interface.java\n\n```\npublic static void main(String[] args) {\n\t\t\n\t\t//创建实现类对象\n\t\tMyInterfaceDefaultA a=new MyInterfaceDefaultA();\n\t\ta.methodAbs();//调用抽象方法，实际运行的是右侧实现类\n\t\t\n\t\t//调用默认方法，如果实现类中没有，会向上寻找\n\t\ta.methodDefault();//这是新添加的默认方法\n\t\t\n\t\tMyInterfaceDefaultB b=new MyInterfaceDefaultB();\n\t\tb.methodAbs();\n\t\tb.methodDefault();//实现类B覆盖重写了默认方法\n\t}\n```\n\n\n\n## 五、接口的静态方法\n\n从Java 8开始，接口中允许定义静态方法。\n\n格式：\n\n```\npublic static 返回值类型 方法名称(参数列表){\n//方法体\n}\n```\n\n提示：\n\n就是将abstract或者default换成static，然后带上方法体。\n\n注意：不能通过接口实现类的对象来调用接口当中的静态方法。\n\n正确用法：直接通过接口名称调用静态方法\n\n格式：\n\n接口名称.静态方法(参数列表)\n\nMyInterfaceStatic.java\n\n```\npublic interface MyInterfaceStatic {\n\t\n\t//public 可以省略\n\tpublic static void methodStatic() {\n\t\tSystem.out.println(\"这是接口的静态方法！\");\n\t}\n}\n```\n\nMyInterfaceStaticImpl.java\n\n```\npublic class MyInterfaceStaticImpl implements MyInterfaceStatic {\n\n}\n```\n\nDemo03Interface.java\n\n```\npublic class Demo03Interface {\n\tpublic static void main(String[] args) {\n//\t\tMyInterfaceStaticImpl impl=new MyInterfaceStaticImpl();\n\t\t\n\t\t//错误写法！\n\t\t//impl.methodStatic();\n\t\t\n\t\t//直接通过接口名称调用静态方法\n\t\tMyInterfaceStatic.methodStatic();\n\t\t\n\t\t\n\t}\n}\n```\n\n\n\n## 六、接口的私有方法\n\n问题描述：\n\n*我们需要抽取一个公共方法，用来解决两个默认方法之间的重复代码的问题，但是这个共有方法不应该让实现类使用，应该是私有化的。*\n\n解决方案：\n\n从Java 9开始，接口里允许定义私有方法\n\n1. 普通私有方法，解决多个默认方法之间重复代码问题\n\n   格式：\n\n   ```\n   private 返回值类型 方法名称(参数列表){\n   //方法体\n   }\n   ```\n\n2. 静态私有方法，解决多个静态方法之间的重复代码问题\n   格式：\n\n   ```\n   private static 返回值类型 方法名称(参数列表){\n   //方法体\n   }\n   ```\n\nMyInterfacePrivateA.java\n\n```\npublic interface MyInterfacePrivateA {\n\tpublic default void methodDefault1() {\n\t\t System.out.println(\"这是默认方法1\");\n//\t\t System.out.println(\"AAA\");\n//\t\t System.out.println(\"BBB\");\n//\t\t System.out.println(\"CCC\");\n\t\t //methodCommon();\n\t\t \n\t\t methodPrivateCommon();\n\t}\n\tpublic default void methodDefault2() {\n\t\tSystem.out.println(\"这是默认方法2\");\n//\t\tSystem.out.println(\"AAA\");\n//\t\tSystem.out.println(\"BBB\");\n//\t\tSystem.out.println(\"CCC\");\n\t\t//methodCommon();\n\t\t\n\t\tmethodPrivateCommon();\n\t}\n\t//如果就像上面的一样，有重复的咋办？\n\t//像下面这样，写个方法呗？但是...\n\t\n\tpublic default void methodCommon() {\n\t\tSystem.out.println(\"AAA\");\n\t\tSystem.out.println(\"BBB\");\n\t\tSystem.out.println(\"CCC\");\n\t}\n\t\n\t//用下面这个就完美解决了\n\tprivate void methodPrivateCommon() {\n\t\tSystem.out.println(\"AAA\");\n\t\tSystem.out.println(\"BBB\");\n\t\tSystem.out.println(\"CCC\");\n\t}\n}\n```\n\nMyInterfacePrivateB.java\n\n```\npublic interface MyInterfacePrivateB {\n\tpublic static void methodStatic1() {\n\t\t System.out.println(\"这是静态方法1\");\n\t\t \n\t\t methodPrivateCommon();\n\t}\n\tpublic static void methodStatic2() {\n\t\tSystem.out.println(\"这是静态方法2\");\n\t\t\n\t\tmethodPrivateCommon();\n\t}\n\t\n\t\n\tprivate static void methodPrivateCommon() {\n\t\tSystem.out.println(\"AAA\");\n\t\tSystem.out.println(\"BBB\");\n\t\tSystem.out.println(\"CCC\");\n\t}\n}\n```\n\nMyInterfacePrivateAImpl.java\n\n```\npublic class MyInterfacePrivateAImpl implements MyInterfacePrivateA {\n\tpublic void methodAnother() {\n\t\t//methodCommon();//直接访问接口中的默认方法，但是这个不应该被访问到啊\n\t\t\n\t\t\n\t}\n}\n```\n\n\n\n## 七、接口的常量定义以及使用\n\n接口当中，也可以定义\"成员变量\"\n\n但是这个成员变量，需要public static final三个关键字进行修饰\n\n从效果上看，这就是接口的常量\n\n格式：\n\n```\npublic static final 数据类型 常量名称 = 数据值;\n```\n\n一旦使用final关键字进行修饰，说明不可改变\n\n1. 接口当中的常量，可以省略这三个关键字，但即使不写，还是默认为自带这三个关键字\n2. 接口当中的常量，必须进行赋值\n3. 接口当中的常量名称，使用完全大写，并且下划线隔开\n\nMyInterfaceConst.java\n\n```\npublic interface MyInterfaceConst {\n\t\n\t//这其实就是一个常量，一旦赋值，是不可以修改的\n\tpublic static final int NUM_OF_MY_CLASS =10;\n\t\n\t\n}\n```\n\nDemo05Interface.java\n\n```\npublic class Demo05Interface {\n\t//访问接口当中的常量\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(MyInterfaceConst.NUM_OF_MY_CLASS);\n\t}\n}\n```\n\n## 八、接口内容总结\n\n在Java 9+版本中（带有中括号表示可以省略）\n\n1. 成员变量其实是常量，格式：\n\n   ```\n   [public] [static] [final] 数据类型 常量名称 = 数据值;\n   ```\n\n   注意:\n   \t常量必须进行赋值，而且一旦赋值不能改变。\n   \t常量名称完全大写，用下划线进行分割。\n   \t\n\n2. 接口中最重要的就是抽象方法，格式：\n\n   ```\n   [public] [abstract] 返回值类型 方法名称(参数列表);\n   ```\n\n   注意：实现类必须覆盖重写接口中所有的抽象方法，除非实现类是抽象类。\n\n3. 从java 8开始，接口里允许定义默认方法，格式：\n\n   ```\n   [public] default 返回值类型 方法名称(参数列表) { 方法体 }\n   ```\n\n   注意：默认方法也可以被覆盖重写。\n\n4. 从java 8开始，接口里允许定义静态方法，格式：\n\n   ```\n   [public] static 返回值类型 方法名称(参数列表) { 方法体 }\n   ```\n\n   注意：应该通过接口名称进行调用，不能通过实现类对象调用接口静态方法\n\n5. 从java 9开始，接口里允许定义私有方法，格式：\n\n   ```\n   普通私有方法：private 返回值类型 方法名称(参数列表) { 方法体 }\n   静态私有方法：private static 返回值类型 方法名称(参数列表) { 方法体 }\n   ```\n\n   注意：private的方法只有接口自己才能调用，不能被实现类或者别人使用。\n\n## 九、使用接口时的注意事项\n\n#### 使用接口的时候，需要注意：\n\n1. 接口是没有静态代码块或者构造方法的\n\n2. 一个类的直接父类是唯一的，但是一个类可以同时实现多个接口\n   格式：\n\n   ```\n   public class MyInterfaceImpl implements MyInterfaceA,MyInterfaceB{\n   //覆盖重写所有抽象方法\n   }\n   ```\n\n3. 如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可\n\n4. 如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是抽象类\n\n5. 如果实现类实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写\n\n6. 一个类，如果直接父类当中的方法，跟接口当中继承的方法产生了冲突，优先用父类当中的方法。\n\nMyInterfaceA.java\n\n```\npublic interface MyInterfaceA {\n\tpublic abstract void methodA();\n\t\n\tpublic abstract void methodAbs();\n\t\n\tpublic default void methodDefault() {\n\t\tSystem.out.println(\"默认方法AAA\");\n\t}\n}\n```\n\nMyInterfaceB.java\n\n```\npublic interface MyInterfaceB {\n\tpublic abstract void methodB();\n\tpublic abstract void methodAbs();\n\t\n\tpublic default void methodDefault() {\n\t\tSystem.out.println(\"默认方法BBB\");\n\t}\n}\n```\n\nMyInterfaceAbstract.java\n\n```\npublic abstract class MyInterfaceAbstract implements MyInterfaceA,MyInterfaceB {\n\n\t@Override\n\tpublic void methodDefault() {\n\t\tSystem.out.println(\"不管抽不抽象，有冲突，都得重写\");\n\t}\n\t\n}\n```\n\nMyInterfacImpl.java\n\n```\npublic class MyInterfaceImpl implements MyInterfaceA,MyInterfaceB {\n\n\t@Override\n\tpublic void methodB() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"覆盖重写A接口抽象方法\");\n\t}\n\n\t@Override\n\tpublic void methodA() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"覆盖重写B接口抽象方法\");\n\t}\n\n\t@Override\n\tpublic void methodAbs() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"覆盖重写了AB接口都有的抽象方法\");\n\t}\n\n\t@Override\n\tpublic void methodDefault() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"对多个接口当中的冲突的默认方法进行覆盖重写\");\n\t}\n\t\n}\n\n```\n\nDemo01Interface.java\n\n```\npublic class Demo01Interface {\n\n}\n```\n\n#### 接口之间的多继承\n\n1. 类与类之间是单继承的。直接父类只能有一个。\n2. 类与接口直接是多实现的。一个类可以实现多个接口，有冲突需要解决。\n3. 接口与接口之间是多继承的。\n\n注意事项：\n\n1. 多个父接口当中的抽象方法如果重复，没关系\n2. 多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，而且带着default关键字。","tags":["java"]},{"title":"java的一些盲点","url":"/blog/2019/jdk/","content":"\n刚入门java，好多地方得弄明白。\n\n<!--more-->\n\n## 一、jre与jdk\n\n**JRE： Java Runtime Environment**\n**JDK：Java Development Kit** \n\n* JRE顾名思义是java运行时环境，包含了java虚拟机，java基础类库。是使用java语言编写的程序运行所需要的软件环境，是提供给想运行java程序的用户使用的。\n* JDK顾名思义是java开发工具包，是程序员使用java语言编写java程序所需的开发工具包，是提供给程序员使用的。JDK包含了JRE，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具：jconsole，jvisualvm等工具软件，还包含了java程序编写所需的文档和demo\n\n在运行jar的时候，运行的电脑上是需要有相应的运行环境，也就是jre才可以。比方说我的服务器是jre8，而我的项目生成的jre需要12，这是就会报错，运行的版本过低的错误。\n\n现在官网提供的[jre](https://www.java.com/zh_CN/download/win10.jsp)也只是8的，因为新版本的jdk中，内置了jre，也就是jdk跟jre是放一块的了。\n\n[具体的操作](https://blog.csdn.net/InsideMao/article/details/95940439)\n\n1. 进入命令控制台（必须使用管理员权限，否则报错\n\n2. 进入jdk的bin目录，执行下面的命令\n\n   ```java\n   jlink.exe --module-path jmods --add-modules java.desktop --output jre\n   ```\n\n就可以生成jre了。\n\n> 有的是在jdk根目录下生成，有的是在bin目录下，看具体情况\n\n查看jre的版本\n\n```java\njava -version\n```\n\n查看jdk的版本\n\n```java\njavac -version\n```\n\n## 二、java 1-12 新特性\n\n{% asset_img jdk新特性.png jdk新特性 %}","tags":["java"]},{"title":"java设计模式","url":"/blog/2019/java-design-model/","content":"\n学习一下java的设计模式\n\n<!--more-->\n\n## 需求\n\n点披萨，可以点不同种类的披萨\n\n比方说奶酪披萨，希腊披萨等等\n\n然后有披萨的准备过程，烘烤过程，切片过程，打包过程\n\n\n\n## 一、传统模式\n\n * 传统的方式\n * 优点：比较好理解，简单易操作\n * 缺点：违反了设计模式的ocp原则，即对扩展开放，对修改关闭。\n * 即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少得修改代码\n * 比如，我要新增加一个pizza种类，需要在OrderPizza里面再加一个elseif，这样并不好\n\n类图：\n\n{% asset_img 传统模式-类图.png 传统模式的类图 %}\n\nPizza.java\n\n```java\npackage factory.pizza;\n\n/*\n * 将Pizza做成抽象方法\n */\npublic abstract class Pizza {\n\tprivate String name;\n\n\t// 准备原材料，不同的披萨，原材料是不一样的。因此，我们做成抽象方法\n\tpublic abstract void prepare();\n\n\tpublic void bake() {\n\t\tSystem.out.println(name + \" baking;\");\n\t}\n\n\tpublic void cut() {\n\t\tSystem.out.println(name + \" cutting;\");\n\t}\n\n\tpublic void box() {\n\t\tSystem.out.println(name + \" boxing;\");\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n}\n\n```\n\nCheesePizza.java\n\n```java\npackage factory.pizza;\n\npublic class CheesePizza extends Pizza {\n\n\t@Override\n\tpublic void prepare() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"给制作CheesePizza准备原材料 \");\n\t}\n\n}\n\n```\n\nGreekPizza.java\n\n```java\npackage factory.pizza;\n\npublic class GreekPizza extends Pizza {\n\n\t@Override\n\tpublic void prepare() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"给制作GreekPizza准备原材料\");\n\t}\n\n}\n\n```\n\nOrderPizza.java\n\n```java\npackage factory.order;\n\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nimport factory.pizza.CheesePizza;\nimport factory.pizza.GreekPizza;\nimport factory.pizza.Pizza;\n\npublic class OrderPizza {\n\t//构造方法、构造器\n\t//下面是传统方式，注释掉\n\tpublic OrderPizza() {\n\t\tPizza pizza=null;\n\t\tString orderType;//订购pizza的类型\n\t\tdo {\n\t\t\torderType=getType();\n\t\t\tif(orderType.equals(\"greek\")) {\n\t\t\t\tpizza=new GreekPizza();\n\t\t\t\tpizza.setName(\"GreekPizza\");\n\t\t\t}else if(orderType.equals(\"cheese\")) {\n\t\t\t\tpizza=new CheesePizza();\n\t\t\t\tpizza.setName(\"CheesePizza\");\n\t\t\t}else {\n\t\t\t\tSystem.out.println(\"俺们家不做这个pizza，请去其他商店\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//输出pizza，制作过程\n\t\t\tpizza.prepare();\n\t\t\tpizza.bake();\n\t\t\tpizza.cut();\n\t\t\tpizza.box();\n\t\t}while(true);\n\t}\n\t\n\t\n\t//写一个方法,可以动态获取pizza类型\n\tpublic String getType() {\n\t\tBufferedReader input=new BufferedReader(new InputStreamReader(System.in));\n\t\tSystem.out.println(\"Please input pizza type:\");\n\t\tString type;\n\t\ttry {\n\t\t\ttype = input.readLine();\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t\treturn \"\";\n\t\t}\n\t\treturn type;\n\t}\n}\n\n```\n\nPizzaStore.java\n\n```java\npackage factory.order;\n\n//相当于一个客户端，发出订购任务\npublic class PizzaStore {\n\tpublic static void main(String[] args) {\n\t\tnew OrderPizza();\n\t}\n\t\n}\n\n```\n\n运行结果\n\n{% asset_img 传统模式-运行结果.png 传统模式下的运行结果 %}\n\n## 二、简单（静态）工厂模式\n\n * 简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。\n * 简单工厂模式是工厂模式家族中最简单实用的模式\n * 简单工厂模式:定义了一个创建对象的类，由这个类来封装实例化对象的行为(代码)\n\n类图\n\n{% asset_img 简单工厂模式-类图.png 简单工厂模式的类图 %}\n\nPizza.java&&GreekPizza.java&&CheesePizza.java\n\n```java\n同传统模式\n```\n\nChinese.java\n\n```java\npackage factory.pizza;\n\npublic class ChinesePizza extends Pizza {\n\n\t@Override\n\tpublic void prepare() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"给制作GreekPizza准备原材料\");\n\t}\n\n}\n\n```\n\nOrderPizza2.java\n\n```java\npackage factory.order;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport factory.pizza.Pizza;\n\npublic class OrderPizza2 {\n\n\t// 定义一个简单工厂对象\n\tSimpleFactory simpleFactory;\n\tPizza pizza = null;\n\t\n\t//构造方法\n\tpublic OrderPizza2() {\n\t\tString orderType = \"\";// 用户输入的\n\t\tdo {\n\t\t\torderType = getType();\n\t\t\tpizza = SimpleFactory.createPizza(orderType);\n\n\t\t\t// 输出pizza\n\t\t\tif (pizza != null) {\n\t\t\t\tpizza.prepare();\n\t\t\t\tpizza.bake();\n\t\t\t\tpizza.cut();\n\t\t\t\tpizza.box();\n\t\t\t}else {\n\t\t\t\tSystem.out.println(\"订购披萨失败\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (true);\n\t}\n\t// 写一个方法,可以动态获取pizza类型\n\tpublic String getType() {\n\t\tBufferedReader input = new BufferedReader(new InputStreamReader(System.in));\n\t\tSystem.out.println(\"Please input pizza type:\");\n\t\tString type;\n\t\ttry {\n\t\t\ttype = input.readLine();\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t\treturn \"\";\n\t\t}\n\t\treturn type;\n\t}\n}\n\n```\n\nSimpleFactory.java\n\n```java\npackage factory.order;\n\nimport factory.pizza.CheesePizza;\nimport factory.pizza.ChinesePizza;\nimport factory.pizza.GreekPizza;\nimport factory.pizza.Pizza;\n\n/*\n * 简单(静态)工厂类\n * 也叫静态工厂模式，需要把方法改成static,这样这个方法就直接可以通过类名调用了\n */\npublic class SimpleFactory {\n\t\n\t//根据orderType返回对应的Pizza对象\n\tpublic static Pizza createPizza(String orderType) {\n\t\tSystem.out.println(\"使用简单工厂模式\");\n\t\tPizza pizza=null;\n\t\tif(orderType.equals(\"greek\")) {\n\t\t\tpizza=new GreekPizza();\n\t\t\tpizza.setName(\"GreekPizza\");\n\t\t}else if(orderType.equals(\"cheese\")) {\n\t\t\tpizza=new CheesePizza();\n\t\t\tpizza.setName(\"CheesePizza\");\n\t\t}else if(orderType.equals(\"chinese\")) {\n\t\t\tpizza=new ChinesePizza();\n\t\t\tpizza.setName(\"ChinesePizza\");\n\t\t}\n\t\treturn pizza;\n\t}\n}\n\n```\n\nPizzaStore.java\n\n```java\npublic class PizzaStore {\n\tpublic static void main(String[] args) {\n//\t\tnew OrderPizza();\n\t\t//使用简单工厂模式\n//\t\tnew OrderPizza(new SimpleFactory());\n\t\t//使用静态工厂模式，其实也是简单工厂，只不过方法是静态的\n\t\tnew OrderPizza2();\n\t\tSystem.out.println(\"退出程序，爱你么么哒❤❤\");\n\t}\n\t\n}\n```\n\n运行结果\n\n{% asset_img 简单工厂模式-运行结果.png 简单工厂模式-运行结果 %}\n\n## 新需求\n\n客户在点披萨的时候，可以点不同口味的披萨\n\n比方说：`北京`的`奶酪`披萨，`伦敦`的`胡椒`披萨\n\n**思路1：**\n\n使用简单工厂模式，创建不同的简单工厂类，BJPizzaSimpleFactory,LDPizzaSimpleFactory等等\n\n但是考虑到项目的规模，以及软件的可维护性、可扩展性并不是特别好\n\n**思路2：**\n\n使用工厂方法模式\n\n工厂方法模式——定义一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。\n\n## 三、工厂方法模式\n\n类图\n\n{% asset_img 工厂方法模式-类图.png 工厂方法模式-类图 %}\n\nPizza.java\n\n```java\npackage factory.factoryMethod.pizzaStore.pizza;\n\n/*\n * 将Pizza做成抽象方法\n */\npublic abstract class Pizza {\n\tprivate String name;\n\n\t// 准备原材料，不同的披萨，原材料是不一样的。因此，我们做成抽象方法\n\tpublic abstract void prepare();\n\n\tpublic void bake() {\n\t\tSystem.out.println(name + \" baking;\");\n\t}\n\n\tpublic void cut() {\n\t\tSystem.out.println(name + \" cutting;\");\n\t}\n\n\tpublic void box() {\n\t\tSystem.out.println(name + \" boxing;\");\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n}\n\n```\n\nBJCheesePizza.java\n\n```java\npackage factory.factoryMethod.pizzaStore.pizza;\n\npublic class BJCheesePizza extends Pizza {\n\n\t@Override\n\tpublic void prepare() {\n\t\t// TODO Auto-generated method stub\n\t\tsetName(\"BJCheesePizza\");\n\t\tSystem.out.println(\"BJCheesePizza准备原材料\");\n\t}\n\n}\n\n```\n\nBJPepperPizza.java\n\n```java\npackage factory.factoryMethod.pizzaStore.pizza;\n\npublic class BJPepperPizza extends Pizza {\n\n\t@Override\n\tpublic void prepare() {\n\t\t// TODO Auto-generated method stub\n\t\tsetName(\"BJPepperPizza\");\n\t\tSystem.out.println(\"BJPepperPizza准备原材料\");\n\t}\n\n}\n\n```\n\nLDCheesePizza.java\n\n```java\npackage factory.factoryMethod.pizzaStore.pizza;\n\npublic class LDCheesePizza extends Pizza {\n\n\t@Override\n\tpublic void prepare() {\n\t\t// TODO Auto-generated method stub\n\t\tsetName(\"LDCheesePizza\");\n\t\tSystem.out.println(\"LDCheesePizza准备原材料\");\n\t}\n\n}\n\n```\n\nLDPepperPizza.java\n\n```java\npackage factory.factoryMethod.pizzaStore.pizza;\n\npublic class LDPepperPizza extends Pizza {\n\n\t@Override\n\tpublic void prepare() {\n\t\t// TODO Auto-generated method stub\n\t\tsetName(\"LDPepperPizza\");\n\t\tSystem.out.println(\"LDPepperPizza准备原材料\");\n\t}\n\n}\n```\n\nOrderPizza.java\n\n```java\npackage factory.factoryMethod.pizzaStore.order;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nimport factory.factoryMethod.pizzaStore.pizza.Pizza;\n\npublic abstract class OrderPizza {\n\t// 定义一个抽象方法，createPizza，让各个工厂子类，自己实现\n\tabstract Pizza createPizza(String orderType);\n\n\t// 构造方法\n\tpublic OrderPizza() {\n\t\tPizza pizza = null;\n\t\tString orderType = null;\n\t\tdo {\n\t\t\torderType = getType();\n\t\t\tpizza = createPizza(orderType);//抽象方法由工厂子类完成\n\t\t\tif(pizza==null)\n\t\t\t\tbreak;\n\t\t\tpizza.prepare();\n\t\t\tpizza.bake();\n\t\t\tpizza.cut();\n\t\t\tpizza.box();\n\t\t\tSystem.out.println(\"披萨已送到你家！！\");\n\t\t\tSystem.out.println();\n\t\t} while (true);\n\t}\n\n\t// 从键盘输入中获取披萨类型\n\tpublic String getType() {\n\t\tBufferedReader input = new BufferedReader(new InputStreamReader(System.in));\n\t\tString orderType;\n\t\tSystem.out.println(\"Please input pizza's type:\");\n\t\ttry {\n\t\t\torderType = input.readLine();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn \"\";\n\t\t}\n\t\treturn orderType;\n\n\t}\n}\n\n```\n\n\n\nBJOrderPizza.java\n\n```java\npackage factory.factoryMethod.pizzaStore.order;\n\nimport factory.factoryMethod.pizzaStore.pizza.BJCheesePizza;\nimport factory.factoryMethod.pizzaStore.pizza.BJPepperPizza;\nimport factory.factoryMethod.pizzaStore.pizza.Pizza;\n\npublic class BJOrderPizza extends OrderPizza {\n\n\t@Override\n\tPizza createPizza(String orderType) {\n\t\t// TODO Auto-generated method stub\n\t\tPizza pizza=null;\n\t\tif(orderType.equals(\"cheese\")) {\n\t\t\tpizza=new BJCheesePizza();\n\t\t}else if(orderType.equals(\"pepper\")) {\n\t\t\tpizza=new BJPepperPizza();\n\t\t}\n\t\treturn pizza;\n\t}\n\n}\n\n```\n\nLDOrderPizza.java\n\n```java\npackage factory.factoryMethod.pizzaStore.order;\n\nimport factory.factoryMethod.pizzaStore.pizza.LDCheesePizza;\nimport factory.factoryMethod.pizzaStore.pizza.LDPepperPizza;\nimport factory.factoryMethod.pizzaStore.pizza.Pizza;\n\npublic class LDOrderPizza extends OrderPizza {\n\n\t@Override\n\tPizza createPizza(String orderType) {\n\t\t// TODO Auto-generated method stub\n\t\tPizza pizza=null;\n\t\tif(orderType.equals(\"cheese\")) {\n\t\t\tpizza=new LDCheesePizza();\n\t\t}else if(orderType.equals(\"pepper\")) {\n\t\t\tpizza=new LDPepperPizza();\n\t\t}\n\t\treturn pizza;\n\t}\n\n}\n\n```\n\n运行结果\n\n{% asset_img 工厂方法模式-运行结果.png 工厂方法模式-运行结果 %}\n\n## 四、抽象工厂模式\n\n基本介绍\n\n* 抽象工厂模式：定义了一个`interface`用于创建相关或有依赖关系的对象簇，而无需指明具体的类\n* 抽象工厂模式可以将`简单工厂模式`和`工厂方法模式`进行整合\n* 从设计层面看，抽象工厂模式就是对简单工厂模式的改进（或者称为进一步的抽象)\n* 将工厂抽象成两层，`AbsFactory(抽象工厂)`和`具体实现的工厂子类`。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更有利于代码的维护和扩展。\n\n类图\n\n{% asset_img 抽象工厂模式-类图.png 抽象工厂模式-类图 %}\n\nPizza.java、BJCheesePizza.java、BJPepperPizza.java、LDCheesePizza.java、LDPepperPizza.java\n\n```java\n同工厂方法模式\n```\n\nAbsFactory.java\n\n```java\npackage factory.abstractFactory.pizzaStore.order;\n\nimport factory.abstractFactory.pizzaStore.pizza.Pizza;\n\n//抽象工厂模式的抽象层\npublic interface AbsFactory {\n\t//让下面的子类具体实现\n\tpublic Pizza createPizza(String orderType);\n}\n\n```\n\nBJFactory.java\n\n```java\npackage factory.abstractFactory.pizzaStore.order;\n\nimport factory.abstractFactory.pizzaStore.pizza.BJCheesePizza;\nimport factory.abstractFactory.pizzaStore.pizza.BJPepperPizza;\nimport factory.abstractFactory.pizzaStore.pizza.Pizza;\n\n//这是一个工厂子类\npublic class BJFactory implements AbsFactory {\n\n\t@Override\n\tpublic Pizza createPizza(String orderType) {\n\t\t// TODO Auto-generated method stub\n\t\tPizza pizza=null;\n\t\tif(orderType.equals(\"cheese\")) {\n\t\t\tpizza=new BJCheesePizza();\n\t\t}else if(orderType.equals(\"pepper\")) {\n\t\t\tpizza=new BJPepperPizza();\n\t\t}\n\t\treturn pizza;\n\t}\n\n}\n\n```\n\nLDFactory.java\n\n```java\npackage factory.abstractFactory.pizzaStore.order;\n\nimport factory.abstractFactory.pizzaStore.pizza.LDCheesePizza;\nimport factory.abstractFactory.pizzaStore.pizza.LDPepperPizza;\nimport factory.abstractFactory.pizzaStore.pizza.Pizza;\n\npublic class LDFactory implements AbsFactory {\n\n\t@Override\n\tpublic Pizza createPizza(String orderType) {\n\t\t// TODO Auto-generated method stub\n\t\tPizza pizza=null;\n\t\tif(orderType.equals(\"cheese\")) {\n\t\t\tpizza=new LDCheesePizza();\n\t\t}else if(orderType.equals(\"pepper\")) {\n\t\t\tpizza=new LDPepperPizza();\n\t\t}\n\t\treturn pizza;\n\t}\n\n}\n\n```\n\nOrderPizza.java\n\n```java\npackage factory.abstractFactory.pizzaStore.order;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nimport factory.abstractFactory.pizzaStore.pizza.Pizza;\n\npublic class OrderPizza {\n\tAbsFactory absFactory;\n\n\n\t//absFactory可以是北京的，也可以是伦敦的\n\tpublic void setAbsFactory(AbsFactory absFactory) {\n\t\tPizza pizza=null;\n\t\tString orderType;\n\t\tthis.absFactory=absFactory;\n\t\tdo {\n\t\t\torderType=getType();\n\t\t\tpizza=absFactory.createPizza(orderType);\n\t\t\tif(pizza==null) {\n\t\t\t\tSystem.out.println(\"俺家不做这个披萨哦，请去别家吧❤❤\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpizza.prepare();\n\t\t\tpizza.bake();\n\t\t\tpizza.cut();\n\t\t\tpizza.box();\n\t\t\tSystem.out.println(\"您订购的Pizza已经在路上了哟❤❤\");\n\t\t\tSystem.out.println();\n\t\t}while(true);\n\t}\n\tpublic String getType() {\n\t\tString orderType;\n\t\tBufferedReader input=new BufferedReader(new InputStreamReader(System.in));\n\t\tSystem.out.println(\"Please input pizza's type: pepper or cheese\");\n\t\ttry {\n\t\t\torderType=input.readLine();\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t\torderType=\"\";\n\t\t}\n\t\treturn orderType;\n\t}\n}\n\n```\n\nPizzaStore.java\n\n```java\npackage factory.abstractFactory.pizzaStore.order;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class PizzaStore {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader input = new BufferedReader(new InputStreamReader(System.in));\n\t\tSystem.out.println(\"Please input pizza's location:Beijing or London\");\n\t\tString loc;\n\t\ttry {\n\t\t\tloc = input.readLine();\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t\tloc=\"\";\n\t\t}\n\t\tif(loc.equals(\"Beijing\")) {\n\t\t\tnew OrderPizza().setAbsFactory(new BJFactory());\n\t\t}else if(loc.equals(\"London\")) {\n\t\t\tnew OrderPizza().setAbsFactory(new LDFactory());\n\t\t}\n\t\tSystem.out.println(\"欢迎下次使用，爱你么么哒❤❤\");\n\t}\n}\n\n```\n\n运行结果\n\n{% asset_img 抽象工厂模式-运行结果.png 抽象工厂模式-运行结果 %}","tags":["java","design-model"]},{"title":"Java DataBase Connectivity","url":"/blog/2020/java-database-connectivity/","content":"\n\n老师上课讲jdbc的时候，发给我们一套连接数据库的代码。很快就讲完了，我们也能直接就拿来做个简单的管理系统了。但是，其中的很多小细节，都没深入去了解。今天就来整起。\n\n<!--more-->\n\n最近一直在看数学跟英语，好久没碰电脑了。这次尝试用idea，并且破解了永久版本，使用起来，跟eclipse相比，太好用啦！\n\n今天晚上竟然刷了半个多小时的吴京的[采访视频](https://www.bilibili.com/video/BV1bx411p7np/?p=2&t=584)，我也是醉咯！不过吴京这人还挺有意思。\n\n先附上java中jar包的maven仓库的国内镜像[下载地址]( https://mvnrepository.com/ )，关于JDBC也发现了一个比较好的[教程网站](https://how2j.cn/k/jdbc/jdbc-connection-pool/610.html#step2655)\n\n# 一、了解JDBC\n\n概念：Java DataBase Connectivity即java数据库连接，java语言操作数据库\n\n本质：官方（Sun）公司定义的一套操作所有关系型数据库的规则，即接口。然后各个数据库厂商去实现这套接口，提供数据库驱动jar包，开发者可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类\n\n{% asset_img 1.png jdbc理解 %}\n\n# 二、入门JDBC\n\n> 下面这就是上课时我们所用到的代码，拿来就用。具体为什么要这么用，我也不知道，老师也说不用知道，都是这个套路。\n>\n> google一下，发现网上的教程，比老师讲得清楚明了\n\n步骤\n\n1. 导入驱动jar包\n2. 注册驱动\n3. 获取数据库连接对象（Connection）\n4. 定义sql\n5. 获取执行sql语句的对象（Statement）\n6. 执行sql，接收返回的结果\n7. 处理结果\n8. 释放资源\n\n代码\n\n```java\npublic class Demo01JDBC {\n\tpublic static void main(String[] args) throws Exception {\n\t\t//1.导入驱动jar包\n\t\t//2.注册驱动\n\t\t//如果mysql数据库是5+\n//\t\tClass.forName(\"com.mysql.jdbc.Driver\");\n\t\t//如果mysql数据库是8+,并且，mysql5之后，是可以省略注册驱动这一代码的，jar包里面是带有自动注册的代码的\n\t\tClass.forName(\"com.mysql.cj.jdbc.Driver\");\n\t\t//3.获取数据库的连接对象，如果中途报错timezone的话，可以设置统一时区，UTC时间跟北京时间相差8小时\n\t\tConnection conn=DriverManager.getConnection(\"jdbc:mysql://localhost:3306/beauty?useUnicode=true&characterEncoding=UTF-8&serverTimezone=UTC\",\"root\",\"13838385638\");\n\t\t//4.定义sql语句\n\t\tString sql=\"select * from memeber\";\n\t\t//5.获取执行sql的对象\n\t\tStatement stmt=conn.createStatement();\n\t\t//6.执行sql\n\t\tResultSet rs=stmt.executeQuery(sql);\n\t\t//7.处理结果\n\t\twhile(rs.next()) {\n\t\t\tString name=rs.getString(\"name\");\n\t\t\tString gender=rs.getString(\"gender\");\n\t\t\tSystem.out.println(name+\"->\"+gender);\n\t\t}\n\t\t//8.释放资源\n\t\tstmt.close();\n\t\tconn.close();\n\t}\n}\n```\n\n{% asset_img 2.png 结果 %}\n\n# 三、详解JDBC\n\n## 3.1 DriverManager：驱动管理对象\n\n功能\n\n1. 注册驱动\n2. 获取数据库连接\n\n### 注册驱动\n\n注册驱动：告诉程序使用哪一个数据库驱动jar，[讲解](https://www.runoob.com/w3cnote/java-class-forname.html)\n\n在DriverManager里面，有这样一个方法\n\n```java\nstatic void\tregisterDriver (Driver driver)\t\n//Registers the given driver with the DriverManager.\n```\n\nClass.forName(\"全类名\")，在源代码阶段，将字节码文件加载进内存，并返回类对象，当然，这个是没有接收的。\n\n通过查看源码，发现在`com.mysql.cj.jdbc.Driver`类中，调用了静态代码块\n\n```java\nstatic {\n    try {\n        java.sql.DriverManager.registerDriver(new Driver());\n    } catch (SQLException E) {\n        throw new RuntimeException(\"Can't register driver!\");\n    }\n}\n```\n\n> mysql5之后的版本可以省略注册驱动\n\n也就是说，我们其实可以直接使用`DriverManager.registerDriver(new Driver())`来代替`Class.forName(\"xxx\")`;\n\n### 获取数据库连接对象\n\n在DriverManager里面有这样一个方法\n\n```java\n/*\n* @param url 指定连接的路径\n* jdbc:mysql://ip地址（域名）:端口号/数据库名称\n* 如果连接的是本机的mysql服务器，并且mysql服务默认端口是3306，则url可以简写为jdbc:mysql:///数据库名称\n* @param 用户名\n* @param 密码\n* @return 返回Connection对象\n*/\npublic static Connection getConnection(String url,\n        String user, String password)\n```\n\n## 3.2 Connection：数据库连接对象\n\n功能\n\n1. 获取执行sql的对象\n2. 管理事务\n\n### 获取执行sql的对象\n\nConnection中有两个这样的方法\n\n```java\n\nStatement createStatement();\n\nPreparedStatement prepareStatement(String sql);\n```\n\n### 管理事务\n\n开启事务\n\n```java\n//传入false，即开启了手动提交\nvoid setAutoCommit(boolean autoCommit);\n```\n\n提交事务\n\n```java\nvoid commit()\n```\n\n回滚事务\n\n```java\nvoid rollback()\n```\n\n## 3.3 Statement：执行sql对象\n\n### 执行sql\n\n```java\n//可以执行任意的sql，但是不常用\n//若返回true,则表示结果是一个结果集；若false，表示修改数或没有结果\nboolean execute(String sql);\n//执行DDL和DML语句，也就是对库和表进行操作的\n//@return 影响的行数\nint executeUpdate(String sql);\n//执行DQL语句\n//@return 结果集\nResultSet executeQuery(String sql);\n```\n\n### 练习\n\n添加记录\n\n```java\npublic class Demo02JDBC {\n\tpublic static void main(String[] args) {\n\t\tConnection conn=null;\n\t\tStatement stmt=null;\n\t\ttry {\n\t\t\t//1.注册驱动\n\t\t\tClass.forName(\"com.mysql.cj.jdbc.Driver\");\n\t\t\t//2.定义sql\n\t\t\tString sql=\"insert into memeber(name,gender,age,grade,p_id) values('武当陈师行','男',40,100,1)\";\n\t\t\t//3.获取Connection对象\n\t\t\tconn=DriverManager.getConnection(\"jdbc:mysql:///beauty?serverTimezone=UTC\", \"root\", \"13838385638\");\n\t\t\t//4.获取执行sql的对象\n\t\t\tstmt=conn.createStatement();\n\t\t\t//5.执行sql\n\t\t\tint count=stmt.executeUpdate(sql);\n\t\t\t//6.打印结果\n\t\t\tif(count>0) {\n\t\t\t\tSystem.out.println(\"添加成功\");\n\t\t\t}else {\n\t\t\t\tSystem.out.println(\"添加失败\");\n\t\t\t}\n\t\t\t//7.释放资源\n\t\t\tstmt.close();\n\t\t\tconn.close();\n\t\t} catch (ClassNotFoundException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (SQLException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\t//如果在执行getConnection的时候，就报错了，那么返回的对象就是空了\n\t\t\t//避免空指针异常\n\t\t\tif(stmt!=null) {\n\t\t\t\ttry {\n\t\t\t\t\tstmt.close();\n\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(conn!=null) {\n\t\t\t\ttry {\n\t\t\t\t\tconn.close();\n\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n修改记录\n\n```java\npublic class Demo03JDBC {\n\tpublic static void main(String[] args) {\n\t\tConnection conn=null;\n\t\tStatement stmt=null;\n\t\ttry {\n\t\t\t//1.注册驱动\n\t\t\tClass.forName(\"com.mysql.cj.jdbc.Driver\");\n\t\t\t//2.获取连接对象\n\t\t\tconn=DriverManager.getConnection(\"jdbc:mysql:///beauty?serverTimezone=UTC\", \"root\", \"13838385638\");\n\t\t\t//3.定义sql\n\t\t\tString sql=\"update memeber set grade=99 where id=2\";\n\t\t\t//4.获取执行sql的对象\n\t\t\tstmt=conn.createStatement();\n\t\t\t//5.执行sql\n\t\t\tint count=stmt.executeUpdate(sql);\n\t\t\t//6.输出结果\n\t\t\tif(count>0) {\n\t\t\t\tSystem.out.println(\"修改成功\");\n\t\t\t}else {\n\t\t\t\tSystem.out.println(\"修改失败\");\n\t\t\t}\n\t\t} catch (ClassNotFoundException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (SQLException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tif(stmt!=null) {\n\t\t\t\ttry {\n\t\t\t\t\tstmt.close();\n\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(conn!=null) {\n\t\t\t\ttry {\n\t\t\t\t\tconn.close();\n\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n删除记录\n\n```java\npublic class Demo04JDBC {\n\tpublic static void main(String[] args) {\n\t\tConnection conn = null;\n\t\tStatement stmt = null;\n\t\ttry {\n\t\t\t// 1.注册驱动\n\t\t\tClass.forName(\"com.mysql.cj.jdbc.Driver\");\n\t\t\t// 2.定义删除的sql语句\n\t\t\tString sql = \"delete from memeber where name='武当陈师行'\";\n\t\t\t// 3.获取连接对象\n\t\t\tconn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/beauty?serverTimezone=UTC\", \"root\",\n\t\t\t\t\t\"13838385638\");\n\t\t\t// 4.获取执行sql的对象\n\t\t\tstmt = conn.createStatement();\n\t\t\t// 5.执行sql语句\n\t\t\tint count = stmt.executeUpdate(sql);\n\t\t\t// 6.运行结果\n\t\t\tif (count > 0) {\n\t\t\t\tSystem.out.println(\"删除成功\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"删除失败\");\n\t\t\t}\n\t\t} catch (ClassNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\t// 避免空指针异常\n\t\t\tif (stmt != null) {\n\t\t\t\ttry {\n\t\t\t\t\tstmt.close();\n\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (conn != null) {\n\t\t\t\ttry {\n\t\t\t\t\tconn.close();\n\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n## 3.4 ResultSet：结果集\n\n### 使用\n\n1. next()：游标向下移动一行，并返回boolean类型值。向下移动，若有数据，则是true，否则为false\n2. getxxx(参数)：获取数据。\n   * xxx代表数据类型。\n   * 参数可以接收int，表示列的编号，从1开始，不是0，特殊。\n   * 参数可以接受String，表示列名称。\n\n使用步骤：\n\n1. 游标向下移动一行\n2. 判断是否有数据\n3. 获取数据\n\n```java\npublic class Demo05JDBC {\n\tpublic static void main(String[] args) {\n\t\tConnection conn = null;\n\t\tStatement stmt = null;\n\t\ttry {\n\t\t\t// 1.注册驱动\n\t\t\tClass.forName(\"com.mysql.cj.jdbc.Driver\");\n\t\t\t// 2.定义删除的sql语句\n\t\t\tString sql = \"select * from memeber\";\n\t\t\t// 3.获取连接对象\n\t\t\tconn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/beauty?serverTimezone=UTC\", \"root\",\n\t\t\t\t\t\"13838385638\");\n\t\t\t// 4.获取执行sql的对象\n\t\t\tstmt = conn.createStatement();\n\t\t\t// 5.执行sql语句\n\t\t\tResultSet rs = stmt.executeQuery(sql);\n\t\t\t// 6.运行结果\n//\t\t\t//6.1 让游标从标题栏移到第一行\n//\t\t\trs.next();\n//\t\t\t//6.2 获取数据\n//\t\t\tSystem.out.println(rs.getString(\"name\")+\" \"+rs.getString(\"gender\"));\n\t\t\twhile (rs.next()) {\n\t\t\t\tSystem.out.println(rs.getString(\"name\") + \" \" + rs.getString(\"gender\"));\n\t\t\t}\n\t\t} catch (ClassNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\t// 避免空指针异常\n\t\t\tif (stmt != null) {\n\t\t\t\ttry {\n\t\t\t\t\tstmt.close();\n\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (conn != null) {\n\t\t\t\ttry {\n\t\t\t\t\tconn.close();\n\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n### 查询练习\n\n定义一个方法，查询emp表的数据，将其封装为对象，装载集合，返回\n\n#### 初版本\n\nEmp.java\n\n```java\n/**\n * 封装Emp表的JavaBean\n * @author kit chen\n *\n */\npublic class Emp {\n\tprivate int id;\n\tprivate String ename;\n\tprivate int job_id;\n\tprivate int mgr;\n\tprivate Date joindate;\n\tprivate double salary;\n\tprivate double bonus;\n\tprivate int dept_id;\n\t\n\tpublic int getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(int id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic String getEname() {\n\t\treturn ename;\n\t}\n\n\tpublic void setEname(String ename) {\n\t\tthis.ename = ename;\n\t}\n\n\tpublic int getJob_id() {\n\t\treturn job_id;\n\t}\n\n\tpublic void setJob_id(int job_id) {\n\t\tthis.job_id = job_id;\n\t}\n\n\tpublic int getMgr() {\n\t\treturn mgr;\n\t}\n\n\tpublic void setMgr(int mgr) {\n\t\tthis.mgr = mgr;\n\t}\n\n\tpublic Date getJoindate() {\n\t\treturn joindate;\n\t}\n\n\tpublic void setJoindate(Date joindate) {\n\t\tthis.joindate = joindate;\n\t}\n\n\tpublic double getSalary() {\n\t\treturn salary;\n\t}\n\n\tpublic void setSalary(double salary) {\n\t\tthis.salary = salary;\n\t}\n\n\tpublic double getBonus() {\n\t\treturn bonus;\n\t}\n\n\tpublic void setBonus(double bonus) {\n\t\tthis.bonus = bonus;\n\t}\n\n\tpublic int getDept_id() {\n\t\treturn dept_id;\n\t}\n\n\tpublic void setDept_id(int dept_id) {\n\t\tthis.dept_id = dept_id;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Emp {id=\" + id + \", ename=\" + ename + \", job_id=\" + job_id + \", mgr=\" + mgr + \", joindate=\" + joindate\n\t\t\t\t+ \", salary=\" + salary + \", bonus=\" + bonus + \", dept_id=\" + dept_id + \"}\";\n\t}\t\n}\n```\n\nDemo06JDBC.java\n\n```java\npublic class Demo06JDBC {\n\tpublic static void main(String[] args) {\n\t\tList<Emp> list=new Demo06JDBC().findAll();\n\t\tSystem.out.println(list);\n\t}\n\t/**\n\t * 查询所有emp对象\n\t * \n\t * @return\n\t */\n\tpublic List<Emp> findAll() {\n\t\tList<Emp> list = null;\n\t\tConnection conn = null;\n\t\tStatement stmt = null;\n\t\tResultSet rs = null;\n\t\ttry {\n\t\t\t// 1.注册驱动\n\t\t\tClass.forName(\"com.mysql.cj.jdbc.Driver\");\n\t\t\t// 2.获取连接对象\n\t\t\tconn = DriverManager.getConnection(\"jdbc:mysql:///beauty?serverTimezone=UTC\", \"root\", \"13838385638\");\n\t\t\t// 3.定义sql\n\t\t\tString sql = \"select * from emp\";\n\t\t\t// 4.获取执行sql对象\n\t\t\tstmt = conn.createStatement();\n\t\t\t// 5.执行sql\n\t\t\trs = stmt.executeQuery(sql);\n\t\t\t// 6.遍历结果集，装载集合\n\t\t\tEmp emp = null;\n\t\t\tlist=new ArrayList<Emp>();\n\t\t\twhile (rs.next()) {\n\t\t\t\tint id = rs.getInt(\"id\");\n\t\t\t\tString ename = rs.getString(\"ename\");\n\t\t\t\tint job_id = rs.getInt(\"job_id\");\n\t\t\t\tint mgr = rs.getInt(\"mgr\");\n\t\t\t\t// 这个date是java.sql.Date，他是继承自java.util.Date的。所以往emp中存的时候，是没问题的\n\t\t\t\tDate joindate = rs.getDate(\"joindate\");\n\t\t\t\tdouble salary = rs.getDouble(\"salary\");\n\t\t\t\tdouble bonus = rs.getDouble(\"bonus\");\n\t\t\t\tint dept_id = rs.getInt(\"dept_id\");\n\t\t\t\t// 创建对象\n\t\t\t\t//在javaBean中，若参数在4个以上，便不推荐使用有参构造函数\n\t\t\t\temp = new Emp();\n\t\t\t\temp.setId(id);\n\t\t\t\temp.setEname(ename);\n\t\t\t\temp.setJob_id(job_id);\n\t\t\t\temp.setMgr(mgr);\n\t\t\t\temp.setJoindate(joindate);\n\t\t\t\temp.setSalary(salary);\n\t\t\t\temp.setBonus(bonus);\n\t\t\t\temp.setDept_id(dept_id);\n\t\t\t\t// 装载集合\n\t\t\t\tlist.add(emp);\n\t\t\t}\n\t\t} catch (ClassNotFoundException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (SQLException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\t//一定不要忘记释放资源\n\t\t\tif (rs != null) {\n\t\t\t\ttry {\n\t\t\t\t\trs.close();\n\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (stmt != null) {\n\t\t\t\ttry {\n\t\t\t\t\tstmt.close();\n\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (conn != null) {\n\t\t\t\ttry {\n\t\t\t\t\tconn.close();\n\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn list;\n\t}\n}\n```\n\n#### 优化版本\n\n目的：简化书写\n\n步骤：\n\n1. 抽取注册驱动\n2. 抽取一个方法来获取连接对象\n   * 需求：不传递参数，同时还要保证工具类的通用性\n   * 解决：配置文件，在之前的[博客](https://meethigher.top/blog/2020/reflection-and-annotation/#1-4-%E5%8F%8D%E5%B0%84%E6%A1%88%E4%BE%8B)也有提到使用方法\n3. 抽取一个方法来释放资源\n\nutil.JDBCUtils.java\n\n```java\npublic class JDBCUtils {\n    /**\n     * 只有静态变量才能被静态代码块所访问\n     */\n    private static String url;\n    private static String user;\n    private static String password;\n    private static String driver;\n\n    /**\n     * 静态代码块，只需要读取一次拿到这些值\n     */\n    static {\n        //读取资源文件，获取值\n        //1.创建Properties集合类\n        Properties pro = new Properties();\n        try {\n            //2.加载文件\n//\t\t\tpro.load(new FileInputStream(\"src/demo45/jdbc.properties\"));\n            //另一种加载方式\n            //获取src路径下的文件的方式-->ClassLoader类加载器\n            ClassLoader loader = JDBCUtils.class.getClassLoader();\n            URL res = loader.getResource(\"jdbc.properties\");\n            String path = res.getPath();\n            pro.load(new FileInputStream(path));\n            //3.获取属性赋值\n            url = pro.getProperty(\"url\");\n            user = pro.getProperty(\"user\");\n            password = pro.getProperty(\"password\");\n            driver = pro.getProperty(\"driver\");\n            //4.注册驱动\n            Class.forName(driver);\n        } catch (ClassNotFoundException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (FileNotFoundException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n    }\n\n    /**\n     * 获取连接\n     *\n     * @return 连接对象\n     */\n    public static Connection getConnection() throws SQLException {\n        Connection conn = null;\n        conn = DriverManager.getConnection(url, user, password);\n\n        return conn;\n    }\n\n    /**\n     * 释放资源\n     *\n     * @param stmt\n     * @param conn\n     */\n    public static void close(Statement stmt, Connection conn) {\n        if (stmt != null) {\n            try {\n                stmt.close();\n            } catch (SQLException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n        if (conn != null) {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n    }\n\n    /**\n     * 释放资源的重载形式\n     *\n     * @param rs\n     * @param stmt\n     * @param conn\n     */\n    public static void close(ResultSet rs, Statement stmt, Connection conn) {\n        if (rs != null) {\n            try {\n                rs.close();\n            } catch (SQLException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n        if (stmt != null) {\n            try {\n                stmt.close();\n            } catch (SQLException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n        if (conn != null) {\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\njdbc.JDBC.java\n\n```java\n/**\n * \n * @author kit chen\n *\n */\npublic class JDBC {\n\tpublic static void main(String[] args) {\n\t\tList<Emp> list=new JDBC().findAll();\n\t\tSystem.out.println(list);\n\t}\n\t/**\n\t * 查询数据，并返回\n\t * @return\n\t */\n\tpublic List<Emp> findAll() {\n\t\tConnection conn=null;\n\t\tStatement stmt=null;\n\t\tResultSet rs=null;\n\t\tEmp emp=null;\n\t\tList<Emp> list=null;\n\t\ttry {\n\t\t\tconn=JDBCUtils.getConnection();\n\t\t\tstmt=conn.createStatement();\n\t\t\tString sql=\"select * from emp\";\n\t\t\trs=stmt.executeQuery(sql);\n\t\t\tlist=new ArrayList<Emp>();\n\t\t\twhile(rs.next()) {\n\t\t\t\tint id = rs.getInt(\"id\");\n\t\t\t\tString ename = rs.getString(\"ename\");\n\t\t\t\tint job_id = rs.getInt(\"job_id\");\n\t\t\t\tint mgr = rs.getInt(\"mgr\");\n\t\t\t\t// 这个date是java.sql.Date，他是继承自java.util.Date的。所以往emp中存的时候，是没问题的\n\t\t\t\tDate joindate = rs.getDate(\"joindate\");\n\t\t\t\tdouble salary = rs.getDouble(\"salary\");\n\t\t\t\tdouble bonus = rs.getDouble(\"bonus\");\n\t\t\t\tint dept_id = rs.getInt(\"dept_id\");\n\t\t\t\t// 创建对象\n\t\t\t\t//在javaBean中，若参数在4个以上，便不推荐使用有参构造函数\n\t\t\t\temp = new Emp();\n\t\t\t\temp.setId(id);\n\t\t\t\temp.setEname(ename);\n\t\t\t\temp.setJob_id(job_id);\n\t\t\t\temp.setMgr(mgr);\n\t\t\t\temp.setJoindate(joindate);\n\t\t\t\temp.setSalary(salary);\n\t\t\t\temp.setBonus(bonus);\n\t\t\t\temp.setDept_id(dept_id);\n\t\t\t\t// 装载集合\n\t\t\t\tlist.add(emp);\n\t\t\t}\n\t\t} catch (SQLException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tJDBCUtils.close(rs, stmt, conn);\n\t\t}\n\t\treturn list;\n\t}\n}\n```\n\ndomain.Emp.java\n\n```java\n/**\n * 封装Emp表的JavaBean\n * @author kit chen\n *\n */\npublic class Emp {\n\tprivate int id;\n\tprivate String ename;\n\tprivate int job_id;\n\tprivate int mgr;\n\tprivate Date joindate;\n\tprivate double salary;\n\tprivate double bonus;\n\tprivate int dept_id;\n\t\n\tpublic int getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(int id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic String getEname() {\n\t\treturn ename;\n\t}\n\n\tpublic void setEname(String ename) {\n\t\tthis.ename = ename;\n\t}\n\n\tpublic int getJob_id() {\n\t\treturn job_id;\n\t}\n\n\tpublic void setJob_id(int job_id) {\n\t\tthis.job_id = job_id;\n\t}\n\n\tpublic int getMgr() {\n\t\treturn mgr;\n\t}\n\n\tpublic void setMgr(int mgr) {\n\t\tthis.mgr = mgr;\n\t}\n\n\tpublic Date getJoindate() {\n\t\treturn joindate;\n\t}\n\n\tpublic void setJoindate(Date joindate) {\n\t\tthis.joindate = joindate;\n\t}\n\n\tpublic double getSalary() {\n\t\treturn salary;\n\t}\n\n\tpublic void setSalary(double salary) {\n\t\tthis.salary = salary;\n\t}\n\n\tpublic double getBonus() {\n\t\treturn bonus;\n\t}\n\n\tpublic void setBonus(double bonus) {\n\t\tthis.bonus = bonus;\n\t}\n\n\tpublic int getDept_id() {\n\t\treturn dept_id;\n\t}\n\n\tpublic void setDept_id(int dept_id) {\n\t\tthis.dept_id = dept_id;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Emp {id=\" + id + \", ename=\" + ename + \", job_id=\" + job_id + \", mgr=\" + mgr + \", joindate=\" + joindate\n\t\t\t\t+ \", salary=\" + salary + \", bonus=\" + bonus + \", dept_id=\" + dept_id + \"}\";\n\t}\n}\n```\n\njdbc.properties\n\n```properties\nurl=jdbc:mysql:///beauty?serverTimezone=UTC\nuser=root\npassword=13838385638\ndriver=com.mysql.cj.jdbc.Driver\n```\n\n### 登录练习\n\n需求：\n\n1. 通过键盘录入用户名和密码\n2. 判断用户是否登录成功\n\n```java\npublic class Demo07JDBC {\n\tpublic static void main(String[] args) {\n\t\tScanner input=new Scanner(System.in);\n\t\tString user=input.nextLine();\n\t\tString password=input.nextLine();\n\t\tif(login(user,password)) {\n\t\t\tSystem.out.println(\"登录成功\");\n\t\t}else {\n\t\t\tSystem.out.println(\"登录失败\");\n\t\t}\n\t\tinput.close();\n\t}\n\t/**\n\t * 登录方法\n\t * @param user\n\t * @param password\n\t * @return\n\t */\n\tpublic static boolean login(String user,String password) {\n\t\tif(user==null||password==null) {\n\t\t\treturn false;\n\t\t}\n\t\t//连接数据库判断是否登录成功\n\t\tConnection conn=null;\n\t\tStatement stmt=null;\n\t\tResultSet rs=null;\n\t\ttry {\n\t\t\t//1.获取连接\n\t\t\tconn=JDBCUtils.getConnection();\n\t\t\t//2.定义sql\n\t\t\tString sql=\"select * from user where user='\"+user+\"' and password='\"+password+\"'\";\n\t\t\t//3.获取执行sql的对象\n\t\t\tstmt=conn.createStatement();\n\t\t\t//4.执行查询\n\t\t\trs=stmt.executeQuery(sql);\n\t\t\t//5.结果\n\t\t\treturn rs.next();\n\t\t} catch (SQLException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}finally {\n\t\t\tJDBCUtils.close(rs, stmt, conn);\n\t\t}\n\t\t\n\t\t//若出现异常，返回false\n\t\treturn false;\n\t}\n}\n```\n\n> 但是，这样登录，会出现sql注入的问题。\n>\n> 假如，密码输入的是**a' or 'a' = 'a**，那么整个sql语句**select * from user where user='fjaljfl' and password='a' or 'a' = 'a'**\n>\n> 不论怎么查，都会返回数据\n\n## 3.5 PreparedStatement：执行sql的对象\n\n1. sql注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性的问题\n2. 解决sql注入问题：使用PreparedStatement对象来解决\n\n> 静态sql：直接拼接而成的sql，这种会产生sql注入问题\n>\n> 预编译sql：参数使用**？**作为占位符\n\nJDBC的步骤也会相应改变\n\n1. 导入驱动jar包\n2. 注册驱动\n3. 获取数据库连接对象（Connection）\n4. 定义sql，参数使用占位符\n   * select * from where user = ? and password = ?;\n5. 获取执行sql语句的对象（PreparedStatement）\n6. 给占位符赋值\n   * 方法：setXXX(参数1，参数2)\n   * 参数1：位置的编号。从1开始\n   * 参数2：值\n7. 执行sql，接收返回的结果\n8. 处理结果\n9. 释放资源\n\n改造上面的登录案例\n\n```java\npublic class Demo08JDBC {\n\tpublic static void main(String[] args) {\n\t\tScanner input=new Scanner(System.in);\n\t\tString user=input.nextLine();\n\t\tString password=input.nextLine();\n\t\tif(login(user,password)) {\n\t\t\tSystem.out.println(\"登录成功\");\n\t\t}else {\n\t\t\tSystem.out.println(\"登录失败\");\n\t\t}\n\t\tinput.close();\n\t}\n\t/**\n\t * 登录方法\n\t * @param user\n\t * @param password\n\t * @return\n\t */\n\tpublic static boolean login(String user,String password) {\n\t\tif(user==null||password==null) {\n\t\t\treturn false;\n\t\t}\n\t\t//连接数据库判断是否登录成功\n\t\tConnection conn=null;\n\t\tPreparedStatement pstmt=null;\n\t\tResultSet rs=null;\n\t\ttry {\n\t\t\t//1.获取连接\n\t\t\tconn=JDBCUtils.getConnection();\n\t\t\t//2.定义sql\n\t\t\tString sql=\"select * from user where user= ? and password= ?\";\n\t\t\t//3.获取执行sql的对象\n\t\t\tpstmt=conn.prepareStatement(sql);\n\t\t\t//4.赋值\n\t\t\tpstmt.setString(1, user);\n\t\t\tpstmt.setString(2, password);\n\t\t\t//5.执行查询\n\t\t\trs=pstmt.executeQuery();\n\t\t\t//6.结果\n\t\t\treturn rs.next();\n\t\t} catch (SQLException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}finally {\n\t\t\tJDBCUtils.close(rs, pstmt, conn);\n\t\t}\n\t\t\n\t\t//若出现异常，返回false\n\t\treturn false;\n\t}\n}\n```\n\n> 实际开发中经常使用PreparedStatement来完成增删改查操作\n>\n> 1. 防止sql注入\n> 2. 效率更高\n\n# 四、JDBC管理事务\n\n事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。\n\n操作\n\n1. 开启事务\n2. 提交事务\n3. 回滚事务\n\n使用Connection对象来管理事务。\n\n```java\npublic class Demo09JDBC {\n\tpublic static void main(String[] args) {\n\t\tConnection conn = null;\n\t\tPreparedStatement pstmt1 = null;\n\t\tPreparedStatement pstmt2 = null;\n\n\t\ttry {\n\t\t\t// 1.获取连接\n\t\t\tconn = JDBCUtils.getConnection();\n\t\t\t//开启事务\n\t\t\tconn.setAutoCommit(false);\n\t\t\t// 2.定义sql\n\t\t\t// 2.1 张三-500\n\t\t\tString sql1 = \"update account set balance = balance-? where id=?\";\n\t\t\t// 2.2 李四+500\n\t\t\tString sql2 = \"update account set balance = balance+? where id=?\";\n\t\t\t//3.获取执行sql对象\n\t\t\tpstmt1=conn.prepareStatement(sql1);\n\t\t\tpstmt2=conn.prepareStatement(sql2);\n\t\t\t//4.设置参数\n\t\t\tpstmt1.setDouble(1, 500);\n\t\t\tpstmt1.setInt(2, 1);\n\t\t\tpstmt2.setDouble(1, 500);\n\t\t\tpstmt2.setInt(2, 2);\n\t\t\t//5.执行sql\n\t\t\tpstmt1.executeUpdate();\n\t\t\t//手动制造异常\n\t\t\tint i=3/0;\n\t\t\tpstmt2.executeUpdate();\n\t\t\t\n\t\t\t//提交事务\n\t\t\tconn.commit();\n\t\t} catch (Exception e) {\n\t\t\t// TODO: handle exception\n\t\t\t//不管出现什么异常,事务都要回滚\n\t\t\ttry {\n\t\t\t\tif(conn!=null) {\n\t\t\t\t\tconn.rollback();\n\t\t\t\t}\n\t\t\t} catch (SQLException e1) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te1.printStackTrace();\n\t\t\t}\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tJDBCUtils.close(pstmt1, conn);\n\t\t\tJDBCUtils.close(pstmt2, null);\n\t\t}\n\t}\n}\n```\n\n# 五、数据库连接池\n\n概念：本质是一个容器（集合），存放数据库连接的容器。\n\n> 当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。\n\n好处\n\n1. 节约资源\n2. 用户访问过程变得高效\n\n实现\n\n1. 标准接口：DataSource，javax.sql包下的官方提供的接口\n   * 获取连接：getConnection()\n   * 归还连接：如果连接对象Connection是从连接池中获取的，那么调用Connection.close()则不会关闭连接，而是归还连接。\n2. 一般是由数据库厂商来实现，推荐[三种数据库连接池技术](https://blog.csdn.net/chenyun1997/article/details/100127106)\n   * C3P0：比较老\n   * Druid：由阿里巴巴提供的，而且高效。号称全球最好？！\n   * DBCP：apache上的java连接池项目，也是tomcat使用的连接池组件。\n\n## 5.1 C3P0\n\n> 在这之前，我要强烈吐槽eclipse！\n>\n> 我用的eclipse最新版2019.06，搞这个数据库连接池的时候，eclipse成功把我推向了idea。主要就是在新版jdk中，eclipse是读不到配置文件的，无论你放到哪里，他都读不到。但是如果把jdk降为1.8，就可以了。\n>\n> 同时，还有个坑，我如果一开始建的项目以jdk1.8为准，后期再换成jdk新版，哎，他又可以用了，玄学啊！如果一开始直接建以最新jdk的项目，他是不能导出jar包的，会无缘无故失败。但是换成1.8，再换成新版，又可以了，又是玄学啊！\n>\n> 而idea，不论是哪个版本jdk，都能完美运行，这就是收费跟不收费软件的区别吗？\n>\n> 发现这个问题的，还有一个小伙伴，他的[博客](https://blog.csdn.net/weixin_45952147/article/details/104659590)\n>\n> eclipse，我以后不会再用了。idea，他不香吗？\n\n[c3p0文档](https://www.mchange.com/projects/c3p0/)\n\n[c3p0配置文件](https://blog.csdn.net/zhanghanlun/article/details/80918422)\n\n### 步骤\n\n1. 导入jar包 c3p0.jar跟mchange.jar\n2. 定义配置文件 c3p0.properties或者c3p0-config.xml，直接将文件放置到src下面即可\n3. 创建核心对象 数据库连接池对象 ComboPooledDataSource\n4. 获取连接 getConnection\n\n实现\n\nc3p0-config.xml\n\n```xml\n<c3p0-config>\n    <!-- 默认配置，如果没有指定则使用这个配置 -->\n    <default-config>\n        <!-- 连接参数 -->\n        <property name=\"user\">root</property>\n        <property name=\"password\">13838385638</property>\n        <property name=\"jdbcUrl\">jdbc:mysql://localhost:3306/beauty?serverTimezone=UTC</property>\n        <property name=\"driverClass\">com.mysql.cj.jdbc.Driver</property>\n        <!-- 连接池参数 -->\n        <!-- 初始化数据库连接池时连接的数量 -->\n        <property name=\"initialPoolSize\">5</property>\n        <!-- 数据库连接池中的最大的数据库连接数 -->\n        <property name=\"maxPoolSize\">5</property>\n        <!-- 超时时间 -->\n        <property name=\"checkoutTimeout\">3000</property>\n    </default-config>\n    <!-- 命名的配置,可以通过方法调用实现 -->\n    <named-config name=\"otherc3p0\">\n        <!-- 连接参数 -->\n        <property name=\"user\">root</property>\n        <property name=\"password\">13838385638</property>\n        <property name=\"jdbcUrl\">jdbc:mysql://localhost:3306/beauty?serverTimezone=UTC</property>\n        <property name=\"driverClass\">com.mysql.cj.jdbc.Driver</property>\n        <!-- 连接池参数 -->\n        <!-- 初始化数据库连接池时连接的数量 -->\n        <property name=\"initialPoolSize\">5</property>\n        <!-- 数据库连接池中的最大的数据库连接数 -->\n        <property name=\"maxPoolSize\">5</property>\n        <!-- 超时时间 -->\n        <property name=\"checkoutTimeout\">3000</property>\n    </named-config>\n</c3p0-config>\n```\n\n当然，也可以用c3p0.properties\n\n```properties\nc3p0.driverClass=com.mysql.cj.jdbc.Driver\nc3p0.jdbcUrl=jdbc:mysql://localhost:3306/beauty?serverTimezone=UTC\nc3p0.user=root\nc3p0.password=13838385638\nc3p0.acquireIncrement=5\nc3p0.initialPoolSize=20\nc3p0.minPoolSize=10\nc3p0.maxPoolSize=40\nc3p0.checkoutTimeout=5000\n```\n\n### 代码\n\n```java\npublic class Demo01c3p0 {\n    public static void main(String[] args) throws SQLException {\n        //1.创建数据库连接池对象\n        //使用默认配置\n//        DataSource ds=new ComboPooledDataSource();\n        //使用指定配置\n        DataSource ds=new ComboPooledDataSource(\"otherc3p0\");\n        //2.获取连接对象\n        Connection conn=ds.getConnection();\n        System.out.println(conn);\n        System.out.println();\n    }\n}\n```\n\n## 5.2 Druid\n\n### 步骤\n\n1. 导入jar包\n2. 定义配置文件.properties\n   * properties格式\n   * 任意名称，可以放在任意目录下\n3. 加载配置文件\n4. 获取数据库连接池对象：通过工厂类DruidDataSourceFactory，来获取\n5. 获取连接：getConnection\n\n配置文件\n\n```properties\n# Druid配置文件\ndriverClassName=com.mysql.cj.jdbc.Driver\nurl=jdbc:mysql:///beauty?serverTimezone=UTC\nusername=root\npassword=13838385638\ninitialSize=5\nmaxActive=10\nmaxWait=3000\n```\n\n### 代码\n\n```java\npublic class Demo03Druid {\n    public static void main(String[] args) throws Exception {\n        //加载配置文件\n        Properties pro=new Properties();\n        pro.load(Demo03Druid.class.getClassLoader().getResourceAsStream(\"druid.properties\"));\n        //获取连接池对象\n        DataSource ds = DruidDataSourceFactory.createDataSource(pro);\n        //获取连接\n        Connection conn=ds.getConnection();\n        System.out.println(conn);\n    }\n}\n```\n\n## 5.3 定义连接池工具类\n\n### 步骤\n\n1. 定义类JDBCPoolUtils\n2. 提供静态代码块，来加载配置文件，并且初始化连接池对象\n3. 提供方法\n   * 获取连接方法：getConnection\n   * 释放资源：close()\n   * 获取连接池的方法：getDataSource\n\n### 实现\n\nJDBCPoolUtils.java\n\n```java\n/**\n * Druid连接池的工具类\n */\npublic class JDBCPoolUtils {\n    //1.定义一个成员变量\n    private static DataSource ds;\n    //2.静态代码块初始化赋值\n    static {\n        //加载配置文件\n        Properties pro=new Properties();\n        try {\n            pro.load(JDBCPoolUtils.class.getClassLoader().getResourceAsStream(\"druid.properties\"));\n            //初始化DataSource\n            ds= DruidDataSourceFactory.createDataSource(pro);\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * @return 获取到的连接对象\n     */\n    public static Connection getConnection() throws SQLException {\n        return ds.getConnection();\n    }\n\n    /**\n     * 释放资源\n     */\n//    public static void close(Statement stmt, Connection conn){\n//        if(stmt!=null){\n//            try {\n//                stmt.close();\n//            } catch (SQLException e) {\n//                e.printStackTrace();\n//            }\n//        }\n//        if(conn!=null){\n//            try {\n//                conn.close();//归还连接\n//            } catch (SQLException e) {\n//                e.printStackTrace();\n//            }\n//        }\n//    }\n    public static void close(ResultSet rs,Statement stmt, Connection conn){\n        if(rs!=null){\n            try {\n                rs.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        if(stmt!=null){\n            try {\n                stmt.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        if(conn!=null){\n            try {\n                conn.close();//归还连接\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    /**\n     *\n     * @return 获取连接池对象\n     */\n    public static DataSource getDataSource(){\n        return ds;\n    }\n}\n```\n\nDruidMain.java\n\n```java\n/**\n * 使用工具类JDBCPoolUtils\n */\npublic class DruidMain {\n    public static void main(String[] args) {\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement pstmt = null;\n        try {\n            conn = JDBCPoolUtils.getConnection();\n//            String sql = \"select * from memeber\";\n//            pstmt = conn.prepareStatement(sql);\n//            rs = pstmt.executeQuery();\n//            while (rs.next()) {\n//                System.out.println(rs.getString(\"name\") + \"-->\"\n//                        + rs.getString(\"gender\"));\n//            }\n            String sql=\"update memeber set gender=? where name=?\";\n            pstmt=conn.prepareStatement(sql);\n            pstmt.setString(1,\"男\");\n            pstmt.setString(2,\"唐三\");\n            int count=pstmt.executeUpdate();\n            System.out.println(count);\n            if(count>0){\n                System.out.println(\"成功\");\n            }else{\n                System.out.println(\"失败\");\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            JDBCPoolUtils.close(rs,pstmt,conn);\n        }\n    }\n}\n```\n\n# 六、Spring JDBC\n\nSpring框架对JDBC的简单封装。提供了JDBCTemplate来简化JDBC的开发\n\n上学期课程设计的时候，我就觉得这部分比较麻烦，问老师，老师也支支吾吾说不明白。老师大概也就只要个功能，具体的实现优化，他才不管，我猜，他也不会。\n\n[报告管理信息系统](https://meethigher.top/blog/2020/record-management/)，说实话，写得很幼稚。\n\n## 步骤\n\n1. 导入jar包 core.jar jdbc.jar tx.jar beans.jar commons-logging.jar\n2. 创建JDBCTemplate对象。依赖于数据源DataSource\n   * JDBCTemlate temp=new JDBCTemplate(ds);\n3. 调用方法来CRUD（增删改）操作\n   * update()：执行DML语句。增删改\n   * queryForMap()：查询结果，将结果集封装为Map。\n     * 列名作为key，值作为value，将这条记录封装为map集合。（长度只能为1）\n   * queryForList()：查询结果，将将结果集封装为List。\n     * 将每一条Map封装为Map集合，再将Map集合装载到List集合中\n   * query()：查询结果，将结果封装为javaBean对象\n     * query的参数：RowMapper。一般我们使用BeanPropertyRowMapper实现类，它可以完成数据到javaBean的自动封装\n     * 使用方法：new BeanPropertyRowMapper<类名>(类名.Class)\n   * queryForObject()：查询结果，将结果封装为指定对象\n     * 一般用于聚合函数的查询。比方说返回的结果是Long类型，就需要将结果封装\n\n```java\npublic class Demo01JDBCTemplate {\n    public static void main(String[] args) {\n        //创建JdbcTemplate\n        JdbcTemplate temp=new JdbcTemplate(JDBCPoolUtils.getDataSource());\n        //调用方法\n        String sql=\"update memeber set gender=? where name=?\";\n        int count=temp.update(sql,\"男\",\"唐三\");\n        System.out.println(count);\n    }\n}\n```\n\n## 使用\n\n需求\n\n1. 修改id为1数据salary为10000\n2. 添加一条记录\n3. 删除刚才添加的记录\n4. 查询id为1的记录，将其封装为Map集合\n5. 查询所有记录，封装为List集合\n6. 查询所有记录，封装为Emp对象的List集合\n7. 查询总记录数\n\n实现\n\n通过Junit单元测试来实现每个需求\n\n```java\n/**\n * 使用Spring以及Junit单元测试\n *\n * @author https://github.com/meethigher\n */\npublic class Demo02JDBCTemplate {\n    private JdbcTemplate temp = new JdbcTemplate(JDBCPoolUtils.getDataSource());\n\n    //修改id为1001数据salary为10000\n    @Test\n    public void test1() {\n        String sql = \"update emp set salary=10000 where id=1001\";\n        int count = temp.update(sql);\n        if (count > 0) {\n            System.out.println(\"成功\");\n        } else {\n            System.out.println(\"失败\");\n        }\n    }\n\n    //添加一条记录\n    @Test\n    public void test2() {\n        String sql = \"insert into emp(id,ename,dept_id) values(?,?,?)\";\n        int count = temp.update(sql, 1015, \"胡列娜\", 10);\n        if (count > 0) {\n            System.out.println(\"成功\");\n        } else {\n            System.out.println(\"失败\");\n        }\n    }\n\n    //删除刚添加的记录\n    @Test\n    public void test3() {\n        String sql = \"delete from emp where id=?\";\n        int count = temp.update(sql, 1015);\n        if (count > 0) {\n            System.out.println(\"成功\");\n        } else {\n            System.out.println(\"失败\");\n        }\n    }\n\n    //查询id为1001的记录，将其封装为Map集合\n    @Test\n    public void test4() {\n        String sql = \"select * from emp where id=?\";\n        Map<String, Object> map = temp.queryForMap(sql, 1001);\n        System.out.println(map);\n    }\n\n    //查询所有记录，将其封装为List集合\n    @Test\n    public void test5() {\n        String sql = \"select * from emp\";\n        List<Map<String, Object>> list = temp.queryForList(sql);\n        for (Map<String, Object> map : list) {\n            System.out.println(map);\n        }\n    }\n\n    //查询所有记录，将其封装为Emp对象的List集合\n    //自己实现\n    @Test\n    public void test6() {\n        String sql = \"select * from emp\";\n        List<Emp> list = temp.query(sql, new RowMapper<Emp>() {\n            @Override\n            public Emp mapRow(ResultSet rs, int i) throws SQLException {\n                Emp emp = new Emp();\n                int id = rs.getInt(\"id\");\n                String ename = rs.getString(\"ename\");\n                int job_id = rs.getInt(\"job_id\");\n                int mgr = rs.getInt(\"mgr\");\n                Date joindate = rs.getDate(\"joindate\");\n                double salary = rs.getDouble(\"salary\");\n                double bonus = rs.getDouble(\"bonus\");\n                int dept_id = rs.getInt(\"dept_id\");\n                emp.setId(id);\n                emp.setEname(ename);\n                emp.setBonus(bonus);\n                emp.setDept_id(dept_id);\n                emp.setJoindate(joindate);\n                emp.setMgr(mgr);\n                emp.setSalary(salary);\n                emp.setJob_id(job_id);\n                return emp;\n            }\n        });\n        for (Emp emp : list) {\n            System.out.println(emp);\n        }\n    }\n\n    //查询所有记录，将其封装为Emp对象的List集合\n    //用别人提供的实现类\n    @Test\n    public void test7() {\n        String sql = \"select * from emp\";\n        /*\n        此处如果数据库的数据中是null的话，传给int或者double这种基本类型是会报错的\n        所以，需要修改成引用类型Integer和Double\n         */\n        List<Emp1> list = temp.query(sql, new BeanPropertyRowMapper<Emp1>(Emp1.class));\n        for (Emp1 emp : list) {\n            System.out.println(emp);\n        }\n    }\n\n    //查询总记录数\n    @Test\n    public void test8() {\n        String sql = \"select count(id) from emp\";\n        Long total = temp.queryForObject(sql, Long.class);\n        System.out.println(total);\n    }\n}\n```\n\n\n\n","tags":["java"]},{"title":"使用官方api文档","url":"/blog/2019/java-official-doc/","content":"\n有关线程的一系列知识点\n\n如何使用java官方api文档呢？\n\n<!--more-->\n\n{% asset_img 使用官方api文档.png 使用官方api文档 %}\n\n{% asset_img 示例.png 示例 %}","tags":["java"]},{"title":"js动态绑定动态元素","url":"/blog/2019/js-dynamic-element/","content":"\n我太难了，完成功能半小时，修bug做兼容俩小时\n\n<!--more-->\n\n#### No.1 动态生成元素绑定事件\n\n今天碰到一个问题，js无法对动态生成的元素进行绑定。\n\n我一开始，知道没有获取到那个标签，所以通过`onload`方法来获取元素，企图通过初始页面加载完成之后，再获取标签，这样也行，但是，异步获取数据之后生成的标签就不行了，`onload`只能执行一次啊，因为异步请求没有刷新页面啊。\n\n后来，搜了一下，发现了解决方案；\n\n```html\n<ul class=\"fu\">\n    //动态生成的li标签\n    <li>1</li>\n    <li>2</li>\n</ul>\n```\n\n\n\n```javascript\n//这个是我的写法\n$(\"li\").on(\"click\",function (){\n    alert(\"haha\");\n});\n//这就出现问题了，这样绑定事件，一旦元素发生变化，就会失效\n\n//解决方案\n$(\".fu\").on(\"click\",function (){\n    alert(\"haha\");\n});\n//通过上面的这个方法，就能动态地给动态元素添加事件了\n```\n\n#### No.2 点击非内容区域关闭弹窗\n\n今天晚上还有个值得一提的事情，就是标题这个事。\n\n这个就涉及到冒泡的问题了。\n\n```javascript\n$(document).on(\"click\",function (){\n    /*隐藏元素的逻辑*/\n});\n$(\"div\").on(\"click\",function (){\n    /*显示元素的逻辑*/\n});\n//上面的这种写法，会导致两个都会冒泡，也就是执行的意思。出现的效果就是元素刚显示就被隐藏了\n\n//解决方案\n$(\"div\").on(\"click\",function (e){\n    e.stopPropagation();//阻止click事件冒泡到父元素\n    /*显示元素的逻辑*/\n});\n```\n\n按上面的方法，就完美解决了。\n\n总结一下，其实这都不难理解，但是总是会在一些小问题上浪费时间。\n\n算了，仔细想想，这一切都是我成为大佬路上的垫脚石。","tags":["javascript"]},{"title":"知识改变命运","url":"/blog/2020/knowledge-determines-fate/","content":"\n今天看了极限挑战，极限男人帮高考那集，有感而发。\n\n<!--more-->\n\n节目即将结束，有个很感人的部分。\n\n真人秀有搞笑又有教育意义，这才是一个好的真人秀的价值所在，而不应该是一味的玩梗、炒热度。\n\n# 一、人生有起点\n\n6个问题，决定了你是否赢在了起跑线\n\n1. 父母是否都接受过大学以上教育？\n2. 父母是否让你持续学习功课以外的一门特长，并且目前还保持一定水准？\n3. 父母是否为你请过一对一家庭教师？\n4. 你是否有过旅游、出国经历？\n5. 父母是否承诺过送你出国留学？\n6. 父母是否一直视你为骄傲，并且在亲朋好友面前炫耀你？\n\n很“幸运”，6个问题，我全是否。\n\n我相信，很多像我一样的农村孩子也是否。\n\n随着，我接受的教育的水平越来越高，我越来越发现与同龄人之间的差距，就在于这小小的起跑线上。\n\n比如，童年。别人从小跟玩伴玩耍长大；而我从小放羊一直放到初中。放学回家第一件事，放羊，放羊回家，再写作业。我一直在同龄人眼中，都是异类。\n\n比如，放学下大暴雨。别人父母都去接孩子；而我特么跟个傻逼一样，全身湿透回家。\n\n比如，初中家长会。别人的父母，谈吐优雅、高学历、高收入；而我父母，说话嘶哑来歪（山东方言，可以理解为犟，也可以理解成杠精）、小学没毕业、低收入。家长会上老师直接忽略了我家长的存在，因为说话挨不到天摸不到地。\n\n比如，高考。别人的父母，鼓励孩子上学，给孩子加油打气；而我爸，嫌弃我上学拖累了他。我现在脖子上还有三道疤痕，很幸运，幸好当年没死掉。\n\n比如，别人从小就会玩电脑；我到高二会考那年，还找不到键盘上的3在哪。\n\n比如，别人从小家里接了网线；我因为今年疫情，才接了网线。跟同学谈起关于宽带的一系列种种种种，一窍不通，同学都感觉很不可思议。\n\n比如，别人大学月生活费1000，省不下；而我大学月生活费1000还能省下几百。在我用我省了很久的钱，换个新手机、买个二手ipad时，同学都说，“哇，土豪啊”。他们吃过的大餐，我没吃过，他们看过的风景，我也没见过，这也是人生的不同之处吧。\n\n比如，别人处对象，感情出问题父母给安慰；我处对象，父母张口就是那小妮骗你钱，谈对象根本不用花钱，人家得倒贴咱才对。\n\n比如，别人用父母给的钱，给自己连续换代好几部手机；我用自己的奖学金加生活费里抠出来的钱，给父母二人换手机。\n\n......\n\n前5个问题，直接否。\n\n关于第6个问题，父母是否视我为骄傲。我想了很久。\n\n我爸肯定不会以我为骄傲的，他的世界里只有他自己。我妈有可能以我为骄傲，但是她从来不跟外人炫耀，我不知道到底算不算骄傲。也算否。\n\n其实有很多农村的人，经历比我还要差一些，想上学没得上。而我，很幸运，我妈供我上学，我妈说只要我愿意上。\n\n虽然我妈也没啥文化，但不得不说，她还是有远见的。\n\n我也因此，认识了更多的人。\n\n原来我所期望的生活，竟是他们口中所抱怨的日子。这或许就是起点吧。\n\n# 二、人生是长跑\n\n人生是段长跑，起点高，未必能坚持到最后。\n\n学校正在建设中，同学吐槽学校环境烂；而我却能既来之则安之，丝毫没感觉环境有啥烂的。\n\n同学吐槽学校网烂，1m/s；而我却用的很舒服，要知道，我手机网速才几百k/s，我要是在家里，可是连网都没有。\n\n同学做事总是三分钟热度；而我却总能坚持到最后。我能坚持早起、坚持跑步。同学问，你怎么做到的。我很纳闷，很难吗？高中三年，我跟我室友都是4点50就起床，这都坚持了三年，早上6点起床，很难吗？\n\n同学吐槽专业没兴趣，不好玩，不学了；而我却能沉下心来好好学习专业课知识。\n\n这就好比，长跑。一开始冲得太快了，结果中途没劲了；而那些一开始就不紧不慢匀速跑的，慢慢地就反超了。\n\n我在第一次跑10公里时，一开始按4分钟一公里的速度跑，结果跑到一半，内心崩溃了，嘴里一口粘痰，即使不想停，身体也承受不住了。\n\n在之后我跑10公里，就以慢跑的速度跑，6分钟一公里的速度，我竟然跑完了，关键是跑完时的感觉就是，我还能再跑10公里，一点都不累啊。\n\n我相信，跑过步的都有这种感觉。\n\n如果你起点高，同时还能把控生活的节奏，那你仍能领先99%的人。若是起点低的，如此也能超过50%的人。\n\n在这场长跑中，有50%的人，会把自己的起点优势给浪费掉了。\n\n# 三、知识改变命运\n\n跟我同龄的，好多都结婚生子了，或者在什么养鸡场、纺织厂打工。\n\n我上了这么多年学，不能说是学了多少东西。\n\n我感觉最大的提升就是让我有了素质，这种素质能够让我在彬彬有礼的人面前更加优雅。\n\n一句打扰一下，一句谢谢，我相信没人会反感这样有礼貌的人吧。\n\n同时，还能懂得收敛自己的性格，很多时候，谦逊处事，把风头让给别人。虽然会失掉很多东西，但是能避免一些没必要的烦恼。这种感觉，我很喜欢。\n\n再同时，我有了自己的爱好、兴趣，可能以后我也会做一些不喜欢的职业。但是一个有追求的人，跟没追求的人，两者的生活态度是不一样的。\n\n所谓上学，就是让你在小学、初中、高中、大学期间，认识更多的人，认清自己的水平。更关键的是，懂得了自己的方向。\n\n上学不能让你变富有，但知识能让你生活变得充实。这也算是改变命运了吧。\n\n\n\n\n\n","tags":["life"]},{"title":"Java Server Pages","url":"/blog/2020/jsp/","content":"\n大道至简，殊途同归，记录JSP学习过程。端午节快乐！\n\n<!--more-->\n\n随着学习的内容越来越多，越发感觉到**大道至简，殊途同归**。\n\n之前大二学过c#，随着现在学习的过程，感觉c#跟java也没啥大的区别，可能直接拿来做东西，不会立即整出来。但是真正用的时候，会发现哪怕是搜问题的过程都是一样的。以至于我现在看python，虽然我不了解语法，但是一看别人写的代码，思路就了然于胸了。\n\n之前学校教过asp，我又自学了php，现在学到jsp的各种东西，老是不自觉得联想到asp与php的东西。用法虽然不一样，本质却是一样的。\n\n大道至简，殊途同归，用这句话概括，再明白不过了。\n\n# 一、JSP\n\njsp的概念以及运行原理，看[这里](https://meethigher.top/blog/2020/cookie-and-session-2/)\n\n## 1.1 指令\n\n作用：用于配置jsp页面，导入资源文件\n\n格式：<%@ 指令名称 属性名1=属性值 属性名2=属性值2 %>\n\n分类：\n\n1. page：配置jsp页面\n   * contentType：等同于response.setContentType()。\n     * 可以设置响应体的MIME类型以及字符集编码\n     * 设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用记事本之类的，则需要设置pageEncoding来设置当前页面编码）\n   * pageEncoding：设置页面编码\n   * language：jsp刚出现的时候，想要一统江湖（表现层技术），但是目前为止也只是java而已\n   * buffer：out输出流缓冲区大小，默认8KB\n   * import：导包，跟java中导包是一样的。\n   * errorPage：当前页面发生异常后，会自动跳转到指定的错误页面\n   * isErrorPage：默认是false。标识当前页面是否是错误页面\n     * true：是错误页面，可以使用内置对象exception来获取错误信息\n     * false：默认值。不能使用内置对象\n2. include：页面包含的，导入页面的资源文件\n   * <%@include file=\"资源文件\" %>\n3. taglib：导入资源。如导入标签库\n   * <%@taglib prefix=\"前缀\" uri=\"标签库\" %>，前缀可以自定义。但是都已经约定俗成了，所以还是按习惯来。\n\n## 1.2 注释\n\n1. html注释\n   * `<!-- 注释 -->`：只能注释html片段，会保存在html源码中\n2. jsp特有的注释\n   * `<%-- 注释 --%>`：可以注释所有，不会保存在html源码中，在jsp中推荐都使用jsp注释\n\n## 1.3 内置对象\n\n9个内置对象\n\n* 域对象：共享数据，以下域的范围是从小到大\n  1. pageContext：PageContext类型\n     * 当前页面共享数据\n     * 可以通过getXXX()获取其他的八个对象\n  2. request：HttpServletRequest类型\n     * 一次请求访问的多个资源间共享数据，如转发\n  3. session：HttpSession类型\n     * 一次会话的多个请求间共享数据\n  4. application：ServletContext类型\n     * 多个用户间共享数据\n* 响应对象\n  5. response：HttpServletResponse类型\n  6. page：Object类型，当前页面的引用，相当于该Servlet的this\n  7. out：JspWriter类型，将数据输出到页面\n* 配置对象\n  8. config：ServletConfig类型，Servlet的配置对象\n* 异常\n  9. exception：Throwable类型，异常对象\n\n具体如何查看其类型，可以在jsp编译后的java文件中，在service方法下找到。\n\n# 二、MVC开发模式\n\n## 2.1 jsp演变历史\n\n早期只有Servlet，只能通过response输出标签数据，非常麻烦。\n\n后来sun公司出了jsp，简化了Servlet的开发，非常方便，但是，与html的混编，导致后期大量的代码让人无法阅读\n\n再后来，javaweb开发，借鉴了MVC这种开发模式，使得程序的设计更加有合理性\n\n## 2.2 MVC\n\n将程序分为三部分\n\n1. Model：模型\n   * 业务逻辑操作，如查询数据库、封装数据等\n2. View：视图\n   * 展示数据\n3. Controller：控制器\n   * 获取客户端输入\n   * 调动模型\n   * 将数据交给视图展示\n\n流程\n\n用户访问网站，会先进入Controller，然后Controller调用Model，Model返回数据给Controller。\n\nController将接收到的数据传递给View，View将数据呈现出来。\n\n在javaweb中\n\n* Model：JavaBean\n* View：JSP\n* Controller：Servlet\n\n[详细了解MVC](https://www.runoob.com/design-pattern/mvc-pattern.html)\n\nMVC优缺点\n\n优点：\n\n1. 耦合性低，方便维护，利于分工协作\n2. 重用性高\n\n缺点：使得项目架构变得复杂，对开发人员的要求就会变高\n\n> 在jsp中要尽量少写java代码，由此就需要用到EL表达式跟jstl\n\n# 三、EL表达式\n\n概念：Expression Language，表达式语言\n\n作用：可以替换和简化jsp页面中java代码的编写\n\n语法：`${表达式}`\n\n注意：jsp默认是支持el表达式的\n\n忽略el表达式：\n\n1. 在page指令中添加`isELIgnored=\"true\"`，忽略整个页面的el表达式\n2. 只忽略某一el表达式，可以通过`\\${3>4}`，前面加个反斜杠`\\`即可\n\n## 3.1 使用\n\n实际使用：\n\n1. 运算：后面括号里表示该运算符也可以替换成括号里内容\n   * 支持算术运算符：+,-,*,/(div),%(取余,mod)\n   * 比较运算符：>,<,<=,>=,==,!=\n   * 逻辑运算符：&&(and),||(or),!(not)\n   * 空运算符：empty\n     * 功能非常强大，用于判断字符串和集合以及数组是否为null并且其长度是否为0\n     * 举例，如`${empty array}`，只要array不为空，就为true（此处让我联想到了php中的empty()方法）\n2. 获取值\n   * el表达式只能从域对象（4个）中获取值\n   * 语法1：`${域名称.键名}`：从指定域中获取指定键的值。\n     * 如果没有该值，就会返回空字符串\n   * 语法2：`${键名}`：依次从最小的域中查找是否有该键对应的值，直到找到第一个值为止。\n   * 域名称：\n     * pageScope：从pageContext域中获取值\n     * requestScope：从request域中获取值\n     * sessionScope：从session域中获取值\n     * applicationScope：从application（ServletContext）域中获取值\n     * 如在request域中存储了name=胡列娜，我们可以通过${pageScope.name}来获取\n3. 获取对象、List集合、Map集合的值\n   * 对象：`${域名称.键名.属性名}`，属性名的定义参照[这篇文章](https://meethigher.top/blog/2020/servlet/)\n     * 本质上会调用对象的getter方法\n   * List集合：`${域名称.键名[索引]}`\n     * 如果索引越界就会返回空字符串\n   * Map集合：`${域名称.键名.key名称}`或者`${域名称.键名[\"key名称\"]}`\n\n> 当然，以上的域名称都是可以省略的。\n\n```java\n<%@ page import=\"demo03.domain.User\" %>\n<%@ page import=\"java.util.ArrayList\" %>\n<%@ page import=\"java.util.HashMap\" %>\n<%@ page import=\"java.util.Map\" %><%--\n  Created by IntelliJ IDEA.\n  User: kitchen\n  Date: 2020/6/25\n  Time: 17:29\n  To change this template use File | Settings | File Templates.\n--%>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>Title</title>\n</head>\n<body>\n<%\n    request.setAttribute(\"name\",\"request\");\n    session.setAttribute(\"name\",\"session\");\n    User user=new User();\n    user.setId(1);\n    user.setUser(\"胡列娜\");\n    user.setPassword(\"胡列娜最美\");\n\n    request.setAttribute(\"person\",user);\n\n    ArrayList list=new ArrayList();\n    list.add(\"胡列娜\");\n    list.add(\"江厌离\");\n    request.setAttribute(\"list\",list);\n\n    Map map=new HashMap();\n    map.put(\"name\",\"江厌离\");\n    map.put(\"gender\",\"女\");\n    request.setAttribute(\"map\",map);\n%>\n${3 > 4}\n\\${3 > 4}\n<h1>算数运算符</h1>\n${3 + 4}=7<br>\n${8 / 2}=4<br>\n${8 div 2}=4<br>\n${3 mod 4}=3<br>\n<h1>比较运算符</h1>\n${3 == 4}=false<br>\n<h1>逻辑运算符</h1>\n${3>4&&3<4}=false<br>\n${3>4 and 3<4}=false<br>\n${3>4||3<4}=true<br>\n${requestScope.name}\n${sessionScope.name}\n1${pageScope.hh}2\n<%--可以省略域名--%>\n${name}\n${requestScope.person}\n${requestScope.person.id}\n${requestScope.person.user}\n${requestScope.person.password}\n${requestScope.person.time}\n${requestScope.list[0]}\n<%--在el中，如果越界，就会返回一个空字符串--%>\n${requestScope.list[2]}\n${requestScope.list[1]}\n\n${requestScope.map.name}\n${requestScope.map.gender}\n${requestScope.map[\"gender\"]}\n</body>\n</html>\n\n```\n\n## 3.2 隐式对象\n\n概念：el表达式中不需要创建的、直接拿来用的对象\n\nel表达式中有11个隐式对象（类似于jsp中的内置对象）\n\n1. pageContext\n   * JSP 页的上下文。它可以用于访问 JSP 隐式对象，如请求、响应、会话、输出、servletContext 等。例如，${pageContext.response} 为页面的响应对象赋值。\n2. param\n   * 表达式 ${param.name}相当于 request.getParameter (name)。\n3. paramValues\n   * 表达式 ${paramvalues.name} 相当于request.getParamterValues(name)。\n4. header\n   * 表达式 ${header.name} 相当于 request.getHeader(name)。\n5. headerValues\n   * 表达式 ${headerValues.name} 相当于 request.getHeaderValues(name)。\n6. cookie\n   * 表达式 ${cookie.name.value} 返回带有特定名称的第一个 cookie 值。如果请求包含多个同名的 cookie，则应该使用 ${headerValues.name} 表达式。\n7. initParam\n   * 将上下文初始化参数名称映射到单个值(通过调用 ServletContext.getInitparameter(String name) 获得)。\n8. pageScope\n9. requestScope\n10. sessionScope\n11. applicationScope\n\n具体可参照[360百科](https://baike.so.com/doc/6751385-6965950.html)\n\n# 四、JSTL\n\n## 4.1 了解\n\n概念：JavaServer Pages Tag Library，jsp标准标签库\n\njstl是由apache组织提供的开源的，免费的jsp标签\n\n作用：用于简化和替换jsp页面上的java代码\n\n步骤：\n\n1. 导入jar包\n2. 引入标签库：通过taglib指令<@ taglib %>\n3. 使用标签\n\n## 4.2 常用标签\n\n详细参照[这里](https://www.runoob.com/jsp/jsp-jstl.html)\n\n常用的jstl标签\n\n1. if：相当于java代码的if语句\n   * 属性：test是必需属性，可以结合el表达式一块使用\n     * 如果test是true，则显示标签体内容\n     * 如果test是false，则不显示标签体内容\n   * 注意：c:if没有else情况，如果想要实现else，可以再定义一个c:if标签\n2. choose：相当于java代码的switch语句\n   * 使用choose标签声明：相当于switch声明\n   * 使用when标签做判断：相当于case\n   * 使用otherwise标签做其他情况的判断：相当于default\n3. forEach：相当于java代码的for语句\n   * 普通for循环，如`for(int i=0;i<10;i++)`\n     * begin：开始值，相当于上面的0\n     * end：结束值，10\n     * var：临时变量，i\n     * step：步长，1\n     * varStatus：循环状态对象(这个在普通for循环中，使用很少)\n       * index：容器中元素的索引，从0开始\n       * count：表示循环次数，从1开始\n   * 增强for循环，如`List<Person> list;for(Person p:list)`\n     * items：容器对象，list\n     * var：容器中元素的临时变量，p\n     * varStatus\n\nif标签代码\n\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>\n<html>\n<head>\n    <title>jstl</title>\n</head>\n<body>\n<%--\nc:if这标签\n必需属性：test，接收布尔表达式，如果表达式为true,则显示if标签体内容，如果为false，则不显示标签体内容\n一般情况下，这个test属性值会结合el表达式一起使用\n\n实现：判断request域中的一个list集合是否为空，如果不为null，则显示遍历集合\n\n注意：c:if标签没有else情况，想要else情况，则可以再定义一个c:if标签\n--%>\n<%\n    List list=new ArrayList();\n    list.add(\"hhh\");\n    request.setAttribute(\"list\",list);\n\n%>\n<c:if test=\"true\">我是真</c:if>\n<c:if test=\"${not empty list}\">\n    遍历集合\n</c:if>\n<c:if test=\"${3%2==0}\">\n    3%2==0\n</c:if>\n<c:if test=\"${3%2!=0}\">\n    3%2!=0\n</c:if>\n</body>\n</html>\n```\n\nchoose标签代码\n\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<%@taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>\n<html>\n<head>\n    <title>jstl</title>\n</head>\n<body>\n<%--完成数字编号对应星期几的案例--%>\n<%\n    request.setAttribute(\"day\",54);\n%>\n<c:choose>\n    <c:when test=\"${day==1}\">星期一</c:when>\n    <c:when test=\"${day==2}\">星期二</c:when>\n    <c:when test=\"${day==3}\">星期三</c:when>\n    <c:when test=\"${day==4}\">星期四</c:when>\n    <c:when test=\"${day==5}\">星期五</c:when>\n    <c:when test=\"${day==6}\">星期六</c:when>\n    <c:when test=\"${day==7}\">星期七</c:when>\n    <c:otherwise>输入有误</c:otherwise>\n</c:choose>\n奥利给\n</body>\n</html>\n```\n\nforEach标签代码\n\n```jsp\n<%@ page import=\"java.util.ArrayList\" %>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\"%>\n<html>\n<head>\n    <title>jstl</title>\n</head>\n<body>\n<%--相当于for(int i=0;i<10;i++)--%>\n<c:forEach begin=\"1\" end=\"10\" var=\"i\" step=\"1\" varStatus=\"s\">\n    ${i},${s.index},${s.count}<br>\n</c:forEach>\n<%\n    ArrayList list=new ArrayList();\n    list.add(\"1\");\n    list.add(\"2\");\n\n    request.setAttribute(\"list\",list);\n%>\n<%--相当于for(int i:list)--%>\n<c:forEach items=\"${list}\" var=\"i\" varStatus=\"s\">\n    ${i},${s.index},${s.count}<br>\n</c:forEach>\n</body>\n</html>\n```\n\n## 4.3 练习\n\n### 需求\n\n在request域中，有一个存有User对象的List集合，需要使用jstl和el将List集合数据展示到jsp页面的表格table中\n\n### 实现\n\n```jsp\n<%@ page import=\"java.util.ArrayList\" %>\n<%@ page import=\"demo03.domain.User\" %>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>\n<html>\n<head>\n    <title>案例</title>\n</head>\n<body>\n<%\n    ArrayList<User> list = new ArrayList<User>();\n\n//    可以通过构造方法，修改需要重启服务器，懒得整了，直接用\n    User u1 = new User();\n    u1.setId(1);\n    u1.setUser(\"胡列娜\");\n    u1.setPassword(\"玄机中最美\");\n\n    User u2 = new User();\n    u2.setId(2);\n    u2.setUser(\"江厌离\");\n    u2.setPassword(\"姐姐中最善良\");\n\n    list.add(u1);\n    list.add(u2);\n\n    request.setAttribute(\"list\", list);\n%>\n<table border=\"1\">\n    <tr>\n    <th>id</th>\n    <th>用户名</th>\n    <th>密码</th>\n    <th>时间</th>\n    </tr>\n    <c:forEach items=\"${list}\" var=\"u\" varStatus=\"s\">\n        <c:if test=\"${s.count%2==0}\">\n            <tr bgcolor=\"#f0f8ff\">\n                <td>${u.id}</td>\n                <td>${u.user}</td>\n                <td>${u.password}</td>\n                <td>${u.time}</td>\n            </tr>\n        </c:if>\n        <c:if test=\"${s.count%2!=0}\">\n            <tr bgcolor=\"#f5f5dc\">\n                <td>${u.id}</td>\n                <td>${u.user}</td>\n                <td>${u.password}</td>\n                <td>${u.time}</td>\n            </tr>\n        </c:if>\n    </c:forEach>\n</table>\n</body>\n</html>\n```\n\n","tags":["web","jsp"]},{"title":"记录换笔记本的历程","url":"/blog/2020/legionR7000/","content":"\n用了六年的Lenovo G510换成了Lenovo R7000，性能确实很不错\n\n<!--more-->\n\n写在前面\n\n非官方店买笔记本，基本都是被换过硬件的，商家转卖硬件还可以赚二次利润。这也就是所谓的定制版、竞速版，以及那些官方没有的配置。\n\n我的这个，就是官配给卸了一根内存条、换了固态。这样算下来，一台笔记本，至少纯利润能赚300+。不过质量也没啥问题，毕竟官网的也抢不到。\n\n如果不是硬性需求，可以在官网买，实惠但是难抢。\n\n# 一、换电脑\n\n前几天下大暴雨，半夜屋里漏水，设备进水了，我有点恼火。\n\n正好一直有换笔记本的打算，那就换了吧，原来我用的是LenovoG510，当年高二会考，不会打字，我家又没电脑，无奈之下，我妈陪我在镇上买的，当时电脑程里一共就两台笔记本，我买了其中一个，3200软妹币，4+500的。\n\n后来大学期间，实在太卡了，就加了8G的内存条，之后又陪我肝了三年。见证我学计算机的一系列旅程。以后我打算继续珍藏这台笔记本。\n\n放一下G510跑分。\n\n{% asset_img 1.png %}\n\n再来R7000的跑分对比下\n\n{% asset_img 8.png %}\n\n我买的是[联想华南专卖店](https://item.jd.com/15548283300.html)的，京东方的屏、记忆科技的内存、佰维的固态（固态应该是换过的），8+512，5899，我是用白条支付的，分期服务费是247.74元，加利息一共是6146软妹币（官网16+512的是5599）。\n\n充电能开机，不过没激活的状态下，试玩了一下，也没啥问题，就签收了。性能比我那老电脑提升太多了，原先的屏幕上面的彩点都能看清，现在这个画面反而更细腻了。\n\n> 原来我一直以为是微软做的软件垃圾，像win10自带的工具，在我电脑都打不开，现在才知道，原来是我电脑太垃圾了。\n>\n> 现在秒开\n\n# 二、数据迁移\n\n本来是用360换机助手来迁移数据的，不过360这个软件做得可真狗，所谓的数据迁移，不过就是将你电脑上面的软件，再重新在360商店下载安装罢了，狗屁数据都没有，全新的。\n\n通过硬盘转移过去，又发现少东西，无法运行。\n\n无奈，我自己又从各种官网下载的指定版本，重新安装的，从昨天晚上7点一直整到现在，才整好。\n\n**softTools**\n\n* fiddler(抓包)\n* filezila(ftp传输数据)\n* fscapture(截屏+录屏)\n* obs-browser(华为云obs)\n* screentogif(gif截图)\n* speedpanx(速盘，百度网盘付费下载神器)\n* tim(2.3.2防撤回)\n* 微信(防撤回)\n* ssr(科学上网神器)\n* v2rayN(科学上网神器)\n* xmind(思维导图)\n* 百度网盘批量转存\n* 电脑管家(相对360来说，比较人性化了，360就是流氓)\n* 火绒安全软件(用来禁网最好不过，系统更新都能禁)\n* 人工桌面(鹿鸣小姐姐哦)\n* 数据恢复工具(原名recuva)\n* potplayer\n* typora\n* 微软运行库合集\n* 奇兔刷机\n* 爱思助手\n* wub停用系统更新\n* ~~picpick~~\n* VMware\n* ~~逍遥安卓模拟器~~\n\n**devTools**\n\n* git\n\n* webstorm\n* idea\n* pycharm\n* phpstorm\n* eclipse\n* vscode\n* sublime\n* notepad++\n* navicat\n* sqlyog\n* ~~cfree~~\n\n**office**\n\n* 自带的正版\n\n**adobeTools(adobe今年开始清网盗版软件了，说实话，不容易找了)**\n\n* ps\n* pr\n* fw\n* acrobat pro dc(pdf去水印神器，未安)\n\n**browser**\n\n* chrome(云端同步，书签、扩展、应用，都安好了，这是最快整好的，chrome牛逼)\n* edge\n* ie\n* 联想浏览器(自带的，懒得卸载了)\n* ~~opera~~\n* ~~firefox~~\n\n**develop(开发环境，当年都是我自己配置的解压版，所以直接复制就行了，但是也花费不少时间，虽然不大，但是代码这种文件零碎)**\n\n* java\n* nodejs\n* python\n* apache\n* tomcat\n* mysql\n* php\n* webpack\n* hexo\n\n**历史代码(竟然有1.8G)**\n\n**开发手册(入门时积累的，不过我现在直接看官方最新文档了，这个不咋看了)**\n\n> 以上还有好多软件没有整理上，一是感觉没必要了，二也是懒得整了。\n\n# 三、照片纪念\n\n**G510**\n\n{% asset_img g510.jpg %}\n\n**G510配置**\n\n{% asset_img 3.png %}\n\n**R7000**\n\n{% asset_img r7000.jpg %}\n\n**R7000配置**\n\n{% asset_img 4.jpg %}\n\n# 四、软件破解\n\n## 4.1 jetbrains系列\n\n将[jetbrains](http://cdn.meethigher.top/media/jetbrains-agent.jar)下载，放到C盘根目录下。然后打开软件，如图所示\n\n{% asset_img 5.png %}\n\n将下面激活码复制\n\n```html\n7UQ2GQ3EMM-eyJsaWNlbnNlSWQiOiI3VVEyR1EzRU1NIiwibGljZW5zZWVOYW1lIjoiZGFjaGVuc2t5IiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IiIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiQUMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiRFBOIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlBTIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkdPIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRNIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkNMIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJTMCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSRCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJQQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSTSIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJXUyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQiIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSU1UiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In1dLCJoYXNoIjoiMTI3OTY4NzcvMCIsImdyYWNlUGVyaW9kRGF5cyI6NywiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ==-PmTP0wXV+vHC6BEDTTP8/JSLOwX27+QH5Oz/6vy9EJhIiPD9E5wpGt+tWie9/CQggVDlWvuAve09E/FjUNmuSCTJvoIa3UL/bEDFknxEsCJUw6GeDUpth6Ku/tCOoUBwtxtfG27RCc/2eOUSAMhWAZ8qEuQqJmneixipx2AFi6wheztfM0qYLLQ66+k4hyukSlzvVpCrAf0+pYOoxWxLZ9qsMzYh8kIjuON3zxSr4Ua70hUi0o6i4bzq1SWOs5XeTzQjEG/spzXJJLQuE+ZRcNcMYrBsTn6Z327Q7MekThof3w7NNKaPMdaCcoHG6Cp0a1FdOUesX/4LMuQyBB4PqQ==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g==\n```\n\n重启软件后，点击左下角的registry，或者进入软件在help中registry\n\n{% asset_img 6.png %}\n\n> 其他软件，方法相同\n\n## 4.2 Navicat\n\n[下载keygen](http://cdn.meethigher.top/media/keygen.exe)\n\n[参考文章](https://www.cnblogs.com/hfxtest/p/12513210.html)\n\n# 五、加装内存\n\n[官方教程](https://www.bilibili.com/video/BV1rQ4y1A79e)\n\n[内存条店铺](https://item.taobao.com/item.htm?id=567563909637)\n\n拆后盖的过程太费劲了，拆了半个小时。拆完感叹一下，还得耐心啊，慢慢拆，注意后盖中间还有一个螺丝，被一个贴纸给盖住了。\n\n放个重新跑分的图\n\n只开启独显跑分\n\n{% asset_img 7.png %}\n\n开启集显+独显混合跑分\n\n{% asset_img 8.png %}","tags":["life"]},{"title":"Map双列集合","url":"/blog/2019/map/","content":"\n 学习一下Map双列集合\n\n<!--more-->\n\n# 第一章 Map集合\n\n## 1.1 概述\n\n现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即`java.util.Map`接口。\n\n我们通过查看`Map`接口描述，发现`Map`接口下的集合与`Collection`接口下的集合，它们存储数据的形式不同，如下图。\n\n{% asset_img Collection与Map.png Collection与Map %}\n\n* `Collection`中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。\n* `Map`中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。\n* `Collection`中的集合称为单列集合，`Map`中的集合称为双列集合。\n* 需要注意的是，`Map`中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。\n\n## 1.2  Map常用子类\n\n通过查看Map接口描述，看到Map有多个子类，这里我们主要讲解常用的HashMap集合、LinkedHashMap集合。\n\n* **HashMap<K,V>**：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。\n* **LinkedHashMap<K,V>**：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。\n\n> tips：Map接口中的集合都有两个泛型变量<K,V>,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量<K,V>的数据类型可以相同，也可以不同。\n\n## 1.3  Map接口中的常用方法\n\nMap接口中定义了很多方法，常用的如下：\n\n* `public V put(K key, V value)`:  把指定的键与指定的值添加到Map集合中。\n* `public V remove(Object key)`: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。\n* `public V get(Object key)` 根据指定的键，在Map集合中获取对应的值。\n* `boolean containsKey(Object key)  ` 判断集合中是否包含指定的键。\n* `public Set<K> keySet()`: 获取Map集合中所有的键，存储到Set集合中。\n* `public Set<Map.Entry<K,V>> entrySet()`: 获取到Map集合中所有的键值对对象的集合(Set集合)。\n\nMap接口的方法演示\n\n~~~java\npublic class Demo01Map {\n\tpublic static void main(String[] args) {\n//\t\tshow01();\n//\t\tshow02();\n//\t\tshow03();\n\t\tshow04();\n\t}\n\t/*\n\t * 演示put方法\n\t * V put(K key, V value);\n\t * 返回值：V\n\t * 存储键值对的时候，key不重复，返回值v是null\n\t * 存储键值对的时候，key重复，会使用新的value替换map中重复的value，返回被替换的value值\n\t */\n\tpublic static void show01() {\n\t\t//创建map，使用多态\n\t\tMap<String,Integer> map=new HashMap<>(); \n\t\tSystem.out.println(map.put(\"水冰儿\", 19));//没有重复的返回就为null\n\t\tSystem.out.println(map.put(\"水冰儿\", 20));//有重复的返回被替换的value值 19\n\t\t\n\t\tSystem.out.println(map.put(\"云韵\", 30));\n\t\tSystem.out.println(map.put(\"焰灵姬\", 28));\n\t\tSystem.out.println(map);\n\t\t\n\t}\n\t/*\n\t * 演示remove方法\n\t * V remove(Object key);\n\t * 返回值：V\n\t * key存在，返回被删除的值\n\t * key不存在，返回Null\n\t */\n\tpublic static void show02() {\n\t\tMap<String,Integer> map=new HashMap<>();\n\t\tmap.put(\"水冰儿\", 19);\n\t\tmap.put(\"焰灵姬\", 28);\n\t\tmap.put(\"妙妙\", 18);\n\t\tSystem.out.println(map);//{焰灵姬=28, 水冰儿=19, 妙妙=18}\n\t\tSystem.out.println(map.remove(\"水冰儿\"));//19\n\t\tSystem.out.println(map);//{焰灵姬=28, 妙妙=18}\n\t\tSystem.out.println(map.remove(\"林志颖\"));//null\n\t\tSystem.out.println(map);//{焰灵姬=28, 妙妙=18}\n\t}\n\t/*\n\t * 演示get方法\n\t * V get(Object key);\n\t * 返回值：V\n\t * 如果key存在，返回对应的value值\n\t * 如果key不存在，返回null\n\t *  \n\t */\n\tpublic static void show03() {\n\t\tMap<String,Integer> map=new HashMap<>();\n\t\tmap.put(\"水冰儿\", 19);\n\t\tmap.put(\"焰灵姬\", 28);\n\t\tmap.put(\"妙妙\", 18);\n\t\tSystem.out.println(map);//{焰灵姬=28, 水冰儿=19, 妙妙=18}\n\t\tSystem.out.println(map.get(\"水冰儿\"));//19\n\t\tSystem.out.println(map.get(\"紫女\"));//null\n\t}\n\t/*\n\t * 演示containsKey方法\n\t * boolean containsKey(Object key);判断集合中是否包含指定的key\n\t * 返回：boolean\n\t * 包含返回true\n\t * 不包含返回false\n\t * \n\t */\n\tpublic static void show04() {\n\t\tMap<String,Integer> map=new HashMap<>();\n\t\tmap.put(\"水冰儿\", 19);\n\t\tmap.put(\"焰灵姬\", 28);\n\t\tmap.put(\"妙妙\", 18);\n\t\tSystem.out.println(map.containsKey(\"水冰儿\"));//true\n\t\tSystem.out.println(map.containsKey(\"焰灵姬啊\"));//false\n\t\t\n\t}\n}\n~~~\n\n## 1.4   Map集合遍历——键找值方式\n\n键找值方式：即通过元素中的键，获取键所对应的值\n\n分析步骤：\n\n1. 获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:`keyset()`\n2. 遍历键的Set集合，得到每一个键。\n3. 根据键，获取键所对应的值。方法提示:`get(K key)`\n\n代码演示：\n\n~~~java\npublic class Demo02Map {\n\tpublic static void main(String[] args) {\n\t\tMap<String, Integer> map=new HashMap<>();\n\t\tmap.put(\"水冰儿\", 19);\n\t\tmap.put(\"妙妙\", 22);\n\t\tmap.put(\"焰灵姬\", 28);\n\t\t\n\t\t//Iterator迭代器遍历\n//\t\tIterator<String> i=map.keySet().iterator();\n//\t\twhile(i.hasNext()) {\n//\t\t\tString key=i.next();\n//\t\t\tSystem.out.println(key+map.get(key));\n//\t\t}\n\t\t\n\t\t//增强for遍历\n\t\tfor(String key:map.keySet()) {\n\t\t\tSystem.out.print(key);\n\t\t\tSystem.out.println(map.get(key));\n\t\t}\n\t}\n}\n~~~\n\n遍历图解：\n\n{% asset_img Map集合遍历方式一.png Map集合遍历方式一 %}\n\n## 1.5  Entry键值对对象\n\n我们已经知道，`Map`中存放的是两种对象，一种称为**key**(键)，一种称为**value**(值)，它们在在`Map`中是一一对应关系，这一对对象又称做`Map`中的一个`Entry(项)`。`Entry`将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历`Map`集合时，就可以从每一个键值对（`Entry`）对象中获取对应的键与对应的值。\n\n 既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法：\n\n* `public K getKey()`：获取Entry对象中的键。\n* `public V getValue()`：获取Entry对象中的值。\n\n在Map集合中也提供了获取所有Entry对象的方法：\n\n* `public Set<Map.Entry<K,V>> entrySet()`: 获取到Map集合中所有的键值对对象的集合(Set集合)。\n\n## 1.6 Map集合遍历——键值对方式\n\n键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。\n\n操作步骤与图解：\n\n1.  获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:`entrySet()`。\n\n2.  遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。\n3.  通过键值对(Entry)对象，获取Entry对象中的键与值。  方法提示:`getkey() getValue()`     \n\n~~~java\npublic class Demo03Map {\n\tpublic static void main(String[] args) {\n\t\t/*\n\t\t * Map.Entry<K,V>:在map接口中有一个内部接口Entry\n\t\t * 作用：当Map集合一创建，那么就会在Map集合中创建一个Entry对象，用来记录键和值（键值对对象，键与值的映射关系）\n\t\t */\n\t\t/*\n\t\t * Map集合遍历的第二种方式：使用Entry遍历\n\t\t * 实现步骤：\n\t\t * 1.使用Map中的方法，entrySet(),把集合中多个Entry对象取出来，存储到一个Set集合中\n\t\t * 2.遍历Set集合，获取每一个Entry对象\n\t\t * 3.使用对象中的方法getKey()和getValue()方法获取键与值\n\t\t * \n\t\t */\n\t\tMap<String, Integer> map=new HashMap<>();\n\t\tmap.put(\"水冰儿\", 19);\n\t\tmap.put(\"妙妙\", 22);\n\t\tmap.put(\"焰灵姬\", 28);\n//\t\tSystem.out.println(map);\n\t\t\n//\t\tSet<java.util.Map.Entry<String, Integer>> set=map.entrySet();//这个写法也没毛病\n\t\tSet<Entry<String, Integer>> set=map.entrySet();\n\t\t\n\t\t//使用Iterator迭代器遍历\n//\t\tIterator<Entry<String,Integer>> i=set.iterator();\n//\t\twhile(i.hasNext()) {\n//\t\t\tEntry<String,Integer> ii=i.next();\n//\t\t\tSystem.out.println(ii.getKey()+ii.getValue());\n//\t\t}\n\t\t\n\t\t//使用增强for遍历\n\t\tfor(Entry<String,Integer> ii:set) {\n\t\t\tSystem.out.println(ii.getKey()+ii.getValue());\n\t\t}\n\t}\n}\n~~~\n\n遍历图解：\n\n{% asset_img Map集合遍历方式二.png Map集合遍历方式二 %}\n\n> tips：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。\n\n## 1.7  HashMap存储自定义类型键值\n\n**HashMap存储自定义类型键值**\n\nMap集合保证key是唯一的：作为key的元素，必须重写`hashCode()`和`equals()`方法，以保证元素的唯一\n\n**练习**\n\n每个妹子（姓名，年龄）都有自己的出处。那么，既然有对应关系，则将妹子对象和动漫出处存储到map集合中。\n\n妹子作为键，出处作为值——show02方法\n\n出处作为键，妹子作为值——show01方法\n\n**代码演示**\n\n```java\nclass Person {\n\tprivate String name;\n\tprivate int age;\n\tpublic Person() {\n\t\t\n\t}\n\tpublic Person(String name,int age) {\n\t\tthis.name=name;\n\t\tthis.age=age;\n\t}\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + age;\n\t\tresult = prime * result + ((name == null) ? 0 : name.hashCode());\n\t\treturn result;\n\t}\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tPerson other = (Person) obj;\n\t\tif (age != other.age)\n\t\t\treturn false;\n\t\tif (name == null) {\n\t\t\tif (other.name != null)\n\t\t\t\treturn false;\n\t\t} else if (!name.equals(other.name))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Person [name=\" + name + \", age=\" + age + \"]\";\n\t}\n\t\n\t\n}\npublic class Demo03HashMapSavePerson {\n\tpublic static void main(String[] args) {\n\t\tshow01();\n//\t\tshow02();\n\t}\n\t/*\n\t * HashMap存储自定义类型键值\n\t * key:String类型\n\t * String类重写hashCode()和equals()方法，可以保证key唯一\n\t * value:Person类型\n\t * value可以重复（同名同年龄的人视为同一个）\n\t */\n\tpublic static void show01() {\n\t\tHashMap<String,Person> map=new HashMap<>();\n\t\tmap.put(\"斗罗大陆\", new Person(\"水冰儿\",18));\n\t\tmap.put(\"斗破苍穹\", new Person(\"云韵\",30));\n\t\tmap.put(\"天行九歌\", new Person(\"焰灵姬\",28));\n\t\tmap.put(\"梦塔雪迷城\", new Person(\"妙妙\",22));\n\t\tmap.put(\"斗破苍穹\", new Person(\"美杜莎\",32));\n\t\t\n\t\t//使用Iterator迭代器遍历\n\t\tSet<Entry<String, Person>> set=map.entrySet();\n\t\tIterator<Entry<String,Person>> i=set.iterator();\n\t\twhile(i.hasNext()) {\n\t\t\tEntry<String, Person> entry=i.next();\n\t\t\tSystem.out.println(entry.getKey()+\"=====\"+entry.getValue());\n\t\t}\n\t\t/*\n\t\t * 天行九歌=====Person [name=焰灵姬, age=28]\n\t\t * 斗罗大陆=====Person [name=水冰儿, age=18]\n\t\t * 斗破苍穹=====Person [name=美杜莎, age=32]\n\t\t * 梦塔雪迷城=====Person [name=妙妙, age=22]\n\t\t */\n\t}\n\t/*\n\t * HashMap存储自定义类型键值\n\t * key:Person类型\n\t * Person类重写hashCode()和equals()方法，可以保证key唯一\n\t * value:String类型\n\t * value可以重复（同名同年龄的人视为同一个）\n\t */\n\tpublic static void show02() {\n\t\tHashMap<Person,String> map=new HashMap<>();\n\t\tmap.put(new Person(\"水冰儿\",18),\"斗罗大陆\");\n\t\tmap.put(new Person(\"云韵\",30),\"斗破苍穹\");\n\t\tmap.put(new Person(\"焰灵姬\",28),\"天行九歌\");\n\t\tmap.put(new Person(\"妙妙\",22),\"梦塔雪迷城\");\n\t\tmap.put(new Person(\"美杜莎\",32),\"斗破苍穹\");\n\t\tmap.put(new Person(\"美杜莎\",31),\"斗破苍穹\");\n\t\t\n\t\t//使用增强for循环遍历\n\t\tfor(Person p:map.keySet()) {\n\t\t\tSystem.out.println(p+\"===\"+map.get(p));\n\t\t}\n\t\t/*\n\t\t * Person [name=妙妙, age=22]===梦塔雪迷城\n\t\t * Person [name=水冰儿, age=18]===斗罗大陆\n\t\t * Person [name=美杜莎, age=31]===斗破苍穹\n\t\t * Person [name=焰灵姬, age=28]===天行九歌\n\t\t * Person [name=美杜莎, age=32]===斗破苍穹\n\t\t * Person [name=云韵, age=30]===斗破苍穹\n\t\t */\n\t\t\n\t}\n}\n```\n\n* 当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须重写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。\n* 如果要保证map中存放的key和取出的顺序一致，可以使用`java.util.LinkedHashMap`集合来存放。\n\n## 1.8   LinkedHashMap\n\n我们知道HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要保证有序，还要速度快怎么办呢？\n\n在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。\n\n~~~java\npublic class Demo05LinkedHashMap {\n\tpublic static void main(String[] args) {\n\t\tHashMap<String, Integer> map=new HashMap<String, Integer>();\n\t\tmap.put(\"水冰儿\", 19);\n\t\tmap.put(\"妙妙\", 22);\n\t\tmap.put(\"焰灵姬\", 28);\n\t\tSystem.out.println(map);//{焰灵姬=28, 水冰儿=19, 妙妙=22}\n\t\t\n\t\tLinkedHashMap<String,Integer> list=new LinkedHashMap<String, Integer>();\n\t\tlist.put(\"水冰儿\", 19);\n\t\tlist.put(\"妙妙\", 22);\n\t\tlist.put(\"焰灵姬\", 28);\n\t\tSystem.out.println(list);//{水冰儿=19, 妙妙=22, 焰灵姬=28}\n\t\t\n\t}\n}\n~~~\n\n## 1.9 Hashtable\n\nHashMap:底层是一个哈希表，是一个线程不安全的集合，是多线程的集合，速度快。可以存储null值，null键\n\nHashtable:底层是一个哈希表，是一个线程安全的集合，是单线程集合，速度慢。不能存储null值，null键\n\nHashtable(Vector)在jdk1.2之后，被更先进的集合HashMap(ArrayList)取代了。\n\nHashtable的子类Properties仍然活跃在历史舞台，Properties集合是一个唯一和IO流相结合的集合。\n\nHashtable代码演示：\n\n```java\npublic class Demo06Hashtable {\n\tpublic static void main(String[] args) {\n\t\tHashMap<String,Integer> map=new HashMap<String,Integer>();\n\t\tmap.put(\"a\", null);\n\t\tmap.put(null, null);\n\t\tmap.put(null,1);\n\t\tSystem.out.println(map);//{null=1, a=null}\n\t\t\n\t\tHashtable<String, Integer> table=new Hashtable<String, Integer>();\n//\t\ttable.put(\"b\", null);//报错\n//\t\ttable.put(null,1);//报错\n//\t\ttable.put(null, null);//报错\n\t}\n}\n```\n\n## 1.10 Map集合练习\n\n**需求：**\n\n计算一个字符串中每个字符出现次数。\n\n**分析：**\n\n1.  获取一个字符串对象\n2.  创建一个Map集合，键代表字符，值代表次数。\n3.  遍历字符串得到每个字符。\n4.  判断Map中是否有该键。\n5.  如果没有，第一次出现，存储次数为1；如果有，则说明已经出现过，获取到对应的值进行++，再次存储。     \n6.  打印最终结果\n\n**代码：**\n\njavascript实现方法\n\n```javascript\nlet arr=\"chenchuancheng\";\nlet obj={};\nfor(let i=0;i<arr.length;i++){\n\tlet key=arr[i];\n\tif(obj[key]){\n\t\tobj[key]++;\n\t}else{\n\t\tobj[key]=1;\n\t}\n}\nconsole.log(arr);\nfor(let i in obj){\n\tconsole.log(i+\"出现了\"+obj[i]+\"次\");\n}\n```\n\njava实现方法\n\n~~~java\npublic class Demo07Practice {\n\tpublic static void main(String[] args) {\n\t\tString str=\"chenchuancheng\";\n\t\tString[] strArr=str.split(\"\");\n\t\tLinkedHashMap<String, Integer> list=new LinkedHashMap<String, Integer>();\n\t\tfor(String s:strArr) {\n\t\t\tif(list.containsKey(s)) {\n\t\t\t\tint num=list.get(s);\n\t\t\t\tlist.put(s, ++num);\n\t\t\t}else {\n\t\t\t\tlist.put(s,1);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//遍历方法1\n//\t\tSet<String> set=list.keySet();\n//\t\tfor(String s:set) {\n//\t\t\tSystem.out.println(s+\"出现了\"+list.get(s)+\"次\");\n//\t\t}\n\t\t\n\n\t\t//遍历方法2\n//\t\tSet<Entry<String, Integer>> set=list.entrySet();\n//\t\tIterator<Entry<String, Integer>> i=set.iterator();\n//\t\twhile(i.hasNext()) {\n//\t\t\tEntry<String,Integer> entry=i.next();\n//\t\t\tSystem.out.println(entry.getKey()+\"出现了\"+entry.getValue()+\"次\");\n//\t\t}\n\t\t\n\t\t//遍历方法3\n//\t\tSet<String> set=list.keySet();\n//\t\tIterator<String> i=set.iterator();\n//\t\twhile(i.hasNext()) {\n//\t\t\tString key=i.next();\n//\t\t\tSystem.out.println(key+\"出现了\"+list.get(key)+\"次\");\n//\t\t}\n\t\t\n\t\t//遍历方法4\n\t\tSet<Entry<String,Integer>> set=list.entrySet();\n\t\tfor(Entry<String,Integer> i:set) {\n\t\t\tSystem.out.println(i.getKey()+\"出现了\"+i.getValue()+\"次\");\n\t\t}\n\t}\n}\n~~~\n\n## 1.11 JDK9对集合添加的优化\n\n通常，我们在代码中创建一个集合（例如，List 或 Set ），并直接用一些元素填充它。 实例化集合，几个 add方法 调用，使得代码重复。\n\n~~~java\npublic class Demo01 {\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<>();\n        list.add(\"abc\");\n        list.add(\"def\");\n        list.add(\"ghi\");\n        System.out.println(list);\n    }\n}\n\n~~~\n\n**jdk9新特性**\n\nList接口，Set接口，Map接口，里面增加了一个静态的方法of，可以给集合一次性地添加多个元素\n\n**使用前提**\n\n当集合中元素的个数已经确定了，不再改变的时候使用\n\n**注意**\n\n1. of方法只适用于List、Set、Map，不使用与接口的实现类，比方说ArrayList、HashSet、HashMap\n2. of方法的返回值是一个不能改变的集合，集合不能再使用add或者put方法添加元素，会抛出异常\n3. Set接口和Map接口在调用of方法的时候，不能有重复的元素，否则也会抛出异常。\n\n**例子**\n\n~~~java\npublic class HelloJDK9 {  \n    public static void main(String[] args) {  \n        Set<String> str1=Set.of(\"a\",\"b\",\"c\");  \n        //str1.add(\"c\");这里编译的时候不会错，但是执行的时候会报错，因为是不可变的集合  \n        System.out.println(str1);  \n        Map<String,Integer> str2=Map.of(\"a\",1,\"b\",2);  \n        System.out.println(str2);  \n        List<String> str3=List.of(\"a\",\"b\");  \n        System.out.println(str3);  \n    }  \n} \n\n~~~\n\n需要注意以下两点：\n\n> 1:of()方法只是Map，List，Set这三个接口的静态方法，其父类接口和子类实现并没有这类方法，比如    HashSet，ArrayList等待；\n>\n> 2:返回的集合是不可变的；\n\n# 第二章  模拟斗地主洗牌发牌\n\n## 2.1 案例介绍\n\n按照斗地主的规则，完成洗牌发牌的动作。\n\n具体规则：\n\n1. 组装54张扑克牌将\n2. 54张牌顺序打乱\n3. 三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。\n4. 查看三人各自手中的牌（按照牌的大小排序）、底牌\n\n> 规则：手中扑克牌从大到小的摆放顺序：大王,小王,2,A,K,Q,J,10,9,8,7,6,5,4,3\n\n## 2.2 案例需求分析\n\n1.  准备牌：\n\n\n完成数字与纸牌的映射关系：\n\n使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。\n\n2.  洗牌：\n\n通过数字完成洗牌发牌\n\n3.  发牌：\n\n将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。\n\n存放的过程中要求数字大小与斗地主规则的大小对应。\n\n将代表不同纸牌的数字分配给不同的玩家与底牌。\n\n4.  看牌：\n\n通过Map集合找到对应字符展示。\n\n通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。\n\n## 2.3  实现代码步骤\n\n~~~java\n/*\n * 斗地主：\n * 1.准备牌\n * 2.洗牌\n * 3.发牌\n * 4.看牌\n */\npublic class DouDiZhu {\n\tpublic static void main(String[] args) {\n\t\t// 1.准备牌\n\t\tList<String> colors = List.of(\"♥\", \"♠\", \"♣\", \"♦\");\n\t\tList<String> numbers = List.of(\"2\", \"A\", \"K\", \"Q\", \"J\", \"10\", \"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\");\n\n\t\t// 存放牌\n\t\tMap<Integer, String> poker = new HashMap<Integer, String>();\n\t\tint key = 0;\n\t\tpoker.put(key++, \"大王\");\n\t\tpoker.put(key++, \"小王\");\n\t\tfor (String number : numbers) {\n\t\t\tfor (String color : colors) {\n\t\t\t\tpoker.put(key++, color + number);\n\t\t\t}\n\t\t}\n\t\t// 2.洗牌\n\t\t// 存放索引，用来排序\n\t\tList<Integer> pokerKey = new ArrayList<Integer>();\n\t\tfor (int i = 0; i < 54; i++) {\n\t\t\tpokerKey.add(i);\n\t\t}\n\t\tCollections.shuffle(pokerKey);\n\t\t// 3.发牌\n\t\t// 创建存放玩家牌序号的集合\n\t\tArrayList<Integer> no01 = new ArrayList<Integer>();\n\t\tArrayList<Integer> no02 = new ArrayList<Integer>();\n\t\tArrayList<Integer> no03 = new ArrayList<Integer>();\n\t\tArrayList<Integer> noDiPai = new ArrayList<Integer>();\n\n\t\tfor (int i = 0; i < pokerKey.size(); i++) {\n\t\t\tInteger p = pokerKey.get(i);\n\t\t\tif (i >= 51) {// 底牌发牌\n\t\t\t\tnoDiPai.add(p);\n\t\t\t} else if (i % 3 == 0) {// 玩家1发牌\n\t\t\t\tno01.add(p);\n\t\t\t} else if (i % 3 == 1) {// 玩家2发牌\n\t\t\t\tno02.add(p);\n\t\t\t} else if (i % 3 == 2) {// 玩家3发牌\n\t\t\t\tno03.add(p);\n\t\t\t}\n\t\t}\n\t\tCollections.sort(no01);\n\t\tCollections.sort(no02);\n\t\tCollections.sort(no03);\n\t\tCollections.sort(noDiPai);\n\t\t// 创建玩家的集合\n\t\tArrayList<String> player01 = new ArrayList<String>();\n\t\tArrayList<String> player02 = new ArrayList<String>();\n\t\tArrayList<String> player03 = new ArrayList<String>();\n\t\tArrayList<String> diPai = new ArrayList<String>();\n\t\tfor (Integer i : no01) {\n\t\t\tplayer01.add(poker.get(i));\n\t\t}\n\t\tfor (Integer i : no02) {\n\t\t\tplayer02.add(poker.get(i));\n\t\t}\n\t\tfor (Integer i : no03) {\n\t\t\tplayer03.add(poker.get(i));\n\t\t}\n\t\tfor (Integer i : noDiPai) {\n\t\t\tdiPai.add(poker.get(i));\n\t\t}\n\t\tSystem.out.println(\"焰灵姬：\" + player01);\n\t\tSystem.out.println(\"水冰儿：\" + player02);\n\t\tSystem.out.println(\"紫女：\" + player03);\n\t\tSystem.out.println(\"底牌：\" + diPai);\n\t}\n}\n~~~\n\n ","tags":["java"]},{"title":"《Love》","url":"/blog/2019/love/","content":"\n不瞒你说，看了这个，我又相信爱情了？\n\n<!--more-->\n\n\n> *I love you,*\n>\n> *Not only for what you are,*\n>\n> *But for what I am*\n>\n> *When I am with you.*\n\n> *I love you,*\n>\n> *Not only for what*\n>\n> *You have made of yourself,*\n>\n> *But for what*\n>\n> *You are making of me.*\n\n> *I love you,*\n>\n> *For the part of me*\n>\n> *That you bring out.*\n\n> *I love you,*\n>\n> *For putting your hand*\n>\n> *Into my heaped-up heart*\n\n> *And passing over,*\n>\n> *All the foolish,weak things*\n>\n> *That you can't help*\n>\n> *Dimly seeing there,*\n\n> *And for drawing out*\n>\n> *Into the light*\n>\n> *All the beautiful belongings*\n>\n> *That no one else had looked*\n>\n> *Quite far enough to find.*\n\n> *I love you because you* \n>\n> *Are helping me to make*\n>\n> *Of the lumber of my life*\n\n> *Not a tavern*\n>\n> *But a temple;*\n>\n> *Out of the works*\n>\n> *Of my every day*\n>\n> *Not a reproach*\n>\n> *But a song.*\n\n> *I love you*\n>\n> *Because you have done*\n>\n> *More than any creed*\n>\n> *Could have done*\n>\n> *To make me good,*\n\n> *And more than any fate*\n>\n> *Could have done*\n>\n> *To make me happy*\n\n> *You have done it*\n>\n> *Without a touch*\n>\n> *Without a word*\n>\n> *Without a sign*\n>\n> *You have done it*\n>\n> *By being yourself*\n\n> *Perhaps that is what* \n>\n> *Being a friend means*\n>\n> ***After all***","tags":["life","reading"]},{"title":"方法引用","url":"/blog/2020/method-reference/","content":"\n在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿什么参数做什么操作。\n\n那么考虑一种情况：如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑？  \n\n<!--more-->\n\n## 1 冗余的Lambda场景\n\n来看一个简单的函数式接口以应用`Lambda`表达式： \n\n```java\n@FunctionalInterface\npublic interface Printable {\n\t//定义字符串的抽象方法\n\tvoid print(String s);\n}\n```\n\n在 `Printable` 接口当中唯一的抽象方法 `print` 接收一个字符串参数，目的就是为了打印显示它。那么通过`Lambda` 来使用它的代码很简单： \n\n```java\npublic class Demo01Printable {\n\t// 定义一个方法，参数传递Printable接口，对字符串进行打印\n\tpublic static void printString(Printable p) {\n\t\tp.print(\"Hello World\");\n\t}\n\tpublic static void main(String[] args) {\n\t\t//调用printString方法，方法的参数Printable是一个函数式接口，所以可以传递Lambda表达式\n\t\tprintString(s->System.out.println(s));\n    }\n}\n```\n\n其中 `printString`方法只管调用 `Printable` 接口的 `print` 方法，而并不管 `print` 方法的具体实现逻辑会将字符串打印到什么地方去。而 `main` 方法通过`Lambda`表达式指定了函数式接口`Printable`的具体操作方案为：拿到 `String`（类型可推导，所以可省略）数据后，在控制台中输出它。  \n\n## 2 问题分析\n\n这段代码的问题在于，对字符串进行控制台打印输出的操作方案，明明已经有了现成的实现，那就是 `System.out` 对象中的 `println(String)` 方法。既然`Lambda`希望做的事情就是调用 `println(String)` 方法，那何必自己手动调用呢？ \n\n## 3 用方法引用改进代码\n\n能否省去`Lambda`的语法格式（尽管它已经相当简洁）呢？只要“引用”过去就好了：\n\n```java \npublic class Demo01Printable {\n\t// 定义一个方法，参数传递Printable接口，对字符串进行打印\n\tpublic static void printString(Printable p) {\n\t\tp.print(\"Hello World\");\n\t}\n\tpublic static void main(String[] args) {\n\t\t//调用printString方法，方法的参数Printable是一个函数式接口，所以可以传递Lambda表达式\n\t\t//printString(s->System.out.println(s));\n        printString(System.out::println);\n    }\n}\n```\n\n请注意其中的双冒号 `::`写法，这被称为“方法引用”，而双冒号是一种新的语法。 \n\n> 注意：\n>\n> 1. `System.out`对象是已经存在的 \n> 2. `println`方法也是已经存在的\n>\n> 所以我们可以使用方法引用来优化`Lambda`表达式，可以使用`System.out`方法直接调用`println`方法\n\n## 4 方法引用符\n\n双冒号`::`为引用运算符，而它所在的表达式被称为方法引用。\n\n如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者。 \n\n### **语义分析** \n\n例如上例中， `System.out` 对象中有一个重载的 `println(String)` 方法恰好就是我们所需要的。那么对于 `printString` 方法的函数式接口参数，对比下面两种写法，完全等效： \n\n* Lambda表达式写法：`s -> System.out.println(s);` \n* 方法引用写法： `System.out::println` \n\n第一种语义是指：拿到参数之后经`Lambda`之手，继而传递给 `System.out.println` 方法去处理。 \n\n第二种等效写法的语义是指：直接让 `System.out` 中的 `println` 方法来取代`Lambda`。两种写法的执行效果完全一样，而第二种方法引用的写法复用了已有方案，更加简洁。 \n\n> 注:Lambda 中，传递的参数一定是方法引用的那个方法可以接收的类型，否则会抛出异常 \n\n### **推导与省略** \n\n如果使用`Lambda`，那么根据“可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载形式——它们都将被自动推导。\n\n而如果使用方法引用，也是同样可以根据上下文进行推导。 \n\n函数式接口是`Lambda`的基础，而方法引用是`Lambda`的孪生兄弟。 \n\n下面这段代码将会调用 `println` 方法的不同重载形式，将函数式接口改为`String`类型的参数：  \n\n```java\n@FunctionalInterface\npublic interface Printable {\n\t//定义字符串的抽象方法\n\tvoid print(String s);\n}\n```\n\n由于上下文变了之后可以自动推导出唯一对应的匹配重载，所以方法引用没有任何变化： \n\n```java\npublic class Demo01Printable {\n\t// 定义一个方法，参数传递Printable接口，对字符串进行打印\n\tpublic static void printString(Printable p) {\n\t\tp.print(\"Hello World\");\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t//调用printString方法，方法的参数Printable是一个函数式接口，所以可以传递Lambda表达式\n\t\tprintString(s->System.out.println(s));\n\t\t\n\t\t/*\n\t\t * 分析：\n\t\t * Lambda表达式的目的，\n\t\t * 就是打印参数传递的字符串，把参数s传递给了System.out的对象，调用out对象中的方法println对字符串进行输出\n\t\t * 注意：\n\t\t * 1.System.out对象是已经存在的 2.println方法也是已经存在的\n\t\t * 所以我们可以使用方法引用来优化Lambda表达式\n\t\t * 可以使用System.out方法直接调用println方法\n\t\t */\n\t\tprintString(System.out::println);\n\t}\n}\n```\n\n这次方法引用将会自动匹配到 `println(String)` 的重载形式。  \n\n## 5 通过对象名引用成员方法\n\n这是最常见的一种用法，与上例相同。如果一个类中已经存在了一个成员方法： \n\n```java\npublic class Demo02MethodRerObject {\n\t//定义一个静态成员方法，传递字符串，把字符串按照大写输出\n\tpublic void printUpperCaseString(String str) {\n\t\tSystem.out.println(str.toUpperCase());\n\t}\n}\n```\n\n函数式接口仍然定义为： \n\n```java\n@FunctionalInterface\npublic interface Printable {\n\t//定义字符串的抽象方法\n\tvoid print(String s);\n}\n```\n\n那么当需要使用这个`printUpperCase`成员方法来替代`Printable`接口的Lambda的时候，已经具有了`Demo02MethodRefObject`类的对象实例，则可以通过对象名引用成员方法，代码为： \n\n```java\npublic class Demo03ObjectMethodReference {\n\t//定义一个方法，方法的参数传递Printable接口\n\tpublic static void printString(Printable p) {\n\t\tp.print(\"hello\");\n\t}\n\tpublic static void main(String[] args) {\n\t\t//调用printString方法，方法的参数Printable是一个函数式接口，所以可以传递Lambda表达式\n\t\tprintString(s->new Demo02MethodRerObject().printUpperCaseString(s));\n\t\t\n\t\t//使用方法引用来优化\n\t\tprintString(new Demo02MethodRerObject()::printUpperCaseString);\n\t}\n}\n```\n\n> 注意：如果里面的方法不是静态的话，则需要对象名::方法，这样使用；如果是静态方法，则可以直接使用类名::方法，这就是所谓的“可推导就是可省略”\n\n## 6 通过类名称引用静态方法\n\n由于在`java.lang.Math`类中已经存在了静态方法`abs`，所以当我们需要通过Lambda来调用该方法时，有两种写 法。首先是函数式接口： \n\n```java\npublic interface Calcable {\n\t//定义一个抽象方法，传递一个整数，对整数进行绝对值计算\n\tpublic abstract int calcAbs(int num);\n}\n```\n\n使用Lambda表达式和方法引用来实现\n\n```java\npublic class Demo04StaticMethodReference {\n\t//定义一个方法，传递计算绝对值的整数，和函数式接口Calcable\n\tpublic static int method(int num,Calcable c) {\n\t\treturn c.calcAbs(num);\n\t}\n\tpublic static void main(String[] args) {\n\t\t//调用method方法，传递计算绝对值的整数，和Lambda表达式\n\t\tSystem.out.println(method(-10,num->Math.abs(num)));\n\t\t/*\n\t\t * 使用方法引用\n\t\t * 1.Math类是存在的\n\t\t * 2.abs方法是静态的\n\t\t */\n\t\tSystem.out.println(method(-10,Math::abs));\n\t}\n}\n```\n\n在这个例子中，下面两种写法是等效的： \n\n* Lambda表达式： `n -> Math.abs(n)` \n* 方法引用： `Math::abs`  \n\n## 7 通过super方法引用成员方法\n\n如果存在继承关系，当Lambda中需要出现super调用时，也可以使用方法引用进行替代。首先是函数式接口： \n\n```java\n@FunctionalInterface\npublic interface Greetable {\n\t//定义一个见面的方法\n\tvoid greet();\n}\n```\n\n然后是父类`Human`的内容：  \n\n```java\nclass Human {\n\t//定义一个说你好的方法\n\tpublic void sayHello() {\n\t\tSystem.out.println(\"hello 我是Human!\");\n\t}\n}\n```\n\n最后是子类`Man`的内容\n\n```java\nclass Man extends Human {\n\n\t@Override\n\tpublic void sayHello() {\n\t\tSystem.out.println(\"Hello 我是Man!\");\n\t}\n\t//定义一个方法参数传递Greetable\n\tpublic void method(Greetable g) {\n\t\tg.greet();\n\t}\n\tpublic void show() {\n\t\t//调用method方法，方法的参数Greetable是一个函数式接口，所以可以传递Lambda表达式\n//\t\tmethod(()->{\n//\t\t\t//创建父类Human对象\n//\t\t\tHuman h=new Human();\n//\t\t\t//调用父类的sayHello\n//\t\t\th.sayHello();\n//\t\t});\n\t\t//因为有子父类关系，所以存在一个关键字super，代表父类，所以我们可以直接使用super调用父类的成员方法\n//\t\tmethod(()->super.sayHello());\n\t\t//使用方法引用 \n\t\tmethod(super::sayHello);\n\t}\n}\n```\n\n最后是主方法\n\n```java\npublic class Demo05SuperMethodReference {\n\tpublic static void main(String[] args) {\n\t\tnew Man().show();\n\t}\n}\n```\n\n在这个例子中，下面两种写法是等效的： \n\n* Lambda表达式： `() -> super.sayHello()` \n* 方法引用： `super::sayHello`  \n\n## 8 通过this引用成员方法\n\nthis代表当前对象，如果需要引用的方法就是当前类中的成员方法，那么可以使用`this::成员方法`的格式来使用方 法引用。首先是简单的函数式接口：  \n\n```java\n@FunctionalInterface\npublic interface Richable {\n\t//定义一个想买啥就买啥的方法\n\tvoid buy();\n}\n```\n\n下面是一个丈夫 `Husband` 类： \n\n```java\nclass Husband {\n\t//定义一个买房子的方法\n\tpublic void buyHouse() {\n\t\tSystem.out.println(\"北京二环内买一套四合院\");\n\t}\n\t//定义一个结婚的方法，参数传递Richable接口\n\tpublic void marry(Richable r) {\n\t\tr.buy();\n\t}\n\t//定义一个非常高兴的方法\n\tpublic void soHappy() {\n//\t\tmarry(()->{\n//\t\t\tthis.buyHouse();\n//\t\t});\n\t\tmarry(this::buyHouse);\n\t}\n}\n```\n\n开心方法 `beHappy` 调用了结婚方法 `marry` ，后者的参数为函数式接口 `Richable` ，所以需要一个Lambda表达式。 但是如果这个Lambda表达式的内容已经在本类当中存在了，则可以对 `Husband` 丈夫类进行修改： \n\n主方法：\n\n```java\npublic class Demo06ThisMethodReference {\n\tpublic static void main(String[] args) {\n\t\tnew Husband().soHappy();\n\t}\n}\n```\n\n在这个例子中，下面两种写法是等效的： \n\n* Lambda表达式： `() -> this.buyHouse()` \n* 方法引用：` this::buyHouse`  \n\n## 9 类的构造器引用\n\n由于构造器的名称与类名完全一样，并不固定。所以构造器引用使用 `类名称::new` 的格式表示。首先是一个简单的 `Person` 类：\n\n```java\npublic class Person {\n\tprivate String name;\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic Person(String name) {\n\t\tsuper();\n\t\tthis.name = name;\n\t}\n\n\tpublic Person() {\n\t\tsuper();\n\t\t// TODO Auto-generated constructor stub\n\t}\n}\n```\n\n然后是用来创建 `Person` 对象的函数式接口：  \n\n```java\n@FunctionalInterface\npublic interface PersonBuilder {\n\t//定义一个方法，根据传递的姓名传递Person对象返回\n\tPerson builderPerson(String name);\n}\n```\n\n要使用这个函数式接口，可以通过Lambda表达式，但是通过构造器引用，有更好的写法： \n\n```java\npublic class Demo07ClassConstructor {\n\t//定义一个方法，参数传递姓名和PersonBuilder接口，方法中通过姓名创建Person对象\n\tpublic static void printName(String name,PersonBuilder pb) {\n\t\tPerson person=pb.builderPerson(name);\n\t\tSystem.out.println(person.getName());\n\t}\n\tpublic static void main(String[] args) {\n\t\t//调用printName方法，方法的参数PersonBuilder接口是一个函数式接口，所以可以传递Lambda表达式\n//\t\tprintName(\"胡列娜\",name->new Person(name));\n\t\t\n\t\t//使用方法引用，构造方法new Person(String name)已知，创建对象方式new已知\n\t\t//就可以使用Person引用new创建对象\n\t\tprintName(\"胡列娜最美\",Person::new);\n\t}\n}\n```\n\n在这个例子中，下面两种写法是等效的： \n\n* Lambda表达式： `name -> new Person(name)` \n* 方法引用： `Person::new`  \n\n## 10 数组的构造器引用\n\n数组也是 `Object` 的子类对象，所以同样具有构造器，只是语法稍有不同。如果对应到Lambda的使用场景中时， 需要一个函数式接口： \n\n```java\n@FunctionalInterface\npublic interface ArrayBuilder {\n\t//创建一个int类型数组的方法，参数传递数组的长度，返回创建好的int类型数组\n\tint[] builderArray(int length);\n}\n```\n\n在应用该接口的时候，可以通过Lambda表达式，但是更好的写法是使用数组的构造器引用：  \n\n```java\npublic class Demo08ArrayConstructor {\n\t/*\n\t * 定义一个方法，方法的参数传递一个创建数组的长度和ArrayBuilder接口\n\t * 方法内部根据传递的长度，使用ArrayBuilder中的方法创建数组并且返回 \n\t */\n\tpublic static int[] createArray(int length,ArrayBuilder ab) {\n\t\treturn ab.builderArray(length);\n\t}\n\tpublic static void main(String[] args) {\n\t\t//调用createArray方法，传递数组的长度和Lambda表达式\n//\t\tSystem.out.println(createArray(10,length->new int[length]).length);\n\t\t\n\t\t/*\n\t\t * 使用方法引用\n\t\t * 已知创建的数组就是int[]数组\n\t\t * 已知数组的长度是length\n\t\t * 就可以使用方法引用\n\t\t */\n\t\tSystem.out.println(createArray(10,int[]::new).length);\n\t}\n}\n```\n\n在这个例子中，下面两种写法是等效的： \n\n* Lambda表达式： `length -> new int[length]` \n* 方法引用： `int[]::new`  \n\n\n\n","tags":["java"]},{"title":"移动web适配问题以及解决方案","url":"/blog/2019/mobile-web/","content":"\n唉，适配永远是个难题啊，不怕，点进来！\n\n<!--more-->\n\n## 一、移动web开发遇到的问题\n\n设备划分：\n\n{% asset_img 设备划分.png 设备划分 %}\n\n浏览器私有前缀：\n\n{% asset_img 浏览器私有前缀.png 浏览器私有前缀 %}\n\n平板、手机、电脑端，不同的页面有不同的需求。其实可以做出来几套方案，通过判断设备的类型，选择合适的方案。\n\n但是，这样会耗费大量的人力、财力。所以，接下来，总结三种比较流行的解决web适配的布局。\n\n\n\n## 二、移动web适配解决方案\n\n### 一、流式布局（百分比布局）\n\n 视觉窗口：viewport（webstorm中，viewport标签生成快捷键——vp tab），是移动端特有的，这是一个虚拟的区域，承载网页的浏。\n\n浏览器承载viewport,viewport承载网页。\n\n下面这个例子，就会自适应。\n\n```\n.box {\n\twidth:100%;\n\theight:500px;\n\tbackground-color:pink;\n}\n<div class=\"box\">\n    流式布局流式布局流式布局流式布局流式布局流式布局流式布局流式布局流式布局流式布局流式布局流式布局流\n    式布局流式布局流式布局流式布局流式布局流式布局流式布局流式布局流式布局流式布局流式布局流式布局流式\n    流式布局流式布局流式布局流式布局流式布局流式布局流式布局流式布局流式布局流式布局流式布局流式布局布局\n    流式布局流式布局流式布局流式布局流式布局流式布局流式布局流式布局流式布局流式布局流式布局流式布局流\n    流式布局流式布局流式布局流式布局流式布局流式布局流式布局流式布局流式布局流式布局流式布局式布局流式布局\n</div>\n```\n\n适配设置：\n\n如果任何设置都没有，默认走得就是viewport上的默认设置，可以不用默认的viewport设置，去设置新的viewport设置，达到适配的要求。\n\n```\n<meta name=\"viewport\">//这个最好紧接着编码设置\n```\n\nviewport功能：\n\n1. width：可以设置宽度\n2. height：可以设置高度\n3. initial-scale：可以设置默认的缩放比例\n4. user-scalable：可以设置是否允许用户自行缩放\n5. maximum-scale：可以设置最大缩放比例\n6. minimum-scale：可以设置最小缩放比例\n\n```\n在<meta name=\"viewport\" content=\"\">中设置，content里面有以上属性\n```\n\n可以使用jquery，但是不建议，jquery做了很多桌面浏览器的兼容问题，特别是兼容ie浏览器，但是移动端没有ie浏览器\n\n主流浏览器：chrome、火狐、safari浏览器、百度、360、qq\n\n移动端使用`h5 api`或者`zepto.js`的库（基于高版本浏览器开发）\n\n移动端常用布局是非固定像素布局，防止内容溢出，防止出现滚动条，提高用户体验\n\n```\nbox-sizing:border-box;\n```\n\n一般移动端是要取消点击时的高亮的\n\n```\n /*取消高亮*/\n tap-highlight-color:transparent;\n -webkit-tap-highlight-color: transparent;\n /*transparent表示全透明*/\n```\n\n关于图片下间隙\n\n```\n<div class=\"box\">\n    <img src=\"../images/banner_1.png\" alt=\"\">\n</div>\n```\n\ndiv高度为228px，图片高度为224px，会多出来4px\n\n因为：\n\nimg为行内块元素，跟文字基线对齐。比如，`agx`，g下面的尾巴就是多出来的下间隙。下面提出几种解决方案（任选其一）：\n\n1. 设置`display:block;`\n2. 设置`font-size:0;`\n3. 设置`line-height:0;`\n4. 设置`vertical-align`随便一个值都行\n\n两栏自适应\n\n```\n<style>\n.box1 {\n    float:left;\n    width:100px;\n    height:100px;\n    background: pink;\n}\n.box2 {\n    width:200px;\n    height:200px;\n    background: blue;\n    float:left;\n}\n.box3 {\n    /*overflow的目的是为了让这个元素绝对绝缘 bfc*/\n    overflow:hidden;\n}\n</style>\n<div class=\"box1\"></div>\n<!--<div class=\"box2\"></div>-->\n<div class=\"box3\">\n    1111111内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\n    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\n    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\n    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\n    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\n    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\n    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\n    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\n    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\n    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\n    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\n    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\n    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\n    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\n    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\n    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\n</div>\n```\n\n去掉overflow就会形成文本环绕，加上overflow的目的是为了让这个元素绝对绝缘\n\n### 二、响应式布局（bootstrap）\n\n响应式容器：\n\n响应式开发的原理bootstrap。\n\n假如有以下需求，\n\n1. 超小屏768px以下，容器宽度100%，背景蓝色\n2. 小屏768px-992px，当前容器宽度750px，背景绿色\n3. 中屏992px-1200px，当前容器宽度970px，背景红色\n4. 大屏1200px以上，当前容器宽度1170px，背景黄色\n\n要实现以上需求，可以通过`媒体查询`。\n\n使用媒体查询`@media`能针对不同屏幕区间设置不同的布局和样式（扩展:@keyframes帧动画，@font-face设置字体）\n\n```\n<div class=\"container\"></div>\n<style>\n* {\n    margin:0;\n    padding:0;\n}\n.container {\n    width:1000px;\n    height:1000px;\n    background-color: pink;\n    margin:0 auto;\n}\n/*使用媒体查询能针对不同屏幕区间设置不同的布局和样式*/\n/*如何使用媒体查询 关于媒体查询 @media*/\n/*@keyframes帧动画   @font-face设置字体*/\n@media screen and (max-width:768px) {\n    .container {\n        width:100%;\n        /*height:1000px;*/\n        height:1000px;\n        background-color: blue;\n    }\n}\n@media screen and (max-width:992px) and (min-width: 768px) {\n    .container {\n        width:750px;\n        height:1000px;\n        margin:0 auto;\n        background-color: green;\n    }\n}\n@media screen and (max-width:1200px) and (min-width: 992px) {\n    .container {\n        width:970px;\n        height:1000px;\n        margin:0 auto;\n        background-color: red;\n    }\n}\n@media screen and (min-width:1200px) {\n    .container {\n        width:1170px;\n        height:1000px;\n        margin:0 auto;\n        background-color: yellow;\n    }\n}\n</style>\n```\n\n**使用bootstrap的基本模板**\n\n```\n<!DOCTYPE html>\n<html lang=\"zh-CN\">\n<head>\n    <!--文档编码申明-->\n    <meta charset=\"utf-8\">\n    <!--要求当前网页使用浏览器最高版本的内核来渲染-->\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <!--视口的设置：视口的宽度和设备一致，默认的缩放比例和pc端一致，用户不能自行缩放-->\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1,user-scalable=0\">\n    <!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ -->\n    <!-- 优先加载和浏览器解释-->\n\n    <title>Bootstrap 101 Template</title>\n\n    <!-- Bootstrap -->\n    <link href=\"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css\" rel=\"stylesheet\">\n\n    <!-- html5shiv 和  respond 分别用来解决IE8版本浏览器不支持 H5标签和媒体查询的  不兼容问题-->\n    <!-- HTML5 shiv and Respond.js for IE8 support of HTML5 elements and media queries -->\n    <!-- 警告：不能以file形式打开，本地打开。最好http://打开 -->\n    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->\n    <!-- 在 IE 9 一下引入-->\n    <!--[if lt IE 9]>\n    <script src=\"../lib/html5shiv/html5shiv.min.js\"></script>\n    <script src=\"../lib/respond/respond.min.js\"></script>\n    <![endif]-->\n</head>\n<body>\n<h1>你好，世界！</h1>\n\n<table class=\"table table-hover\">\n    <thead>\n    <tr>\n        <th>#</th>\n        <th>First Name</th>\n        <th>Last Name</th>\n        <th>Username</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <th scope=\"row\">1</th>\n        <td>Mark</td>\n        <td>Otto</td>\n        <td>@mdo</td>\n    </tr>\n    <tr>\n        <th scope=\"row\">2</th>\n        <td>Jacob</td>\n        <td>Thornton</td>\n        <td>@fat</td>\n    </tr>\n    <tr>\n        <th scope=\"row\">3</th>\n        <td>Larry</td>\n        <td>the Bird</td>\n        <td>@twitter</td>\n    </tr>\n    </tbody>\n</table>\n\n<!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) -->\n<script src=\"https://cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js\"></script>\n<!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 -->\n<script src=\"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js\"></script>\n</body>\n</html>\n```\n\n**两种重置样式库：reset.css 和 normalize.css**\n\n共同点：都是重置样式库，增强浏览器表现一致性\n\n不同点：举个例子->ul\n`reset.css` list-style:none;---根据需求重置掉一些样式\n\n`normalize.css`  不会重置ul样式---本身已经在每个浏览器表现一致的元素，每个浏览器都有这个点，所以没有重置\n\n一句话：都是为了增强浏览器一致性地，但是normalize不会重置已经一致的元素。\n\n**使用bootstrap的栅格系统（12等份）**\n\n需求：\n\n大屏设备 lg 均分6等份\n\n中屏设备 md 均分4等份\n\n小屏设备 sm 均分3等份\n\n超小屏设备 xs 均分2 等份\n\n```\n<div class=\"container\">\n    <div class=\"row\">\n        <div class=\"col-lg-2 col-md-3 col-sm-4 col-xs-6\"></div>\n        <div class=\"col-lg-2 col-md-3 col-sm-4 col-xs-6\"></div>\n        <div class=\"col-lg-2 col-md-3 col-sm-4 col-xs-6\"></div>\n        <div class=\"col-lg-2 col-md-3 col-sm-4 col-xs-6\"></div>\n        <div class=\"col-lg-2 col-md-3 col-sm-4 col-xs-6\"></div>\n        <div class=\"col-lg-2 col-md-3 col-sm-4 col-xs-6\"></div>\n    </div>\n</div>\n```\n\n扩展：偏移offset，往后推push，往前拉pull，比如`col-xs-offset-3`默认是左偏移3格，`col-xs-push-9`往后推9格，`col-xs-pull-3`往前拉3格\n\n**响应式工具——bootstrap**\n\n需求：\n\n* 大屏设备 大屏设备显示\n* 中屏设备 中屏设备隐藏\n* 小屏设备 小屏设备显示\n* 超小屏设备 超小屏设备隐藏\n\n原生实现：\n\n```\n<style>\n    @media screen and (min-width:1200px) {\n        .box {\n            display:block;\n        }\n    }\n    @media screen and (min-width:992px) and (max-width:1200px) {\n        .box {\n            display:none;\n        }\n    }\n    @media screen and (min-width:768px) and (max-width:992px) {\n        .box {\n            display:block;\n        }\n    }\n    @media screen and (max-width:768px) {\n        .box {\n            display:none;\n        }\n    }\n</style>\n<div class=\"box\"></div>\n```\n\nbootstrap实现\n\n```\n<!--\nvisible-lg 大屏显示，其他隐藏\nvisible-md 中屏显示，其他隐藏\nvisible-sm 小屏显示，其他隐藏\nvisible-xs\n\n3.2版本以后，建议使用hidden https://v3.bootcss.com/css/原文档中提到过\n\nhidden-lg 大屏隐藏 其他显示\nhidden-md\nhidden-sm\nhidden-xs\n-->\n<div class=\"box visible-lg visible-sm\">内容</div>\n```\n\n**媒体查询-扩展**\n\n```\n.container {\n    width:100%;\n    height:1000px;\n    background-color: blue;\n}\n@media screen and (min-width:768px) {\n    .container {\n        width:750px;\n        background-color: green;\n    }\n}\n@media screen and (min-width:992px) {\n    .container {\n        width:970px;\n        background-color: red;\n    }\n}\n@media screen and (min-width:1200px) {\n    .container {\n        width:1170px;\n        background-color: orange;\n    }\n}\n```\n\n其实利用的是优先级的原理\n\n**before与after的理解**\n\n```\n<style>\n    .box {\n        width:200px;\n        height:200px;\n        background-color: pink;\n        margin:200px auto;\n        position:relative;\n    }\n    .box::before {\n        position:absolute;\n        top:10px;\n        left:10px;\n        width:20px;\n        height:20px;\n        content:\"\";\n        background-color: #fff;\n        border-radius:5px;\n        display:block;\n    }\n    .box::after {\n        position:absolute;\n        bottom:10px;\n        left:10px;\n        width:20px;\n        height:20px;\n        content:\"\";\n        background-color: #fff;\n        border-radius:5px;\n        display:block;\n    }\n</style>\n```\n\n实际效果:\n\n{% asset_img before与after理解.png before与after理解 %}\n\n\n\n### 三、rem布局\n\n**认识rem**\n\nrem是相对单位\n\nem大小是基于父元素的字体大小\n\nrem r====>root 根的意思,rem大小是基于html的字体大小\n\n```\n<style>\n    html {\n        font-size:10px;\n    }\n    body {\n        margin:0;\n        padding:0;\n        font-size:50px;\n        line-height:1;\n    }\n    .em {\n        font-size:2em;\n    }\n    .rem {\n        font-size:2rem;\n    }\n</style>\n<div class=\"em\">aaa</div>//字体是100px\n<div class=\"rem\">aaa</div>//字体是20px\n```\n\n看到上面的例子是不是理解了呢？\n\n**各种布局比较**\n\n1. 伸缩布局 flex\n2. 流式布局 百分比\n3. 响应式布局 媒体查询\n4. rem布局 通过控制html上的字体大小去控制页面上所有以rem为单位的基准值控制尺寸\n   1. 把px转化为rem\n   2. 页面制作的时候，psd上量取的px转成rem使用\n   3. 怎么换算？预设一个基准值，方便计算，100px\n   4. 适配的时候，设置基准值 320px 50px 怎么算使得(640px 100px == 320px 50px)\n   5. 换算公式：当前rem基准值=100/640*320=50\n\n1,2,3的共同点：元素只能做到宽度的适配（图片除外）\n\nrem布局：宽度和高度都能做到适配（等比缩放）\n\nrem搭配less简直完美","tags":["web"]},{"title":"音乐播放器","url":"/blog/2019/music-player/","content":"\n这是我一直想写的，之前一直抱怨说没时间，正好借软件工程这个空，写完了。写了11天，一天平均写俩小时吧。\n\n<!--more-->\n\n#### 项目名称\n\n[在线音乐播放器](https://github.com/meethigher/music-player)<本项目已开源>\n\n#### 感谢大佬\n\n* [孟坤](https://mkblog.cn/)\n* [metowolf](https://i-meto.com/)\n\n#### 项目环境\n\n运行环境：php 7.2+（开启扩展 curl_exec, file_get_contents, json_decode, openssl_encrypt ）\n\n#### 兼容性\n\n最好是`chrome内核`的浏览器，ie浏览器没做兼容。edge浏览器也有一些不兼容\n\n#### 项目功能\n\n1. 搜索音乐\n\n   * 支持选择播放源\n\n   * 支持键盘事件——up、down、enter\n\n* 支持搜索记录——回车选中直接搜索，鼠标点击直接搜索\n  * 支持分页加载\n\n2. 播放音乐\n\n   * 暂停/播放\n   * 上/下一首切换\n   * 音量以及播放进度调整（有个bug）\n   * 记忆音量——保存上一次音量的设置\n\n3. 显示歌词\n\n   * 歌词\n   * 海报\n   * 歌曲、歌手以及专辑文案显示\n\n4. 自定义歌单\n\n   * 添加音乐\n   * 清空列表\n   * 退出后保存上次的歌单\n\n#### 项目演示\n\n[演示地址](https://meethigher.top/music)","tags":["open","javascript","web","php"]},{"title":"我的父亲","url":"/blog/2020/my-father/","content":"\n今天送我爸去坐高铁，他要回烟台上班了。\n\n<!--more-->\n\n17号考完科三，就准备接我爸回家了，我俩两年没见了吧，大概。\n\n今年1月20日晚上的时候，我骑车去接我爸回家。当时零下七八度，而我爸，还是老样子，只是面容多了老态。\n\n我骑车带着他，他在后面，也不嫌冷，一直东扯一句西扯一句，当时我的嘴都给我冻麻了。\n\n当时还没有疫情，本来我爸计划着是2月6日返厂，因为疫情拖到2月11，后来又拖到现在。\n\n我妈正月十六就开工了，然后家里就剩我和我爸。\n\n我俩没太多的话说，因为我爸爱啰嗦，重复的话喜欢念叨，说多了就吵架，所以干脆不说。\n\n我在家里打游戏的时候，他在刷视频，我就说，别刷了！他就会把网关掉。\n\n他晚上7点就睡觉了，而我，一般到一两点。\n\n我睡觉的时候，他就会问，你不上网了？\n\n我说，不上了。\n\n他又说，那我看头条了。\n\n我才意识到，我说了一句，别刷视频，他之后一天没上网。\n\n本来我以为就他那脾气，肯定懒得不肯上班，结果我昨天问他，你准备啥时候返厂，他说，明天。\n\n当时着实给我吓了一跳，这应该是我爸第一次这么果断地下决心了。\n\n我问他你怎么走，他说，我走着去，还锻炼身体！\n\n我才发现，我俩是这么的像。\n\n当初上高中的时候，国庆节放假，我走了五六个小时，从学校走到家，就是因为当时想到我妈会上班，没人接我，我索性也就不麻烦我妈了，自己走回家，还锻炼身体。\n\n然后我给他订了高铁票，也就是今天3月12日，我又骑车送他去新汶，然后打车到泰安转烟台。\n\n我爸用的智能机，是我原来用奖学金给他买的，红米Pro。他一直说，手机不好。其实，像这种手机，只能算是入门机。\n\n但是今天在车站，别人给他打电话，他直接按绿色的打开通讯录，喂！\n\n我才知道，他到现在还是不会用智能机，尽管每天都在玩手机。等我以后，有钱了，给他换个老年机吧。\n\n我一直以为，懒人是永远改不了懒毛病的，我爸算是懒汉，但是他着实改点了一点。\n\n假期这段时间，他每天早起生炉子，然后，也慢慢学会了做饭，尽管不好吃。至少是能做出来了。\n\n我姥爷原来也是衣来伸手饭来张口，但是自从我姥姥病了之后，不能做饭了，我姥爷慢慢地就学会了做饭了，现在也算是小厨了，啥也会做。\n\n或许是他们觉得到了自己该照顾人的时候了。\n\n我妈跟我爸，在家说不到几句就吵架。临走这天，我妈给我爸放下了一百多块钱，还帮他收拾了煎饼跟鸡蛋，然后就上班了。我妈早上五点上班，晚上十点下班，还是抽出了时间，给我爸收拾东西。\n\n我爸跟我妈，婚姻并不幸福，我也不像别人家的孩子一样，自小父母天天吵架，甚至打架，我也形成了自己事自己做的习惯，也就是孤独吧，用孤僻形容更好一点，从来不会主动找人帮忙，即使父母。\n\n这是农村包办婚姻的后果，农村父母，只觉得，应该把儿女留在身边孝顺自己，才不关心后代幸不幸福。\n\n我没被父亲照顾过，因为他也不会照顾人，我也并不喜欢小孩子，我觉得，像我这种，人性上面，有缺陷的人，也不应该再去为人父母，不然又会有一个小孩，走我曾经的路了。\n\n不管父母感情如何吧，我是俩人的结晶，就算他俩没有感情，至少我与妈，我与爸，还是彼此有感情的，他们也是为了我而努力工作。\n\n我也要努力。","tags":["life"]},{"title":"java中其他强大的流","url":"/blog/2019/more-powerful-stream/","content":"\n之前一周学习了基础的IO流，现在学更牛逼的流！\n\n比如能够高效读写的缓冲流，能够转换编码的转换流，能够持久化存储对象的序列化流等等。这些功能更为强大的流，都是在基本的流对象基础之上创建而来的，就像穿上铠甲的武士一样，相当于是对基本流对象的一种增强。\n\n<!--more-->\n\n# 第一章 缓冲流\n\n## 1.1 概述\n\n缓冲流,也叫高效流，是对4个基本的`FileXxx` 流的增强，所以也是4个流，按照数据类型分类：\n\n* **字节缓冲流**：`BufferedInputStream`，`BufferedOutputStream` \n* **字符缓冲流**：`BufferedReader`，`BufferedWriter`\n\n缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。\n\n理解原理：\n\n{% asset_img 缓冲流的原理.png 缓冲流的原理 %}\n\n## 1.2 字节缓冲流\n\n### 1.2.1 字节缓冲输出流\n\n构造方法：\n\n * `BufferedOutputStream(OutputStream out)`  创建一个新的缓冲输出流，以将数据写入指定的底层输出流。 \n * `BufferedOutputStream(OutputStream out, int size)`  创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流。 \n\n参数：\n\n* `OutputStream out`：字节输出流，可以传递FileOutputStream，缓冲流会给FileOutputStream增加一个缓冲区，提高FileOutputStream的写入效率\n * `int size`：指定缓冲流内部缓冲区的大小，不指定就是默认的大小\n\n使用步骤：\n\n1. 创建一个FileOutputStream对象，构造方法中绑定要输出的目的地\n\n2. 创建BufferedOutputStream对象，构造方法中传递FileOutputStream对象，提高FileOutputStream的效率\n\n3. 使用BufferdOutputStream对象中的方法write，把数据写入到内部缓冲区中\n\n4. 使用BufferdOutputStream对象中的方法flush，把内部缓冲区中的数据刷新到文件中\n\n5. 释放资源（会调用flush,刷新数据），所以第四步可以省略\n\n案例：\n\n```java\npublic static void main(String[] args) {\n\t\ttry(FileOutputStream fos=new FileOutputStream(\"C:\\\\users\\\\kitchen\\\\desktop\\\\abc\\\\abc.txt\");\n\t\t\t\tBufferedOutputStream bos=new BufferedOutputStream(fos);) {\n\t\tbos.write(\"我把数据写入到内部缓冲区中\".getBytes());\n//\t\tbos.flush();\n//\t\tbos.close();\n\t\t//上面这几步不用再写，因为在jdk1.7中，自动刷新flush关闭close()\n\t} catch (Exception e) {\n\t\te.printStackTrace();\n\t}\n\t\t\n}\n```\n\n### 1.2.2 字节缓冲输入流\n\n构造方法：\n\n * `BufferedInputStream(InputStream in)` 创建一个 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。 \n * `BufferedInputStream(InputStream in, int size)` 创建具有指定缓冲区大小的 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。\n\n参数：\n\n * `InputStream in`：字节输入流，可以传递FileInputStream，缓冲流会给FileInputStream增加一个缓冲区，提高FileInputStream的读取效率\n * `int size`：指定缓冲流内部缓冲区的大小，不指定就是默认的大小\n\n使用步骤：\n\n1. 创建FileInputStream对象，构造方法中绑定要读取的数据源\n2. 创建BufferedInputStream对象，构造方法中传入FileInputStream对象，提高FileInputStream对象的读取效率\n3. 使用BufferedInputStream对象中的read方法，将数据读取到内部缓冲区中\n4. 释放资源\n\n案例：\n\n```java\npublic static void main(String[] args) {\n\t\ttry(FileInputStream fis=new FileInputStream(\"C:\\\\users\\\\kitchen\\\\desktop\\\\abc\\\\abc.txt\");\n\t\t\t\tBufferedInputStream bis=new BufferedInputStream(fis);) {\n\t\t\tint len=0;\n\t\t\tbyte[] b=new byte[1024];\n\t\t\twhile((len=bis.read(b))!=-1) {\n\t\t\t\tSystem.out.println(new String(b,0,len));\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();// TODO: handle exception\n\t\t}\n}\n```\n\n### 1.2.3 效率测试\n\n查询API，缓冲流读写方法与基本的流是一致的，我们通过复制大文件（277MB），测试它的效率。\n\n1. 基本流，代码如下：\n\n```java\npublic class Demo03Effectiveness {\n\tpublic static void main(String[] args) {\n\t\t//不使用字节缓冲流，277M文件复制11889毫秒\n\t\tlong beginTime=System.currentTimeMillis();\n\t\ttry(FileOutputStream fos=new FileOutputStream(\"C:\\\\Users\\\\kitchen\\\\Desktop\\\\abc\\\\copy.exe\");\n\t\t\t\tFileInputStream fis=new FileInputStream(\"C:\\\\Users\\\\kitchen\\\\Desktop\\\\PhpStorm-2019.2.5.exe\")) {\n\t\t\tbyte[] b=new byte[1024];\n\t\t\tint len=0;\n\t\t\twhile((len=fis.read(b))!=-1) {\n\t\t\t\tfos.write(b, 0, len);\n\t\t\t}\n\t\t\t\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tSystem.out.println(\"复制过程总共历时\"+(System.currentTimeMillis()-beginTime)+\"毫秒\");\n\t\t}\n    }\n}\n```\n\n2. 缓冲流，代码如下：\n\n```java\npublic class Demo03Effectiveness {\n\tpublic static void main(String[] args) {\n\t\t//使用字节缓冲流,277M文件复制1433毫秒\n\t\ttry(BufferedOutputStream bos=new BufferedOutputStream(new FileOutputStream(\"C:\\\\Users\\\\kitchen\\\\Desktop\\\\abc\\\\copy.exe\"));\n\t\t\t\tBufferedInputStream bis=new BufferedInputStream(new FileInputStream(\"C:\\\\Users\\\\kitchen\\\\Desktop\\\\PhpStorm-2019.2.5.exe\"))) {\n\t\t\tint len=0;\n\t\t\tbyte[] b=new byte[1024];\n\t\t\twhile((len=bis.read(b))!=-1) {\n\t\t\t\tbos.write(b, 0, len);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}finally {\n\t\t\tSystem.out.println(\"复制过程总共历时\"+(System.currentTimeMillis()-beginTime)+\"毫秒\");\n\t\t}\n    }\n}\n```\n\n如何更快呢？\n\n使用数组的方式，代码如下：\n\n```java\npublic class Demo03Effectiveness {\n\tpublic static void main(String[] args) {\n\t\t//使用字节缓冲流,277M文件复制480毫秒\n\t\ttry(BufferedOutputStream bos=new BufferedOutputStream(new FileOutputStream(\"C:\\\\Users\\\\kitchen\\\\Desktop\\\\abc\\\\copy.exe\"));\n\t\t\t\tBufferedInputStream bis=new BufferedInputStream(new FileInputStream(\"C:\\\\Users\\\\kitchen\\\\Desktop\\\\PhpStorm-2019.2.5.exe\"))) {\n\t\t\tint len=0;\n\t\t\tbyte[] b=new byte[1024*100];\n\t\t\twhile((len=bis.read(b))!=-1) {\n\t\t\t\tbos.write(b, 0, len);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}finally {\n\t\t\tSystem.out.println(\"复制过程总共历时\"+(System.currentTimeMillis()-beginTime)+\"毫秒\");\n\t\t}\n    }\n}\n```\n\n## 1.3 字符缓冲流\n\n### 1.3.1 字符缓冲输出流\n\n构造方法：\n\n* `BufferedWriter(Writer out)` 创建一个使用默认大小输出缓冲区的缓冲字符输出流。 \n * `BufferedWriter(Writer out, int sz)` 创建一个使用给定大小输出缓冲区的新缓冲字符输出流。 \n\n参数：\n\n`Writer out`：字符输出流。我们可以传递FileWriter，缓冲流会给FileWriter增加一个缓冲区，以提高FileWriter的写入效率\n\n`int sz`：指定缓冲区的大小，不写就是默认的大小。\n\n特有的成员方法：\n\nvoid newLine();写入一个行分割符。会根据不同的操作系统，获取不同的行分割符\n\n换行符：不同的操作系统，换行符也不同\n\nwindows：\\r\\n\n\nlinux：/n\n\nmax：\\r\n\n使用步骤：\n\n1. 创建一个字符缓冲输出流对象，构造方法中传递字符输出流\n2. 调用字符缓冲输出流中的方法write，把数据写入到内存缓冲区中\n3. 调用字符缓冲输出流中的方法flush，把内存缓冲区中的数据刷新到文件中\n4. 释放资源\n\n案例：\n\n```java\npublic class Demo04BufferedWriter {\n\tpublic static void main(String[] args) {\n\t\ttry(BufferedWriter bw=new BufferedWriter(new FileWriter(\"src\\\\demo36\\\\abc.txt\"))){\n\t\t\tfor(int i=0;i<10;i++) {\n\t\t\t\tbw.write(\"我是你爸爸，嘎嘎嘎\");\n\t\t\t\tbw.newLine();\n\t\t\t}\n\t\t}catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n```\n\n\n\n### 1.3.2 字符缓冲输入流\n\n构造方法\n\n* `BufferedReader(Reader in)` 创建一个使用默认大小输入缓冲区的缓冲字符输入流。 \n * `BufferedReader(Reader in, int sz)` 创建一个使用指定大小输入缓冲区的缓冲字符输入流。\n\n使用步骤：\n\n1. 创建字符缓冲输入流对象，构造方法中传递字符输入流\n\n2. 使用字符缓冲输入流对象中的方法read或者readLine，读取文本\n\n3. 释放资源\n\n构造举例，代码如下：\n\n```java\npublic class Demo05BufferedReader {\n\tpublic static void main(String[] args) {\n\t\ttry(BufferedReader br=new BufferedReader(new FileReader(\"src\\\\demo36\\\\abc.txt\"));){\n//\t\t\tString line=\"\";\n//\t\t\twhile((line=br.readLine())!=null) {\n//\t\t\t\tSystem.out.println(line);\n//\t\t\t}\n\t\t\t\n\t\t\tint len=0;\n\t\t\tchar[] b=new char[10];\n\t\t\twhile((len=br.read(b))!=-1) {\n\t\t\t\tSystem.out.println(new String(b,0,len));\n\t\t\t}\n\t\t}catch(IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n\n```\n\n### 1.3.3 两者的特有方法\n\n字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。\n\n* BufferedReader：`public String readLine()`: 读一行文字。 \n* BufferedWriter：`public void newLine()`: 写一行行分隔符,由系统属性定义符号。 \n\n`readLine`方法演示，代码如下：\n\n```java\npublic class BufferedReaderDemo {\n    public static void main(String[] args) throws IOException {\n      \t // 创建流对象\n        BufferedReader br = new BufferedReader(new FileReader(\"in.txt\"));\n\t\t// 定义字符串,保存读取的一行文字\n        String line  = null;\n      \t// 循环读取,读取到最后返回null\n        while ((line = br.readLine())!=null) {\n            System.out.print(line);\n            System.out.println(\"------\");\n        }\n\t\t// 释放资源\n        br.close();\n    }\n}\n```\n\n`newLine`方法演示，代如下：\n\n  ```java\npublic class BufferedWriterDemo throws IOException {\n    public static void main(String[] args) throws IOException  {\n      \t// 创建流对象\n\t\tBufferedWriter bw = new BufferedWriter(new FileWriter(\"out.txt\"));\n      \t// 写出数据\n        bw.write(\"我是\");\n      \t// 写出换行\n        bw.newLine();\n        bw.write(\"你\");\n        bw.newLine();\n        bw.write(\"爸爸\");\n        bw.newLine();\n\t\t// 释放资源\n        bw.close();\n    }\n}\n输出效果:\n我是\n你\n爸爸\n  ```\n\n## 1.4 练习:文本排序\n\n请将文本信息恢复顺序。\n\n```\n3.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。\n8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。\n4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。\n2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。\n1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。\n9.今当远离，临表涕零，不知所言。\n6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。\n7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。\n5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。\n```\n\n### 1.4.1 案例分析\n\n1. 逐行读取文本信息。\n2. 解析文本信息到集合中。\n3. 遍历集合，按顺序，写出文本信息。\n\n### 1.4.2 案例实现\n\n```java\npublic class Demo05TextSort {\n\tpublic static void main(String[] args) {\n\t\tMap<String,String> map=new HashMap<String,String>();\n\t\ttry(BufferedReader br=new BufferedReader(new FileReader(\"src\\\\demo36\\\\text.txt\"));\n\t\t\t\tBufferedWriter bw=new BufferedWriter(new FileWriter(\"src\\\\demo36\\\\textSort.txt\"))){\n\t\t\tString s=\"\";\n\t\t\twhile((s=br.readLine())!=null) {\n\t\t\t\tString[] arr=s.split(\"\\\\.\");\n\t\t\t\tmap.put(arr[0], arr[1]);\n\t\t\t}\n\t\t\tfor(String key:map.keySet()) {\n\t\t\t\tbw.write(key+\".\"+map.get(key));\n\t\t\t\tbw.newLine();\n\t\t\t}\n\t\t\t\n\t\t}catch(IOException e){\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n```\n\n\n\n# 第二章 转换流\n\n## 2.1 字符编码和字符集\n\n### 2.1.1 字符编码\n\n计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为**编码** 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为**解码** 。\n\n比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。\n\n编码:字符(能看懂的)--字节(看不懂的)\n\n解码:字节(看不懂的)-->字符(能看懂的)\n\n* **字符编码`Character Encoding`** : 就是一套自然语言的字符与二进制数之间的对应规则。\n\n  编码表:生活中文字和计算机中二进制的对应规则\n\n### 2.1.2 字符集\n\n* **字符集 `Charset`**：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。\n\n计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集（u8，u16，u32）等。\n\n{% asset_img 1_charset.jpg 1_charset.jpg %}\n\n可见，当指定了**编码**，它所对应的**字符集**自然就指定了，所以**编码**才是我们最终要关心的。\n\n* **ASCII字符集** ：\n  * ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。\n  * 基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。\n* **ISO-8859-1字符集**：\n  * 拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。\n  * ISO-8859-1使用单字节编码，兼容ASCII编码。\n* **GBxxx字符集**：\n  * GB就是国标的意思，是为了显示中文而设计的一套字符集。\n  * **GB2312**：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的\"全角\"字符，而原来在127号以下的那些就叫\"半角\"字符了。\n  * **GBK**：**最常用的中文码表**。是在GB2312标准基础上的扩展规范，使用了**双字节编码方案**，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。\n  * **GB18030**：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。\n* **Unicode字符集** ：\n  * Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。\n  * 它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。**最为常用的UTF-8编码**。\n  * UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：\n    1. 128个US-ASCII字符，只需一个字节编码。\n    2. 拉丁文等字符，需要二个字节编码。 \n    3. 大部分常用字（含中文），**使用三个字节编码**。\n    4. 其他极少使用的Unicode辅助字符，使用四字节编码。\n\n## 2.2 编码引出的问题\n\nFileReader读取项目IDE的默认编码。当读取windows系统中的文本文件时，采用的是系统的编码。如果两者不统一，就会出现问题。\n\n**编码：**字符(能看懂的)--字节(看不懂的)\n\n**解码：**字节(看不懂的)-->字符(能看懂的)\n\n```java\npublic class ReaderDemo {\n    public static void main(String[] args) throws IOException {\n        FileReader fileReader = new FileReader(\"E:\\\\File_GBK.txt\");\n        int read;\n        while ((read = fileReader.read()) != -1) {\n            System.out.print((char)read);\n        }\n        fileReader.close();\n    }\n}\n输出结果：\n���\n```\n\n那么如何读取GBK编码的文件呢？ \n\n## 2.3 InputStreamReader类  \n\n转换流`java.io.InputStreamReader`，是Reader的子类，是从字节流到字符流的桥梁。\n\n它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。（**指定编码表**） \n\n构造方法\n\n* `InputStreamReader(InputStream in)`: 创建一个使用默认字符集的字符流。 \n* `InputStreamReader(InputStream in, String charsetName)`: 创建一个指定字符集的字符流。\n\n使用步骤：\n\n1. 创建InputStreamReader对象，构造方法中传递字节输入流，和指定的编码表名称\n\n2. 使用InputStreamReader对象中的方法read读取文件\n\n3. 释放资源\n\n> 注意事项：\n>\n> 构造方法中指定的编码表名称要和文件的编码相同，否则会发生乱码\n\n构造举例，代码如下： \n\n```java\nInputStreamReader isr = new InputStreamReader(new FileInputStream(\"in.txt\"));\nInputStreamReader isr2 = new InputStreamReader(new FileInputStream(\"in.txt\") , \"GBK\");\n```\n\n指定编码读取\n\n```java\npublic class ReaderDemo2 {\n    public static void main(String[] args) throws IOException {\n      \t// 定义文件路径,文件为gbk编码\n        String FileName = \"E:\\\\file_gbk.txt\";\n      \t// 创建流对象,默认UTF8编码\n        InputStreamReader isr = new InputStreamReader(new FileInputStream(FileName));\n      \t// 创建流对象,指定GBK编码\n        InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FileName) , \"GBK\");\n\t\t// 定义变量,保存字符\n        int read;\n      \t// 使用默认编码字符流读取,乱码\n        while ((read = isr.read()) != -1) {\n            System.out.print((char)read); // ��Һ�\n        }\n        isr.close();\n      \n      \t// 使用指定编码字符流读取,正常解析\n        while ((read = isr2.read()) != -1) {\n            System.out.print((char)read);// 大家好\n        }\n        isr2.close();\n    }\n}\n```\n\n## 2.4 OutputStreamWriter类\n\n转换流`java.io.OutputStreamWriter` ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 \n\n构造方法\n\n- `OutputStreamWriter(OutputStream in)`: 创建一个使用默认字符集的字符流。 \n- `OutputStreamWriter(OutputStream in, String charsetName)`: 创建一个指定字符集的字符流。\n\n使用步骤：\n\n1. 创建一个OutputStreamWriter对象，构造方法中传递字节输出流和指定的编码表名称\n\n2. 使用OutputStreamWriter对象中的方法write，把字符转换成字节存储到缓冲区中（编码的过程）\n\n3. 使用OutputStreamWriter对象中的flush，把内存缓冲区的字节刷新到文件中（使用字节流写字节的过程）\n\n4. 释放资源\n\n构造举例，代码如下： \n\n```java\nOutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream(\"out.txt\"));\nOutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream(\"out.txt\") , \"GBK\");\n```\n\n指定编码写出\n\n```java\npublic class OutputDemo {\n    public static void main(String[] args) throws IOException {\n      \t// 定义文件路径\n        String FileName = \"E:\\\\out.txt\";\n      \t// 创建流对象,默认UTF8编码\n        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName));\n        // 写出数据\n      \tosw.write(\"你好\"); // 保存为6个字节\n        osw.close();\n      \t\n\t\t// 定义文件路径\n\t\tString FileName2 = \"E:\\\\out2.txt\";\n     \t// 创建流对象,指定GBK编码\n        OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FileName2),\"GBK\");\n        // 写出数据\n      \tosw2.write(\"你好\");// 保存为4个字节\n        osw2.close();\n    }\n}\n```\n\n## 2.5 转换流理解图解\n\n**转换流是字节与字符间的桥梁！**\n\n{% asset_img 2_zhuanhuan.jpg 2_zhuanhuan.jpg %}\n\n## 2.6 练习：转换文件编码\n\n将GBK编码的文本文件，转换为UTF-8编码的文本文件。\n\n### 2.6.1 案例分析\n\n1. 指定GBK编码的转换流，读取文本文件。\n2. 使用UTF-8编码的转换流，写出文本文件。\n\n### 2.6.2 案例实现\n\n```java\npublic class TransDemo {\n   public static void main(String[] args) {      \n    \t// 1.定义文件路径\n     \tString srcFile = \"file_gbk.txt\";\n        String destFile = \"file_utf8.txt\";\n\t\t// 2.创建流对象\n    \t// 2.1 转换输入流,指定GBK编码\n        InputStreamReader isr = new InputStreamReader(new FileInputStream(srcFile) , \"GBK\");\n    \t// 2.2 转换输出流,默认utf8编码\n        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(destFile));\n\t\t// 3.读写数据\n    \t// 3.1 定义数组\n        char[] cbuf = new char[1024];\n    \t// 3.2 定义长度\n        int len;\n    \t// 3.3 循环读取\n        while ((len = isr.read(cbuf))!=-1) {\n            // 循环写出\n          \tosw.write(cbuf,0,len);\n        }\n    \t// 4.释放资源\n        osw.close();\n        isr.close();\n  \t}\n}\n```\n\n# 第三章 序列化\n\n## 3.1 概述\n\nJava 提供了一种对象**序列化**的机制。用一个字节序列可以表示一个对象，该字节序列包含该`对象的数据`、`对象的类型`和`对象中存储的属性`等信息。字节序列写出到文件之后，相当于文件中**持久保存**了一个对象的信息。 \n\n反之，该字节序列还可以从文件中读取回来，重构对象，对它进行**反序列化**。`对象的数据`、`对象的类型`和`对象中存储的数据`信息，都可以用来在内存中创建对象。\n\n简单概念理解：\n\n**对象的序列化：**\n\n把对象以流的方式，写入到文件中保存，叫写对象，也叫对象的序列化。\n\n**对象的反序列化：**\n\n把文件中保存的对象，以流的方式读取出来，叫做读对象，也叫对象的反序列化。\n\n看图理解序列化： \n\n{% asset_img 3_xuliehua.jpg 3_xuliehua.jpg %}\n\n## 3.2 ObjectOutputStream类\n\n`java.io.ObjectOutputStream ` 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。\n\n构造方法\n\n* `public ObjectOutputStream(OutputStream out) `： 创建一个指定OutputStream的ObjectOutputStream。\n\n使用步骤：\n\n1. 创建一个ObjectOutputStream对象，构造方法中传递字节输出流\n\n2. 使用ObjectOutputStream对象中的方法writeObject，把对象写入到文件中\n\n3. flush\n\n4. close\n\n构造举例，代码如下：  \n\n```java\nFileOutputStream fileOut = new FileOutputStream(\"employee.txt\");\nObjectOutputStream out = new ObjectOutputStream(fileOut);\n```\n\n序列化操作\n\n1. 一个对象要想序列化，必须满足两个条件:\n\n* 该类必须实现`java.io.Serializable ` 接口，`Serializable` 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出`NotSerializableException` 。\n* 该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用`transient` 关键字修饰。\n\n```java\npublic class Employee implements java.io.Serializable {\n    public String name;\n    public String address;\n    public transient int age; // transient瞬态修饰成员,不会被序列化\n    public void addressCheck() {\n      \tSystem.out.println(\"Address  check : \" + name + \" -- \" + address);\n    }\n}\n```\n\n2.写出对象方法\n\n* `public final void writeObject (Object obj)` : 将指定的对象写出。\n\n```java\npublic class SerializeDemo{\n   \tpublic static void main(String [] args)   {\n    \tEmployee e = new Employee();\n    \te.name = \"zhangsan\";\n    \te.address = \"beiqinglu\";\n    \te.age = 20; \n    \ttry {\n      \t\t// 创建序列化流对象\n          ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"employee.txt\"));\n        \t// 写出对象\n        \tout.writeObject(e);\n        \t// 释放资源\n        \tout.close();\n        \tfileOut.close();\n        \tSystem.out.println(\"Serialized data is saved\"); // 姓名，地址被序列化，年龄没有被序列化。\n        } catch(IOException i)   {\n            i.printStackTrace();\n        }\n   \t}\n}\n输出结果：\nSerialized data is saved\n```\n\n## 3.3 ObjectInputStream类\n\nObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 \n\n构造方法\n\n* `public ObjectInputStream(InputStream in) `： 创建一个指定InputStream的ObjectInputStream。\n\n使用步骤：\n\n1. 创建一个ObjectInputStream对象，构造方法中传递字节输入流\n\n2. 使用ObjectInputStream对象中的readObject方法，读取保存对象的文件\n\n3. 释放资源\n\n4. 使用读取出来的对象\n\n反序列化操作1\n\n如果能找到一个对象的class文件，我们可以进行反序列化操作，调用`ObjectInputStream`读取对象的方法：\n\n- `public final Object readObject ()` : 读取一个对象。\n\n```java\npublic class DeserializeDemo {\n   public static void main(String [] args)   {\n        Employee e = null;\n        try {\t\t\n             // 创建反序列化流\n             FileInputStream fileIn = new FileInputStream(\"employee.txt\");\n             ObjectInputStream in = new ObjectInputStream(fileIn);\n             // 读取一个对象\n             e = (Employee) in.readObject();\n             // 释放资源\n             in.close();\n             fileIn.close();\n        }catch(IOException i) {\n             // 捕获其他异常\n             i.printStackTrace();\n             return;\n        }catch(ClassNotFoundException c)  {\n        \t// 捕获类找不到异常\n             System.out.println(\"Employee class not found\");\n             c.printStackTrace();\n             return;\n        }\n        // 无异常,直接打印输出\n        System.out.println(\"Name: \" + e.name);\t// zhangsan\n        System.out.println(\"Address: \" + e.address); // beiqinglu\n        System.out.println(\"age: \" + e.age); // 0\n    }\n}\n```\n\n**对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 `ClassNotFoundException` 异常。**  \n\n**反序列化操作2**\n\n**另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个`InvalidClassException`异常。**发生这个异常的原因如下：\n\n* 该类的序列版本号与从流中读取的类描述符的版本号不匹配 \n* 该类包含未知数据类型 \n* 该类没有可访问的无参数构造方法 \n\n`Serializable` 接口给需要序列化的类，提供了一个序列版本号。`serialVersionUID` 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。\n\n```java\npublic class Employee implements java.io.Serializable {\n     // 加入序列版本号\n     private static final long serialVersionUID = 1L;\n     public String name;\n     public String address;\n     // 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.\n     public int eid; \n\n     public void addressCheck() {\n         System.out.println(\"Address  check : \" + name + \" -- \" + address);\n     }\n}\n```\n\n## 3.4 序列化过程描述\n\n类实现了`Serializable`接口，就会根据类的定义，给`Person.class`文件，添加一个序列号。如果修改了类的定义，那么就会给`Person.class`文件中的序列号和`Person.text`文件中的序列号进行比较。\n\n如果是一样的，则反序列化成功；如果不一样，则抛出序列化冲突异常`InvalidClassException`\n\n解决方法：\n\n无论是否对类的定义进行修改，都不重新生成序列号，可以手动给类添加一个序列号\n\n格式：\n\n在Serializable接口规定，可序列化类可以通过声明`serialVersionUID`的字段（`static`,`final`,`long`型的），显示声明其自己的`serialVersionUID`\n\n```java\nstatic final long serialVersionUID=42L;\n```\n\n## 3.5 static与transient关键字比较\n\n`static关键字`：静态关键字\n\n静态优先于非静态加载到内存中（优先于对象进入到内存中），被static修饰的成员变量是不能被序列化的，序列化的都是对象。\n\n`transient关键字`：瞬态关键字\n\n被transient修饰的成员变量，不能被序列化。最终实现的效果跟static类似，但是没有static的含义。\n\n比较：\n\n将变量注释为`static`或者`transient`运行一下序列化和反序列化的程序，进行结果比较\n\n## 3.6 练习：序列化集合\n\n1. 将存有多个自定义对象的集合序列化操作，保存到`list.txt`文件中。\n2. 反序列化`list.txt` ，并遍历集合，打印对象信息。\n\n### 3.6.1 案例分析\n\n1. 把若干学生对象 ，保存到集合中。\n2. 把集合序列化。\n3. 反序列化读取时，只需要读取一次，转换为集合类型。\n4. 遍历集合，可以打印所有的学生信息\n\n### 3.6.2 案例实现\n\n```java\npublic class Demo07Practice {\n\tpublic static void main(String[] args) {\n\t\twrite();\n\t\tread();\n\t}\n\n\tpublic static void write() {\n\t\tArrayList<Person> list = new ArrayList<Person>();\n\t\tlist.add(new Person(\"水月儿\", 18));\n\t\tlist.add(new Person(\"邱若水\", 19));\n\t\tlist.add(new Person(\"水冰儿\", 20));\n\t\ttry (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"src\\\\demo37\\\\demo07.txt\"))) {\n\t\t\toos.writeObject(list);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tSystem.out.println(\"success\");\n\t}\n\n\tpublic static void read() {\n\t\tArrayList<Person> list = new ArrayList<Person>();\n\t\ttry (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"src\\\\demo37\\\\demo07.txt\"))) {\n\t\t\tlist = (ArrayList<Person>) ois.readObject();\n\t\t\tfor (Person p : list) {\n\t\t\t\tSystem.out.println(p.getName() + \" \" + p.getAge());\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n\n```\n\n\n#  第四章 打印流\n\n## 4.1 概述\n\n平时我们在控制台打印输出，是调用`print`方法和`println`方法完成的，这两个方法都来自于`java.io.PrintStream`类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。\n\n## 4.2 PrintStream类\n\n### 4.2.1 构造方法\n\n* `public PrintStream(String fileName)  `： 使用指定的文件名创建一个新的打印流。\n\n构造举例，代码如下：  \n\n```java\nPrintStream ps = new PrintStream(\"ps.txt\")；\n```\n\n### 4.2.2 改变打印流向\n\n`System.out`就是`PrintStream`类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个\"小把戏\"，改变它的流向。\n\n```java\npublic class Demo09PrintStream {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tSystem.out.println(\"我是在控制台输出的\");\n\t\t\n\t\tPrintStream ps=new PrintStream(\"src\\\\demo37\\\\demo09.txt\");\n\t\tSystem.setOut(ps);\n\t\tSystem.out.println(\"我是在文件中输出的\");\n\t\tps.close();\n\t}\n}\n```\n\n","tags":["java"]},{"title":"我的母亲","url":"/blog/2020/my-mother/","content":"\n听妈妈的话，别让她受伤。\n\n五一劳动节，我妈放了两天假，五一快乐吖！\n\n<!--more-->\n\n先放上一首歌，周杰伦的《听妈妈的话》\n\n<audio src=\"http://cdn.meethigher.top/media/tingmamadehua.mp3\" style=\"height:30px\" controls></audio>\n\n# 关于这首歌\n\n《听妈妈的话》\n\n* 长大后我开始明白\n\n* 为什么我 跑得比别人快\n\n* 飞得比别人高\n\n* 将来大家看的都是我画的漫画\n\n* 大家唱的都是 我写的歌\n\n* 妈妈的辛苦 不让你看见\n\n* 温暖的食谱在她心里面\n\n* 有空就得多握握她的手\n\n* 把手牵着一起梦游\n\n* 听妈妈的话 别让她受伤\n\n* 想快快长大 才能保护她\n\n* 美丽的白发 幸福中发芽\n\n* 天使的魔法 温暖中慈祥\n* 在你的未来\n* 音乐是你的王牌\n* 拿王牌谈个恋爱\n* 唉 我不想把你教坏\n* 还是听妈妈的话吧\n* 晚点再恋爱吧\n* 我知道你未来的路\n* 但妈比我更清楚\n* 你会开始学其他同学\n* 在书包写东写西\n* 但我建议最好写\n* 妈妈我会用功读书\n* 用功读书\n* 怎么会从我嘴巴说出\n* 不想你输\n* 所以要叫你用功读书\n* 妈妈织给你的毛衣\n* 你要好好的收着\n* 因为母亲节到的时候\n* 我要告诉她我还留着\n* 对了 我会遇到了周润发\n* 所以你可以跟同学炫耀\n* 赌神未来是你爸爸\n* 我找不到 童年写的情书\n* 你写完不要送人\n* 因为过两天你会在操场上捡到\n* 你会开始喜欢上流行歌\n* 因为张学友开始准备唱吻别\n\n我听得歌，很少。\n\n这是前几天无意间听到的一个首歌，很有感触。\n\n我下载了这首歌之后，发现是qmc3格式的，没法播放。\n\n看了大佬的一篇博客[QMC解码-某音乐解码](https://blog.csdn.net/oftoo/article/details/103159199)，把音乐转成了mp3。\n\n等我有时间，我会写一款开源工具的。可以批量实现路径下的图片高质量压缩、音乐的剪辑、音乐格式转换等功能的，因为这些工具，我都比较常用。虽然这些功能很简单，但是大多数都是不免费的。所以，我打算做一款开源免费软件。\n\n周董这首歌，我活了这么多年，竟然是在现在第一次听过，很惭愧啊。\n\n其中的歌词，很多有产生共鸣。\n\n我从小到大，都不是个好孩子。可能在别人眼里，我是个乖乖孩，不捣蛋，不调皮。这是我的性格的原因，但我本质上并不是个安分的孩子。\n\n小的时候，我被母亲逼迫着放羊，现在想起来，陪伴我童年的，没有小伙伴，是一群小动物。虽然有点苦涩，但也不免有点幸运了。独处，让我有了更多的时间去思考自己想要啥。就比方说，在做一些自己不喜欢做的事情上，我比大多数人坚持的时间都久。像我见过的同学，早上永远都是起不来那种，而我，就不一样，我曾经说早上五点起床跑步，然后这个习惯，我在大学里竟然坚持了两年，只不过后来将习惯改成了傍晚跑步了。我对自己的控制力，我自认为哈，是大多数人都比不上我的，这很大程度上，来源于童年那段苦涩的记忆。\n\n我很幸运，幸好我妈在我求学的这段日子里，都是一直在鼓励我。不然，依我的性格，可能高中的我就已经辍学了。而我现在，却在读大学，看到了除村里之外，更大的世界。我跟大多数人有一点不同的是，好多人都不想上学，都不想上课，而我觉得，上课上学，是世界上最幸福的事了，至少跟我放羊相比，上学上课，是真的轻松。身体不累，精神更不累，反而有收获。\n\n# 五一快乐\n\n平时，我妈上班的时候，我的作息还算是比较有规律，每天六点半就起了。\n\n放假第一天，就放纵了一下自己，打开好久不玩的王者荣耀，买了一个至尊宝的皮肤，用了5块钱的优惠券，然后玩了俩小时的游戏。睡得时候，已经两点多了，早上就起不来了。\n\n{% asset_img 1.jpg 至尊宝 %}\n\n大清早的我妈就骂骂咧咧地，说我在家里，“整天就知道在屋当门里baibai，这里也baibai，那里也baibai，我怎么就生了个儿，没生个闺女，人家闺女都知道干活，我生个儿长这么大还不干人事儿”。被妈念叨了这么多年，听不下去了，就会顶她一句，然后她过一会，又开始继续叨叨。\n\n我妈在家，我就不用自己操心吃啥了。打开电脑，想了想昨天小伙伴给提的关于腾讯课堂签到脚本的优化地方，想了一会，有点思路了，正要动手开写。我妈就喊我吃饭了。\n\n吃饭的时候，我妈又开始念叨我。说，我在家里，水果皮乱扔，扔花池里，找虫子了，多脏。\n\n我就说，虫子能把水果皮分解，分解之后的物质可以当成植物的养料，有啥不可？\n\n紧接着，我又打了一机灵，说，我现在用的筷子是我常用的那双吗？\n\n我妈就说，这是新的，你以为我跟你一样，用过的还要再用。\n\n我说这多浪费，又蘸糊一双新筷子。\n\n我就开始数落我妈，我说，我每天刷的碗筷，我顶多只用一双筷子，一个碗。别的碗筷都让你蘸糊了，我刷的碗筷都是你用过的，还说我能baibai，哪有你能baibai。\n\n我妈边吃饭边笑。这算是哭笑吧，对我很无奈，却又说不过我。\n\n我在家的这段日子，每天三顿饭，就是一边看电脑，一边啃馒头或者啃煎饼，顶多用到一双筷，一个碗。虽然生活上过得很邋遢，但精神上还是很富足的，每天都有收获。在家人眼里，我就很邋遢，我自己不觉得而已。\n\n跟网上描述的肥宅的日子一样。我的桌上，一台电脑，一堆莫名的纸团，一个垃圾袋，一个碗，一双筷子，一天的活动范围，就是这个桌子了。要啥拿啥。\n\n我妈又过来问，我出去买点东西，你去不？\n\n我说，不去，你给我买个牙膏回来吧。\n\n我妈又数落我，给你钱都不会花，东西都不会买（PS：这句话，曾经有另一个人也这么跟我说过，哈哈）。\n\n我答，我没啥要买的，干嘛还要出去买。我就开始又跟我妈讲大道理，我出去买东西，要整理自己装扮，还要奔波一番，然后，就是为了买一个牙膏，多么不值得，浪费时间，我还不如打游戏，还能收获精神上的愉悦。\n\n我妈又无奈地笑了，她不知多少次后悔生了我这样的一个儿子，这么懒。\n\n我看我妈很久没动身，我忍不住，就跟小时候一样，蹦跶蹦跶过去看她（从小到大，只有在妈面前，我才能感觉自己像个小孩子。哪怕是在我爸跟前，我都会以为自己是个大人，而我爸是个小孩子）。\n\n看到我妈在补袜子，我一眼就看明白了。我说，你是怕买鞋的时候，袜子漏脚指头被人笑话吧。\n\n我妈说，那可不，不然人家还以为咱们没钱买袜子。\n\n补完袜子，我妈得意洋洋地拿出了她10块钱买的一件衬衫，我妈穿上，我给她拍了照。我就笑她肚子大，我妈就说，她当年生我的时候，生下来7斤多，还是zuoma生，把她肚子撑大了。\n\n我问，zuoma生是啥。\n\n我妈说，就是生孩子的时候，屁股先出来。\n\n我说，哦，那我知道了，咱家羊羔生小羊的时候，就是腚先出来的，我看她生得费劲，就帮她拽出来了（我家那只被我从它妈肚子里拽出来的小红羊，这么多年了，现在已经很老很老了）。\n\n我妈又笑了。\n\n其实，我妈如果不上班的话，在家好好打扮一番，是超级好看的。\n\n今天是我妈笑得最多的一次，五一快乐吖！\n\n{% asset_img 2.jpg 我的母亲 %}\n\n---\n\n5月2号，我妈在摊煎饼，听到有人卖小鸭，就跑出去了。\n\n{% asset_img 3.jpg 大鹅大鸡小鸭 %}\n\n鹅还处在换毛季节，这种大的都是15一只。\n\n小鸭子8块钱一只，贼好看。抬头正好看到月亮，就拍下来了。\n\n五一假期，该玩的也玩了，接下来好好学习吧。\n\n\n\n","tags":["life"]},{"title":"java实现对音频的截取","url":"/blog/2020/music-split/","content":"\n想制作一个闹钟铃声来着，没有好的铃声截取平台，自己写一个\n\n<!--more-->\n\n<audio src=\"http://cdn.meethigher.top/media/honey.mp3\" style=\"height:30px\" controls></audio>\n\n今天突然觉得张艺兴的Honey很好听，于是就想做成手机铃声，我又没会员，没法下载，于是从qq上的Mv扒下来了一段，想做成铃声。\n\n奈何网上没有太好的平台，有一些好的平台，但是有收费限制，还有一些免费的平台，由于自身服务器的原因，网速很慢，于是就想用java自己写一个。\n\n无非就是读取字节流，然后输出字节流罢了。\n\n需要注意的换算单位\n\n> 1byte=8bit\n>\n> 1kbps=1024bps\n>\n> bps指bits per second，即传输速度，表示为比特/秒\n\n下面上代码\n\n```java\npublic class MusicSplit {\n\tpublic static void main(String[] args) throws IOException {\n\t\t//C:\\\\Users\\\\kitchen\\\\Desktop\\\\Honey-张艺兴.mp3\n\t\tFileInputStream fis=new FileInputStream(new File(\"C:\\\\Users\\\\kitchen\\\\Desktop\\\\Honey-张艺兴.mp3\"));\n\t\tFileOutputStream fos=new FileOutputStream(new File(\"C:\\\\Users\\\\kitchen\\\\Desktop\\\\Honey-张艺兴-00.mp3\"));\n\t\tint start=10;\n\t\tint stop=20;\n\t\tint bps=124;\n\t\tcutMusic(start,stop,bps,fis,fos);\n\t}\n\tpublic static void cutMusic(int start,int stop,int bps,FileInputStream fis,FileOutputStream fos) throws IOException {\n\t\tint begin=(start-1)*bps*1024/8;\n\t\tint end=stop*bps*1024/8;\n\t\tint len=0,total=0;\n\t\tbyte[] bytes=new byte[1024];\n\t\twhile((len=fis.read(bytes))!=-1) {\n\t\t\ttotal+=len;\n\t\t\tif(total<begin)\n\t\t\t\tcontinue;\n\t\t\tif(total>end)\n\t\t\t\tbreak;\n\t\t\tfos.write(bytes, 0, len);\n\t\t}\n\t}\n}\n```\n\n","tags":["java"]},{"title":"网络编程","url":"/blog/2020/network-programming/","content":"\n这学期计算机概论老师讲了三次握手协议，之前只是大概听懂了，没有深入。\n\n现在学习一下。\n\n<!--more-->\n\n# 第一章 网络编程入门\n\n## 1.1 软件结构\n\n- **C/S结构** ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。\n\n{% asset_img 1_cs.jpg cs.jpg %}\n\n**B/S结构** ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。\n\n{% asset_img 2_bs.jpg bs.jpg %}\n\n两种架构各有优势，但是无论哪种架构，都离不开网络的支持。**网络编程**，就是在一定的协议下，实现两台计算机的通信的程序。\n\n## 1.2 网络通信协议\n\n* **网络通信协议：**通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。\n\n\n* **TCP/IP协议：** 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。\n\n{% asset_img 3_tcp_ip.jpg tcp_ip.jpg %}\n\n上图中，TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能。\n链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。\n网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。\n运输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。\n应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。\n\n## 1.3 协议分类\n\n通信的协议还是比较复杂的，`java.net` 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。\n\n`java.net` 包中提供了两种常见的网络协议的支持：\n\n- **UDP**：用户数据报协议(User Datagram Protocol)。UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。\n\n  由于使用UDP协议**消耗资源小，通信效率高**，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。\n\n  但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。UDP的交换过程如下图所示。\n\n{% asset_img UDP通信图解.png UDP通信图解 %}\n\n特点：数据被限制在64kb以内，超出这个范围就不能发送了。\n\n例子：屏幕广播，QQ的聊天功能\n\n{% asset_img 网络连接.png 网络连接 %}\n\n数据报(Datagram):网络传输的基本单位 \n\n- **TCP**：传输控制协议 (Transmission Control Protocol)。TCP协议是**面向连接**的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。\n\n  在TCP连接中必须要明确**客户端**与**服务器端**，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。\n\n  - 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。\n    - 第一次握手，客户端向服务器端发出连接请求，等待服务器确认。\n    - 第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。\n    - 第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示。\n\n{% asset_img 4_tcp.jpg tcp.jpg %}\n\n​    完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。\n\n## 1.4 网络编程三要素\n\n### 1.4.1 协议\n\n* **协议：**计算机网络通信必须遵守的规则，已经介绍过了，不再赘述。\n\n### 1.4.2 IP地址\n\n**IP地址：指互联网协议地址（Internet Protocol Address）**，俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。\n\n**IP地址分类**\n\n* IPv4：是一个32位的二进制数，通常被分为4个字节，表示成`a.b.c.d` 的形式，例如`192.168.65.100` 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。\n\n* IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。\n\n  为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成`ABCD:EF01:2345:6789:ABCD:EF01:2345:6789`，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。\n\n**常用命令**\n\n* 查看本机IP地址，在控制台输入：\n\n```java\nipconfig\n```\n\n* 检查网络是否连通，在控制台输入：\n\n```java\nping 空格 IP地址\nping meethigher.top\n```\n\n**特殊的IP地址**\n\n* 本机IP地址：`127.0.0.1`、`localhost` 。\n\n### 1.4.3 端口号\n\n网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？\n\n如果说**IP地址**可以唯一标识网络中的设备，那么**端口号**就可以唯一标识设备中的进程（应用程序）了。\n\n* **端口号：用两个字节表示的整数，它的取值范围是0~65535**。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。\n\n利用`协议`+`IP地址`+`端口号` 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。\n\n{% asset_img ip地址与端口号.png ip地址与端口号 %}\n\n常用端口号：\n\n1. 网络端口-80端口 `meethigher.top:80` 这个能打开，就算不写80，访问的时候，也会默认加上。如果是`meethigher.top:70`就会报错\n2. 数据库 mysql是3306，oracle是1521\n3. Tomcat端口号是8080\n\n# 第二章 TCP通信程序\n\n## 2.1 概述\n\nTCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。\n\n**两端通信时步骤：**\n\n1. 服务端程序，需要事先启动，等待客户端的连接。\n2. 客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。\n\n**在Java中，提供了两个类用于实现TCP通信程序：**\n\n1. 客户端：`java.net.Socket` 类表示。创建`Socket`对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。\n2. 服务端：`java.net.ServerSocket` 类表示。创建`ServerSocket`对象，相当于开启一个服务，并等待客户端的连接。\n\n## 2.2 Socket类  \n\n`Socket` 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。\n\n### 2.2.1 构造方法\n\n* `public Socket(String host, int port)` :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址。  \n\n  > 小贴士：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。\n\n构造举例，代码如下：\n\n```java\nSocket client = new Socket(\"127.0.0.1\", 6666);\n```\n\n### 2.2.2 成员方法\n\n* `public InputStream getInputStream()` ： 返回此套接字的输入流。\n\n  * 如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。\n  * 关闭生成的InputStream也将关闭相关的Socket。\n\n* `public OutputStream getOutputStream()` ： 返回此套接字的输出流。\n\n  * 如果此Scoket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。\n  * 关闭生成的OutputStream也将关闭相关的Socket。\n\n* `public void close()` ：关闭此套接字。\n\n  * 一旦一个socket被关闭，它不可再使用。\n  * 关闭此socket也将关闭相关的InputStream和OutputStream 。 \n\n* `public void shutdownOutput()` ： 禁用此套接字的输出流。   \n\n  * 任何先前写出的数据将被发送，随后终止输出流。 \n\n## 2.3 ServerSocket类\n\n\n`ServerSocket`类：这个类实现了服务器套接字，该对象等待通过网络的请求。\n\n### 2.3.1 构造方法\n\n* `public ServerSocket(int port)` ：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。\n\n构造举例，代码如下：\n\n```java\nServerSocket server = new ServerSocket(6666);\n```\n\n### 2.3.2 成员方法\n\n* `public Socket accept()` ：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。 \n\n\n## 2.4 简单的TCP网络程序\t\n\n### 2.4.1 TCP通信分析图解\n\n1. 【服务端】启动,创建ServerSocket对象，等待连接。\n2. 【客户端】启动,创建Socket对象，请求连接。\n3. 【服务端】接收连接,调用accept方法，并返回一个Socket对象。\n4. 【客户端】Socket对象，获取OutputStream，向服务端写出数据。\n5. 【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。\n\n> 到此，客户端向服务端发送数据成功。\n\n{% asset_img 5_简单通信.jpg 简单通信 %}\n\n> 自此，服务端向客户端回写数据。\n\n6. 【服务端】Socket对象，获取OutputStream，向客户端回写数据。\n7. 【客户端】Scoket对象，获取InputStream，解析回写数据。\n8. 【客户端】释放资源，断开连接。\n\n{% asset_img tcp通信概述.png tcp通信概述 %}\n\n### 2.4.2 服务端\n\n步骤：\n\n1. 创建服务器ServerSocket，跟系统要指定的端口号\n2. 使用ServerSocket中的方法accept，获取到请求的客户端对象Socket\n3. 使用Socket对象中的方法getInputStream，获取网络字节输入流对象\n4. 使用网络自己输入流InputStream对象中的方法read，读取客户端发送的数据\n5. 使用Socket对象中的方法getOutputStream获取网络字节输出流OutputStream\n6. 使用网络字节输出流OutputStream对象中的方法write，给客户端回写数据\n7. 释放资源（Socket，ServerSocket）\n\n> 注意：\n>\n> 服务器端必须明确哪个客户端请求的服务器，所以可以用accept获取到请求的客户端对象Socket\n\n### 2.4.3 客户端\n\n步骤：\n\n1. 创建一个客户端对象Socket，构造方法中绑定服务器的ip地址和端口号\n2. 使用Socket对象中的方法getOutputStream，获取网络字节输出流对象\n3. 使用网络字节输出流对象OutputStream对象中的方法write，给服务器发送数据\n4. 使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象\n5. 使用网络字节输入流InputStream对象中的方法read，读取服务器返回的数据\n6. 释放资源\n\n> 注意：\n>\n> 1. 客户端和服务端进行交互，必须使用Socket，Socket中提供的网络流，不能使用自己创建的流对象\n> 2. 当我们创建客户端对象Socket，就会请求服务器，和服务器经过三次握手，建立连接\n>    如果服务器没有启动，就会抛出异常；如果服务器已经启动，那么就可以进行交互\n\n### 2.4.4 客户端向服务器发送数据\n\n**服务端实现：**\n\n```java\npublic class ServerTCP {\n    public static void main(String[] args) throws IOException {\n        System.out.println(\"服务端启动 , 等待连接 .... \");\n        // 1.创建 ServerSocket对象，绑定端口，开始等待连接\n        ServerSocket ss = new ServerSocket(6666);\n        // 2.接收连接 accept 方法, 返回 socket 对象.\n        Socket server = ss.accept();\n        // 3.通过socket 获取输入流\n        InputStream is = server.getInputStream();\n        // 4.一次性读取数据\n      \t// 4.1 创建字节数组\n        byte[] b = new byte[1024];\n      \t// 4.2 据读取到字节数组中.\n        int len = is.read(b)；\n        // 4.3 解析数组,打印字符串信息\n        String msg = new String(b, 0, len);\n        System.out.println(msg);\n        //5.关闭资源.\n        is.close();\n        server.close();\n    }\n}\n```\n\n**客户端实现：**\n\n```java\npublic class ClientTCP {\n\tpublic static void main(String[] args) throws Exception {\n\t\tSystem.out.println(\"客户端 发送数据\");\n\t\t// 1.创建 Socket ( ip , port ) , 确定连接到哪里.\n\t\tSocket client = new Socket(\"localhost\", 6666);\n\t\t// 2.获取流对象 . 输出流\n\t\tOutputStream os = client.getOutputStream();\n\t\t// 3.写出数据.\n\t\tos.write(\"你好么? tcp ,我来了\".getBytes());\n\t\t// 4. 关闭资源 .\n\t\tos.close();\n\t\tclient.close();\n\t}\n}\n```\n\n### 2.4.5 服务器向客户端回写数据\n\n**服务端实现：**\n\n```java\npublic class ServerTCP {\n    public static void main(String[] args) throws IOException {\n        System.out.println(\"服务端启动 , 等待连接 .... \");\n        // 1.创建 ServerSocket对象，绑定端口，开始等待连接\n        ServerSocket ss = new ServerSocket(6666);\n        // 2.接收连接 accept 方法, 返回 socket 对象.\n        Socket server = ss.accept();\n        // 3.通过socket 获取输入流\n        InputStream is = server.getInputStream();\n        // 4.一次性读取数据\n      \t// 4.1 创建字节数组\n        byte[] b = new byte[1024];\n      \t// 4.2 据读取到字节数组中.\n        int len = is.read(b)；\n        // 4.3 解析数组,打印字符串信息\n        String msg = new String(b, 0, len);\n        System.out.println(msg);\n      \t// =================回写数据=======================\n      \t// 5. 通过 socket 获取输出流\n      \t OutputStream out = server.getOutputStream();\n      \t// 6. 回写数据\n      \t out.write(\"我很好,谢谢你\".getBytes());\n      \t// 7.关闭资源.\n      \tout.close();\n        is.close();\n        server.close();\n    }\n}\n```\n\n**客户端实现：**\n\n```java\npublic class ClientTCP {\n\tpublic static void main(String[] args) throws Exception {\n\t\tSystem.out.println(\"客户端 发送数据\");\n\t\t// 1.创建 Socket ( ip , port ) , 确定连接到哪里.\n\t\tSocket client = new Socket(\"localhost\", 6666);\n\t\t// 2.通过Scoket,获取输出流对象 \n\t\tOutputStream os = client.getOutputStream();\n\t\t// 3.写出数据.\n\t\tos.write(\"你好么? tcp ,我来了\".getBytes());\n      \t// ==============解析回写=========================\n      \t// 4. 通过Scoket,获取 输入流对象\n      \tInputStream in = client.getInputStream();\n      \t// 5. 读取数据数据\n      \tbyte[] b = new byte[100];\n      \tint len = in.read(b);\n      \tSystem.out.println(new String(b, 0, len));\n\t\t// 6. 关闭资源 .\n      \tin.close();\n\t\tos.close();\n\t\tclient.close();\n\t}\n}\n```\n\n# 第三章 综合案例\n\n## 3.1 文件上传原理\n\n原理：\n\n客户端读取本地的文件，把文件上传到服务器，服务器再把上传的文件保存到服务器的硬盘上。\n\n步骤：\n\n1. 客户端使用本地的字节输入流，读取要上传的文件\n2. 客户端使用网络字节输出流，把读取到的文件上传到服务器\n3. 服务器使用网络字节输入流，读取客户端上传的文件\n4. 服务器使用本地字节输出流，把读取到的文件，保存到服务器的硬盘上\n5. 服务器使用网络字节输出流，给客户端回写一个\"上传成功\"\n6. 客户端使用网络字节输入流，读取服务器回写的数据\n7. 释放资源\n\n注意：\n\n1. 客户端和服务器和本地硬盘进行读写，需要使用自己创建的字节流对象（本地流）\n2. 客户端和服务器之间进行读写，必须使用Socket中提供的字节流对象（网络流）\n\n> 文件上传的原理，就是文件的复制，需要明确：\n>\n> 1. 数据源\n> 2. 数据目的地\n\n## 3.2 文件上传案例\n\n服务端：\n\n```java\npublic class Server {\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tServerSocket server=new ServerSocket(8888);\n\t\t\tSocket socket=server.accept();\n\t\t\tSystem.out.println(\"服务器启动！\");\n\t\t\tInputStream is=socket.getInputStream();\n\t\t\tFile file=new File(\"c:\\\\users\\\\kitchen\\\\desktop\\\\abc\");\n\t\t\tif(!file.exists()) {\n\t\t\t\tfile.mkdirs();\n\t\t\t}\n\t\t\tDate date=new Date();\n\t\t\tSimpleDateFormat sdf=new SimpleDateFormat(\"mm\");\n\t\t\tFileOutputStream fos=new FileOutputStream(file+\"\\\\\"+sdf.format(date)+\"娜扎.mp3\");\n\t\t\tint len=0;\n\t\t\tbyte[] b=new byte[1024];\n\t\t\twhile((len=is.read(b))!=-1) {\n\t\t\t\tfos.write(b, 0, len);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(\"整个复制过程耗时\"+(date.getTime()-System.currentTimeMillis())/1000);\n\t\t\tOutputStream os=socket.getOutputStream();\n\t\t\tos.write(\"上传成功\".getBytes());\n\t\t\tsocket.close();\n\t\t\tserver.close();\n\t\t\tfos.close();\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\t\n\t}\n}\n\n```\n\n客户端：\n\n```java\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tSocket socket=new Socket(\"localhost\", 8888);\n\t\t\tOutputStream os=socket.getOutputStream();\n\t\t\tFileInputStream fis=new FileInputStream(new File(\"c:\\\\users\\\\kitchen\\\\desktop\\\\穷哈-古力娜扎.mp3\"));\n\t\t\tint len=0;\n\t\t\tbyte[] b=new byte[1024];\n\t\t\twhile((len=fis.read(b))!=-1) {\n\t\t\t\tos.write(b, 0, len);\n\t\t\t}\n\t\t\tsocket.shutdownOutput();\n\t\t\tInputStream is=socket.getInputStream();\n\t\t\twhile((len=is.read(b))!=-1) {\n\t\t\t\tSystem.out.print(new String(b, 0, len));\n\t\t\t}\n\t\t\tsocket.close();\n\t\t\tfis.close();\n\t\t} catch (UnknownHostException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t\t\n\t}\n}\n```\n\n运行结果：\n\n出现了阻塞问题，客户端接收不到服务端返回的`上传成功`。\n\n原因：\n\n经过查找资料发现read()是一个阻塞函数，如果客户端没有声明断开`OutputStream`，那么它就会认为客户端仍旧可能发送数据。像read()这种阻塞读取函数，还有BufferedReader类中的readLine()、DataInputStream中的readUTF()等。\n\n解决方案：\n\n1. Socket任意一端在调用完write方法时，调用`shutdownOutput`方法关闭输出流。\n2. 发送数据时，约定数据的首部固定字节数为数据长度。\n3. 发送数据时，约定前几位返回数据byte[]长度大小或最后输出\\n或者\\r作为数据传输终止符。\n\n解决方案一：\n\n```java\nos.write(\"上传成功\".getBytes);\nos.flush();\nsocket.shutdownOutput();//调用shutdown通知对端请求完毕\n```\n\n> 缺点：\n>\n> 这个解决方案缺点非常明显，socket任意一端，都依赖于对方调用shutdownOutput()来完成read返回-1，如果任意一方没有执行shutdown函数，就会出现问题。所以我们一般都会在socket请求时设置连接的超时时间socket.setSoTimeout(5000)；以防止长时间没有响应造成系统瘫痪。\n\n解决方案二：\n\n> 优点：不依赖对方调用shutdown函数，响应较快\n>\n> 缺点：数据传输是最大字节数固定，需要双方事先约定好长度，伸缩性差。\n\n解决方案三：\n\n客户端\n\n```java\nos.write(\"我要上传数据\\n\".getBytes());\nos.flush();\n```\n\n服务端\n\n```java\nint len=0;\nbyte[] b=new byte[1];\nwhile((len=is.read(b))!=-1){\n    String str=new String(b);\n    if(str.equals(\"\\n\")){\n        break;\n    }else{\n        fos.write(b,0,len);\n    }\n}\n```\n\n> 这是对第二种方案的改良版，但不得不说，这是目前socket数据传输的最常用处理read()阻塞的解决方案\n\n### 3.2.1 文件上传分析图解\n\n1. 【客户端】输入流，从硬盘读取文件数据到程序中。\n2. 【客户端】输出流，写出文件数据到服务端。\n3. 【服务端】输入流，读取文件数据到服务端程序。\n4. 【服务端】输出流，写出文件数据到服务器硬盘中。\n\n{% asset_img 6_upload.jpg upload.jpg %}\n\n**服务端实现：**\n\n```java\npublic class FileUpload_Server {\n    public static void main(String[] args) throws IOException {\n        System.out.println(\"服务器 启动.....  \");\n        // 1. 创建服务端ServerSocket\n      \tServerSocket serverSocket = new ServerSocket(6666);\n  \t\t// 2. 建立连接 \n        Socket accept = serverSocket.accept();\n      \t// 3. 创建流对象\n      \t// 3.1 获取输入流,读取文件数据\n        BufferedInputStream bis = new BufferedInputStream(accept.getInputStream());\n        // 3.2 创建输出流,保存到本地 .\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"copy.jpg\"));\n\t\t// 4. 读写数据\n        byte[] b = new byte[1024 * 8];\n        int len;\n        while ((len = bis.read(b)) != -1) {\n            bos.write(b, 0, len);\n        }\n        //5. 关闭 资源\n        bos.close();\n        bis.close();\n        accept.close();\n        System.out.println(\"文件上传已保存\");\n    }\n}\n```\n\n**客户端实现：**\n\n```java\npublic class FileUPload_Client {\n\tpublic static void main(String[] args) throws IOException {\n        // 1.创建流对象\n        // 1.1 创建输入流,读取本地文件  \n        BufferedInputStream bis  = new BufferedInputStream(new FileInputStream(\"test.jpg\"));\n        // 1.2 创建输出流,写到服务端 \n        Socket socket = new Socket(\"localhost\", 6666);\n        BufferedOutputStream   bos   = new BufferedOutputStream(socket.getOutputStream());\n\n        //2.写出数据. \n        byte[] b  = new byte[1024 * 8 ];\n        int len ; \n        while (( len  = bis.read(b))!=-1) {\n            bos.write(b, 0, len);\n            bos.flush();\n        }\n        System.out.println(\"文件发送完毕\");\n        // 3.释放资源\n\n        bos.close(); \n        socket.close();\n        bis.close(); \n        System.out.println(\"文件上传完毕 \");\n\t}\n}\n```\n\n### 3.2.2 文件上传优化分析\n\n1. **文件名称写死的问题**\n\n   服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一，代码如下：\n\n```java\nFileOutputStream fis = new FileOutputStream(System.currentTimeMillis()+\".jpg\") // 文件名称\nBufferedOutputStream bos = new BufferedOutputStream(fis);\n```\n\n2. **循环接收的问题**\n\n   服务端，指保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件，代码如下：\n\n```java\n// 每次接收新的连接,创建一个Socket\nwhile（true）{\n    Socket accept = serverSocket.accept();\n    ......\n}\n```\n\n3. **效率问题**\n\n   服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化，代码如下：\n\n```java\nwhile（true）{\n    Socket accept = serverSocket.accept();\n    // accept 交给子线程处理.\n    new Thread(() -> {\n      \t......\n        InputStream bis = accept.getInputStream();\n      \t......\n    }).start();\n}\n```\n\n### 3.2.3 最终实现\n\n服务端\n\n```java\npublic class Demo02TcpServer {\n\tpublic static void main(String[] args) throws IOException {\n\t\tServerSocket server = new ServerSocket(8000);\n\t\twhile (true) {\n\t\t\tSocket socket = server.accept();\n\t\t\tnew Thread(() -> {\n\t\t\t\ttry {\n\t\t\t\t\tSystem.out.println(\"执行\");\n\t\t\t\t\tBufferedInputStream bis = new BufferedInputStream(socket.getInputStream());\n\t\t\t\t\tBufferedOutputStream bos;\n\t\t\t\t\tOutputStream os = socket.getOutputStream();\n\t\t\t\t\tFile file = new File(\"c:\\\\users\\\\kitchen\\\\desktop\\\\upload\");\n\t\t\t\t\tDate date=new Date();\n\t\t\t\t\tif(!file.exists()) {\n\t\t\t\t\t\tfile.mkdirs();\n\t\t\t\t\t}\n\t\t\t\t\tbos = new BufferedOutputStream(\n\t\t\t\t\t\t\tnew FileOutputStream(file.getAbsolutePath() + \"\\\\\" + (date.getTime())+ \"娜扎.mp3\"));\n\t\t\t\t\tint len = 0;\n\t\t\t\t\tbyte[] b = new byte[1024];\n\t\t\t\t\twhile ((len = bis.read(b)) != -1) {\n\t\t\t\t\t\tbos.write(b, 0, len);\n\t\t\t\t\t\tbos.flush();\n\t\t\t\t\t}\n\t\t\t\t\tos.write(\"上传成功\".getBytes());\n\t\t\t\t\tSystem.out.println(\"success!整个过程耗时\"+(System.currentTimeMillis()-date.getTime()));\n\t\t\t\t\tbis.close();\n\t\t\t\t\tbos.close();\n\t\t\t\t\tsocket.close();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}).start();\n\t\t}\n\t}\n}\n```\n\n客户端\n\n```java\npublic class Demo02TcpClient {\n\tpublic static void main(String[] args) throws UnknownHostException, IOException {\n\t\tSocket socket=new Socket(\"localhost\",8000);\n\t\tBufferedOutputStream bos=new BufferedOutputStream(socket.getOutputStream());\n\t\tBufferedInputStream bis=new BufferedInputStream(new FileInputStream(new File(\"c:\\\\users\\\\kitchen\\\\desktop\\\\穷哈-古力娜扎.mp3\")));\n\t\tInputStream is=socket.getInputStream();\n\t\tint len=0;\n\t\tbyte[] b=new byte[1024];\n\t\twhile((len=bis.read(b))!=-1) {\n\t\t\tbos.write(b, 0, len);\n\t\t}\n\t\tsocket.shutdownOutput();\n\t\twhile((len=is.read(b))!=-1) {\n\t\t\tSystem.out.print(new String(b,0,len));\n\t\t}\n\t\tsocket.close();\n\t\tbis.close();\n\t}\n}\n```\n\n## 3.3 模拟B\\S服务器(扩展知识点)\n\n模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。\n\n### 3.3.1 案例分析\n\n1. 准备页面数据，web文件夹。\n\n   复制到我们Module中，比如复制到day08中\n\n   {% asset_img 复制.png 复制 %}\n\n2. 我们模拟服务器端，ServerSocket类监听端口，使用浏览器访问\n\n   ~~~java\n   public static void main(String[] args) throws IOException {\n       \tServerSocket server = new ServerSocket(8000);\n       \tSocket socket = server.accept();\n       \tInputStream in = socket.getInputStream();\n      \t    byte[] bytes = new byte[1024];\n       \tint len = in.read(bytes);\n       \tSystem.out.println(new String(bytes,0,len));\n       \tsocket.close();\n       \tserver.close();\n   }\n   ~~~\n\n   {% asset_img 无法访问.jpg 无法访问 %}\n\n3. 服务器程序中字节输入流可以读取到浏览器发来的请求信息\n\n   {% asset_img 读取访问信息.jpg 读取访问信息 %}\n\n\nGET/web/index.html HTTP/1.1是浏览器的请求消息。/web/index.html为浏览器想要请求的服务器端的资源,使用字符串切割方式获取到请求的资源。\n\n~~~java\n//转换流,读取浏览器请求第一行\nBufferedReader readWb = new BufferedReader(new InputStreamReader(socket.getInputStream()));\nString requst = readWb.readLine();\n//取出请求资源的路径\nString[] strArr = requst.split(\" \");\n//去掉web前面的/\nString path = strArr[1].substring(1);\nSystem.out.println(path);\n~~~\n\n### 3.3.2 案例实现\n\n服务端实现：\n\n```java\npublic class SerDemo {\n    public static void main(String[] args) throws IOException {\n        System.out.println(\"服务端  启动 , 等待连接 .... \");\n        // 创建ServerSocket 对象\n        ServerSocket server = new ServerSocket(8888);\n        Socket socket = server.accept();\n        // 转换流读取浏览器的请求消息\n        BufferedReader readWb = new\n        BufferedReader(new InputStreamReader(socket.getInputStream()));\n        String requst = readWb.readLine();\n        // 取出请求资源的路径                        \n        String[] strArr = requst.split(\" \");\n        // 去掉web前面的/\n        String path = strArr[1].substring(1);\n        // 读取客户端请求的资源文件\n        FileInputStream fis = new FileInputStream(path);\n        byte[] bytes= new byte[1024];\n        int len = 0 ;\n        // 字节输出流,将文件写会客户端\n        OutputStream out = socket.getOutputStream();\n        // 写入HTTP协议响应头,固定写法\n        out.write(\"HTTP/1.1 200 OK\\r\\n\".getBytes());\n        out.write(\"Content-Type:text/html\\r\\n\".getBytes());\n        // 必须要写入空行,否则浏览器不解析\n        out.write(\"\\r\\n\".getBytes());\n        while((len = fis.read(bytes))!=-1){\n            out.write(bytes,0,len);\n        }\n        fis.close();\n        out.close();\n        readWb.close();\t\n        socket.close();\n        server.close();\n    }\n}\n\n```\n\n### 3.3.3 访问效果\n\n> 小贴士：不同的浏览器，内核不一样，解析效果有可能不一样。\n\n发现浏览器中出现很多的叉子,说明浏览器没有读取到图片信息导致。\n\n浏览器工作原理是遇到图片会开启一个线程进行单独的访问,因此在服务器端加入线程技术。\n\n~~~java\npublic class ServerDemo {\n    public static void main(String[] args) throws IOException {\n        ServerSocket server = new ServerSocket(8888);\n        while(true){\n            Socket socket = server.accept();\n            new Thread(new Web(socket)).start();\n        }\n    }\n    static class Web implements Runnable{\n        private Socket socket;\n\n        public Web(Socket socket){\n            this.socket=socket;\n        }\n\n        public void run() {\n            try{\n                //转换流,读取浏览器请求第一行\n                BufferedReader readWb = new\n                        BufferedReader(new InputStreamReader(socket.getInputStream()));\n                String requst = readWb.readLine();\n                //取出请求资源的路径\n                String[] strArr = requst.split(\" \");\n                System.out.println(Arrays.toString(strArr));\n                String path = strArr[1].substring(1);\n                System.out.println(path);\n\n                FileInputStream fis = new FileInputStream(path);\n                System.out.println(fis);\n                byte[] bytes= new byte[1024];\n                int len = 0 ;\n                //向浏览器 回写数据\n                OutputStream out = socket.getOutputStream();\n                out.write(\"HTTP/1.1 200 OK\\r\\n\".getBytes());\n                out.write(\"Content-Type:text/html\\r\\n\".getBytes());\n                out.write(\"\\r\\n\".getBytes());\n                while((len = fis.read(bytes))!=-1){\n                    out.write(bytes,0,len);\n                }\n                fis.close();\n                out.close();\n                readWb.close();\n                socket.close();\n            }catch(Exception ex){\n\n            }\n        }\n    }\n\n}\n~~~\n\n稍微简单一点的，更通俗易懂：\n\n```java\npublic class Demo03TcpServer {\n\tpublic static void main(String[] args) throws IOException {\n\t\tServerSocket server=new ServerSocket(4000);\n\t\twhile(true) {\n\t\t\tSocket socket=server.accept();\n\t\t\tnew Thread(()->{\n\t\t\t\ttry {\n\t\t\t\t\tBufferedReader br=new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\t\t\t\t\tString str=br.readLine();\n\t\t\t\t\tString[] strArr=str.split(\" \");\n\t\t\t\t\tString path=strArr[1].substring(1);\n\t\t\t\t\t//构造方法中绑定要读取的html路径\n\t\t\t\t\tFileInputStream fis=new FileInputStream(path);\n\t\t\t\t\tint len=0;\n\t\t\t\t\tbyte[] b=new byte[1024];\n\t\t\t\t\tOutputStream os=socket.getOutputStream();\n\t\t\t\t\t//写入http协议响应头，固定写法\n\t\t\t\t\tos.write(\"HTTP/1.1 200 OK\\r\\n\".getBytes());\n\t\t\t\t\tos.write(\"Content-Type:text/html\\r\\n\".getBytes());\n\t\t\t\t\t//必须写入空行，否则浏览器不解析\n\t\t\t\t\tos.write(\"\\r\\n\".getBytes());\n\t\t\t\t\twhile((len=fis.read(b))!=-1) {\n\t\t\t\t\t\tos.write(b, 0, len);\n\t\t\t\t\t}\n\t\t\t\t\tfis.close();\n\t\t\t\t\tsocket.close();\n\t\t\t\t\t\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}).start();\n\t\t}\n\t\t\n\t}\n}\n\n```\n\n**访问效果：**\n\n{% asset_img 运行结果pc.png 效果图 %}\n\n{% asset_img 运行结果android.png 效果图 %}\n\n{% asset_img 运行结果ios.png 效果图 %}\n\n**出现的bug**\n\n我在html加载的css样式，是把字体大小设置成50px，但是执行时，却没有渲染上样式，后来打印了一下执行过程。\n\n发现在多线程调用过程中，都是先调用的html，再调用css或者js，由此导致的样式没有加上，解决方案还不知道。\n\n该问题已经丢到[博客园](https://www.cnblogs.com/meethigher/p/12151827.html)上，等大佬解答吧，或者等我学成归来！","tags":["java"]},{"title":"php查看和开启扩展","url":"/blog/2019/php-extension/","content":"\n今天用到php的时候碰到了一点小问题\n\n<!--more-->\n\n碰到了一个问题，今天需要用到php的两个函数`curl_exec`和`openssl_encrypt`但是一直报错。\n\n后来百度了一下，弄明白了。\n\n**首先，**\n\n在localhost的根目录下，新建一个php.php文件\n\n```php\n<?php\n    phpinfo();\n?>\n```\n\n然后localhost/php.php，就能查看扩展的情况了。\n\n**其次，**\n\n在php.ini文件中，把两个扩展打开（也就是把扩展前面的注释去掉）\n\n对于curl来说，还要多一步找到对应php目录下libssh2.dll文件，复制到对应apache的bin文件夹下。\n\n**最后**\n\n之后重启，解决curl模块无法加载问题。 \n\n附两张图\n\ncurl扩展开启\n\n{% asset_img 1.png curl扩展 %}\n\nopenssl扩展开启\n\n{% asset_img 2.png openssl扩展 %}","tags":["php"]},{"title":"记华为云OBS的一次白嫖","url":"/blog/2020/obs/","content":"\n我用来做静态资源加速了，正好弥补了学生机带宽的缺点\n\n<!--more-->\n\n12号早上一醒来，打开b站，映入眼帘的两个大字**白嫖**。\n\n白嫖，我喜欢。\n\n具体看了一眼[视频](https://www.bilibili.com/video/BV17p4y1S7kj)\n\n其实仔细分析一波，就是up在拉人头，不过对用户也有好处，属于双赢，我就注册了。\n\n华为云叫OBS（Object Storage Service），阿里云叫OSS（Object Storage Service），腾讯云叫COS（Cloud Object Storage），商家显示出自家产品独一无二的特点，随便造名嘛，无所谓了。\n\n用了优惠券之后，总价234，抵扣了200，又用红包，总共支付了33元。买了两年40G存储、50G/月下行流量，现在就用来做静态资源的加速了。\n\n我自己的服务器是学生机，1M带宽，我之前的博客有分享大壁纸，网速125kb/s实在受不了。现在已经可以做到秒加载了。\n\n除了用来加速静态资源，还可以用来做个人网盘，支持分享，也不错。反正这33块钱花得很值。\n\n在配置obs绑定自定义域名的时候出了点问题，我工单反馈华为云，没屁用，好在群里有个大佬，分分钟帮我解决了。\n\n如果是文件的配置\n\n{% asset_img 1.png %}\n\n如果是文件夹的配置\n\n{% asset_img 2.png %}\n\n感谢大佬\n\n{% asset_img 3.png %}\n\n","tags":["obs"]},{"title":"PS学习笔记","url":"/blog/2020/photoshop-learn/","content":"\n整理一下ps学习过程中的知识点。\n\n<!--more-->\n\n# 一、基本工具\n\n## 1.1 移动工具\n\n* 快捷键：V\n* 多对象跨窗口移动的时候，按`shift键`加上`鼠标左键`拖拽可以快速定位到中心位置\n* 放大快捷键：alt+滚动鼠标中键，ctrl+加号，ctrl+0恢复至正常视图\n* 图层的显示与隐藏，图层的上下是有顺序的\n* 在图像被放大的时候，空格键+鼠标左键是可以拖动视野框的\n\n## 1.2 选区工具\n\n* 快捷键：M\n* 工具右下角有小三角符号的，右键或者长按鼠标左键可以展开更多工具\n* 一般有多工具的，可以通过shift+快捷键进行切换选择\n* 一般将背景图层，拖拽到右下角，新建一个复制图层，来p图\n\n## 1.3 矩形选区\n\n* 正方形选区：shift+鼠标左键\n* 取消选区：ctrl+D\n* 标尺快捷键：ctrl+R，用来辅助选区，用的时候，直接拖，删除的话，再拖回去\n* 中心建立选区：Alt+鼠标左键\n\n## 1.4 椭圆工具\n\n具体操作跟矩形选区差不多\n\n## 1.5 选区属性\n\n* 新选区\n* 添加到选区\n* 从选区减掉\n* 与选区交叉\n\n## 1.6 选区实例\n\n自己去练习\n\n## 1.7 羽化属性\n\n* 创建选区时，先设置一下羽化的像素值\n* 选区羽化值不能大于选区大小的百分之五十\n\n## 1.8 前景色与背景色\n\n* Alt+delete 填充前景色\n* Ctrl+delete 填充背景色\n* 前景色以及背景色可以在显示图标上直接点击，选择自己需要的颜色\n\n## 1.9 复制选区\n\n* 选区之后，按住Alt+移动，可以复制当前选区\n\n# 二、编辑工具\n\n## 2.1 污点修复工具\n\n* 快捷键：J\n* 中括号可以改变笔触的大小\n* 可以用选区把需要修复的地方框选上，再进行修复，这样不会影响到未选区域\n\n## 2.2 修复画笔工具\n\n* 快捷键：J\n* 使用前要先按住Alt键定义源点，即给电脑一个参考点，去修复污点部位\n* 修复画笔工具会根据源点图形，再参考修补部位附近图案对修补部位进行修复。\n\n## 2.3 仿制图章\n\n* 快捷键：S\n* 使用前先按住Alt键定义源点，即给电脑一个参考点，去修复污点补位\n* 仿制图章工具只会根据源点图形对修补部位就行修复\n\n## 2.4 修补工具\n\n* 快捷键：S\n* 使用前框选要修复的补位，然后左键直接把选区拖拽到好的地方\n* 修补工具会根据源点图形对修补部位周围图形进行修复\n\n## 2.5 红眼工具\n\n* 在眼睛红色区域直接点击，即可自动修补\n\n## 2.6 画笔工具\n\n* 快捷键：B\n* 画水平或者垂直的线，需要按住shift键\n* 可以更改硬度以及多种笔刷模式\n* 颜色是由前景色和背景色决定的\n* 笔刷的各项参数可以在`画笔设置面板`里进行详细设置 \n\n## 2.7 图案图章\n\n* 快捷键：S\n* 批量画出相同的图案\n* 编辑——定义图案，可以定义图章的图案\n* 定义图案的时候要注意图案的大小，如果不合适可以在图像——图像大小，里面进行调整设置。\n\n## 2.8 历史画笔\n\n* 快捷键：Y\n* 对图案进行局部的恢复，所以必须前期有一定的处理\n* 使用历史画笔的时候要注意设置好恢复的源点\n  {% asset_img 1.png 设置源点 %}\n* 恢复源点可以任意选择，不受操作顺序限制\n  {% asset_img 2.png 历史画笔进行修复 %}\n\n## 2.9 橡皮擦\n\n* 快捷键：E\n* 橡皮擦：用背景色对当前的图案进行填充\n* 背景橡皮擦：直接删除当前团，并且将背景图层转化成了普通图层\n* 魔术橡皮擦：魔棒自动删除所选择的选区范围内图形\n\n## 2.10 渐变工具\n\n* 快捷键：G\n* 渐变工具：默认是前景色与背景色控制其填充颜色\n* 按住shift可以辅助矫直拖拉直线\n* 左边的颜色对应的是起点颜色，即前景色；右边的颜色对应的是终点颜色，及背景色。\n\n# 三、矢量工具\n\n## 3.1 位图矢量及位图\n\n* 位图就是像素图，由一个个的像素点组成；矢量图是记录点到点的连线或者说程序算出来的图\n* 位图放大很多倍之后就会失真，可以看到像素点，类似于马赛克，所以有分辨率这一说\n* 矢量图是程序控制，对电脑要求相对较高，但无论放大多少倍也会很清晰。\n\n## 3.2 钢笔工具——形状\n\n* 钢笔工具快捷键：P\n* 形状图层：会在图层上面加一个矢量蒙板\n* 形状图层也会在路径里面进行显示及储存\n\n## 3.3 钢笔工具——路径\n\n* 钢笔工具快捷键：P\n* 路径在添加新的锚点之后不要松开鼠标左键，直接拖拉，可以生成两条调整线，可以调路径的长短以及该点的曲率\n* 按住Alt点击调整点可以调整曲率\n* 按住ctrl点击画好的路径，可以生成选区\n\n## 3.4 路径编辑\n\n* 快捷键：A\n* 路径选择工具只会移动整个路径，而移动路径针对的是整个图层\n* 直接选择工具针对的是锚点，而非整个路径\n\n## 3.5 自由钢笔\n\n* 自由钢笔工具直接按住鼠标左键进行拖动即可创建路径。\n* 弯度钢笔工具创建路径也是通过添加锚点生成的，但是其自带一定的曲率，按住鼠标左键拖拽只能调整锚点的位置。\n* 矩形工具创建的是形状路径，可以选择多种形状。 \n\n## 3.6 文字编辑\n\n* 文字蒙板工具可以直接创建出文字的选区\n* 文字创建时点击已存在的路径，可以使文字沿着路径排布，切换到移动工具后，路径会自动隐藏\n* 如果文字工具在封闭的路径内部写入文字，文字会在以路径为区域，自动填满\n\n## 3.7 快捷操作\n\n* 按住Alt+鼠标滚轮键可以快读的放大缩小\n* 按住空格键+鼠标左键拖动可以快速移动图片\n* 按一下D可以快速将前景色和背景色恢复默认\n* 按一下X可以快速切换前景色及背景色\n\n# 四、模式编辑\n\n## 4.1 灰度模式\n\n* 灰度模式：最多包含256种灰度的8位图像\n* 模式含义：不用模式对颜色的分类甚至种类都不一样，可以理解为格式不一样\n* 灰度模式：可以在RGB格式下去色处理达到类似效果，但是概念不一样\n\n## 4.2 位图模式\n\n* 位图模式：黑白两种颜色组成，针对的是原来是灰度模式的图像\n* RGB模式不能直接切换到位图或者双色调模式，需要先切换到灰度模式才可以\n\n## 4.3 双色调模式\n\n* 双色调模式：用多种颜色来替换灰色，也是针对灰色模式来说的\n* RGB模式不能直接切换到位图或者双色调模式，需要先切换到灰度模式才行\n\n## 4.4 RGB与CMYK模式\n\n* RGB模式：ps默认模式，所有绘画工具或者滤镜都可以用，可以容纳1670万种颜色，用于屏幕显示，属于发光色。红绿蓝每个基本颜色的值为0-255\n* CMYK模式用于打印或者印刷色泽连续的图形，属于反光色，每个基本色是按浓度来说的，值就是0%-100%\n\n## 4.5 亮度对比度\n\n* 对比度就是亮色的更亮，暗色的更暗，从而使对象对比强烈\n* 色阶：ctrl+l。恢复的原来设置可以按住alt点击取消\n\n## 4.6 曲线调节\n\n* 曲线调节快捷键：ctrl+m\n* 类似色阶操作，恢复的原来设置可以按住alt点击取消\n* 曝光度是单独针对高光和暗场的调节\n\n## 4.7 饱和度\n\n* 自然饱和度：电脑自动判断，对已饱和的颜色形成保护。\n* 饱和度：加深加亮所属颜色\n* 色相：快捷键ctrl+U；颜色的相貌就是色相，比如黄色，紫色等等，但是黑白灰这三个颜色就比较特殊，不属于有色的色相\n\n## 4.8 图层调整\n\n* 图层下方也有调整颜色的各个工具（右下角，有一个圆被挖空一半的图标），但是与菜单里面的工具不一样的地方就是对原图层形成保护，采用添加一个新蒙板进行调节\n* 蒙板：白色的是遮盖的意思，黑色是不遮盖的意思，直接用画笔在蒙版上涂抹就可以调整\n* 注意图层顺序，蒙板的是遮盖临近的上一个图层。\n\n## 4.9 色彩平衡\n\n* 色彩平衡：ctrl+B\n* 蒙板：白色的是遮盖的意思，黑色是不遮盖的意思，直接用画笔在蒙板上涂抹就可以调整\n* 色彩平衡可以调整CMY~RGB\n\n# 小插曲——实战\n\n改变指定区域的颜色，两种方法\n\n1. 通过建立选区，用历史画笔工具进行颜色改变。\n2. 通过色相/饱和度，然后左下角小手指定区域，对指定颜色进行调节\n\n# 五、图层编辑\n\n## 5.1 图层新建\n\n* 新建图层：shift+ctrl+N\n* 图层的颜色只用于图层的标识\n* 组的作用就是将图层进行分类，方便我们查找和统一去移动或者其他操作\n\n## 5.2 图层复制新建\n\n* 新建复制图层：ctrl+J\n* 菜单里的通过拷贝复制图层可以选择局部范围进行复制新建新图层\n* 菜单里的复制图层可以复制到别的文档里\n\n## 5.3 投影样式\n\n* 样式可以双击图层后半部调出，或者点击图层下方FX图标\n* 投影效果就是在图片后方添加深色像素，使图片更有立体感，层次感\n* 样式可以单独分离进行编辑\n\n## 5.4 发光样式\n\n* 内阴影指的是在内部添加深色像素，使图片有陷进去的感觉\n* 内发光与内阴影相反，但是这两个效果可以同时用，并不冲突\n* 阻塞的意思是过渡范围\n\n## 5.5 斜面浮雕\n\n* 周边加上亮色，使图案突出，然后添加阴影，使其有立体感\n* 可以在浮雕上贴图，有不同的花纹选择\n* 系统有很多自带的样式，可以自由切换\n\n## 5.6 描边叠加\n\n* 描边一般用于突出主题，勾画出主题轮廓\n* 渐变叠加与渐变填充基本相同，但是渐变叠加是单独的特效，对原图像没有损坏，强烈推荐\n* 图案叠加可以任意选择图案，来达到不同的效果\n\n## 5.7 图层调整\n\n* 类似于将纸张合到一张纸上。合并图层后所有效果等信息都会丢失，形成一张图像。可以选择性的合并可见图层\n* 不透明度会将所带效果一块调整，而填充只会针对对象调整。\n\n## 5.8 图层混合\n\n* 溶解：只有不透明度调整的时候才能生效\n* 变暗：所选图片亮色隐藏，黑色显示（相对下面的图片）\n\n# 六、图层蒙版\n\n## 6.1 图层蒙版\n\n* 蒙版：只存在黑、白、灰。黑色表示遮盖，白色表示透明，灰色根据其灰度来调整不透明度\n* 蒙版就是针对某个单独图层进行精细操作的时候，可以起到辅助作用的一个透明纸张\n* 在右下角有蒙版工具（矩形被抠走了一个圆的图标）\n\n## 6.2 建立蒙版\n\n* 当选区存在的时候，会默认形成遮盖蒙版，使选区内部透明\n* 蒙版对原图像没有任何影响，从而形成一种保护\n\n## 6.3 矢量蒙版\n\n* 矢量蒙版需要矢量工具进行编辑，灰色表示遮盖，类似于窗口效果\n* 矢量工具没有半透明的效果，而且放大缩小不会产生影响\n\n## 6.4 剪贴蒙版\n\n* 剪贴蒙版作用于两个相邻的图层\n* 按住alt键，左键点击两个图层中间\n\n# 七、通道编辑\n\n## 7.1 认识通道\n\n* 通道的主要功能：1.存储图像的色彩资料。2.存储和创建选区。3.抠图\n* 在ps中，在不同的图像模式下，通道是不一样的，通道层中的像素颜色是由一组原色的亮度值组成的，通道实际上可以理解为是选择区域的映射。\n\n## 7.2 头发抠图\n\n* 通道类似于蒙版，黑色是遮挡，白色是透明\n\n* 需要找出一个对比度最强的通道，然后通过曲线调色，对通道进行相应的处理，使其对比度更强烈，从而形成一个选区，把细节也能勾画出来。\n\n  > 具体操作：\n  >\n  > 1. 在通道里找到对比度强烈的通道，比方说蓝色\n  > 2. 然后复制出一个通道，对通道进行对比度调整（可以通过曲线）\n  > 3. ctrl+图层，建立选区，然后通过选区复制图层，就ok啦\n\n## 7.3 替换通道\n\n* 某一个通道有问题的时候，可以用其他通道替代有问题的通道\n* 通过通道颜色的调节可以直接影响整个图像的色调\n\n","tags":["ps"]},{"title":"多态以及上下转型","url":"/blog/2019/polymorphism/","content":"\n教你认识多态\n\n<!--more-->\n\n## 一、多态的概述以及使用\n\n啥叫多态？左父右子，就叫多态。此处联想css中的子绝父相。\n\n{% asset_img 多态1.png 多态的概述 %}\n\n代码当中提现多态性，其实就是一句话：父类引用指向子类对象\n\n格式：\n\n```\n父类对象 对象名 = new 子类名称();\n```\n\n或者\n\n```\n接口名称 对象名 = new 实现类名称();\n```\n\nFu.java\n\n```\npublic class Fu {\n\tpublic void method() {\n\t\tSystem.out.println(\"父类方法\");\n\t}\n\tpublic void methodFu() {\n\t\tSystem.out.println(\"这是父类特有的方法\");\n\t}\n}\n```\n\nZi.java\n\n```\npublic class Zi extends Fu {\n\t@Override\n\tpublic void method() {\n\t\tSystem.out.println(\"子类方法\");\n\t}\n}\n```\n\nDemo01Multi.java\n\n```\npublic class Demo01Multi {\n\tpublic static void main(String[] args) {\n\t\t\n\t\t//使用多态方法\n\t\t//左侧父类的引用，指向右侧子类的对象\n\t\tFu obj=new Zi();\n\t\t\n\t\tobj.method();//子类方法。看右边new的是谁，就输出谁\n\t\tobj.methodFu();\n\t}\n}\n```\n\n## 二、多态中成员变量使用特点\n\n访问成员变量的两种方式：\n\n1. 直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找\n2. 间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找\n\nFu1.java\n\n```\npublic class Fu1 {\n\tint num=10;\n\tpublic void method() {\n\t\tSystem.out.println(\"父类\"+num);\n\t}\n}\n```\n\nZi1.java\n\n```\npublic class Zi1 extends Fu1 {\n\tint num=20;\n\t@Override\n\tpublic void method() {\n\t\tSystem.out.println(\"子类\"+num);\n\t}\n}\n```\n\nDemo02MultiField.java\n\n```\npublic class Demo02MultiField {\n\tpublic static void main(String[] args) {\n\t\t//使用多态的方法，父类引用指向子类对象，左父右子\n\t\tFu1 obj=new Zi1();\n\t\tSystem.out.println(obj.num);//10\n\t\tobj.method();//20,子类没有覆盖重写，就是父；子类如果覆盖重写，就是子\n\t\t\n\t\tZi1 zi=new Zi1();\n\t\tSystem.out.println(zi.num);//20\n\t\tzi.method();//20\n\t}\n}\n```\n\n## 三、多态中成员方法的使用特点\n\n在多态的代码当中，成员方法的访问规则：\n\n*看new的是谁，就优先用谁，没有则向上找*\n\n口诀：编译看左边，运行看右边\n\n**对比：**\n\n成员变量：编译看左边，运行还看左边\n\n成员方法：编译看左边，运行看右边\n\nFu2.java\n\n```\npublic class Fu2 {\n\tpublic void method() {\n\t\tSystem.out.println(\"父类方法\");\n\t}\n\t\n\tpublic void methodFu() {\n\t\tSystem.out.println(\"父类特有的方法\");\n\t}\n}\n```\n\nZi2.java\n\n```\npublic class Zi2 extends Fu2 {\n\t@Override\n\tpublic void method() {\n\t\tSystem.out.println(\"子类方法\");\n\t}\n\t\n\tpublic void methodZi() {\n\t\tSystem.out.println(\"子类特有方法\");\n\t}\n}\n```\n\nDemo03MultiMethod.java\n\n```\npublic class Demo03MultiMethod {\n\tpublic static void main(String[] args) {\n\t\tFu2 obj=new Zi2();//多态\n\t\tobj.method();//父子都有，优先用子\n\t\tobj.methodFu();//子类没有，父类有，向上找\n\t\t\n\t\t//obj.methodZi();//报错了,因为编译看左边，左边是Fu,Fu当中没有methodZi方法，所以编译报错\n\t\t\n\t\tZi2 zi=new Zi2();\n\t\tzi.methodZi();\n\t}\n}\n```\n\n## 四、使用多态的好处\n\n{% asset_img 多态2.png 使用多态的好处 %}\n\n如果不用多态，只用子类，那么写法是：\n\n```\nTeacher one = new Teacher();\none.work();//讲课\nAssistant two = new Assistant();\ntwo.work();//辅导\n```\n\n我现在唯一要做的事情，就是调用work方法，其他的功能不关心。\n\n如果使用多态的写法，对比一下：\n\n```\nEmployee one = new Teacher();\none.work();//讲课\nEmployee two = new Assistant();\ntwo.work();//辅导\n```\n\n**好处：**\n\n*无论右边new的时候换成哪个子类对象，等号左边调用方法不会发生变化*\n\n## 五、对象的向上转型与向下转型\n\n{% asset_img 多态3.png 上转型与下转型理解图 %}\n\n#### 向上转型\n\n对象的向上转型，其实就是多态写法：\n\n```\n父类名称 对象名 = new 子类名称();\n\n//Animal animal = new Cat();\n//创建了一只猫，当做动物看待，没问题。\n```\n\n含义：右侧创建一个子类对象，把它当做父类来看待使用。\n\n注意事项：**向上转型一定是安全的。**从小范围转向了大范围，从小范围的猫，转向了更大范围的动物。\n\n类似于：\n\n```\ndouble num=100;//正确，int-->double,自动类型转换\n```\n\n#### 向下转型\n\n对象的向下转型，其实是一个【还原】的动作\n\n格式：\n\n```\n子类名称 对象名 = (子类名称) 父类对象;//其实类似于 int a = (double) 10.0;\n\n//Animal animal = new Cat();//本来是猫，向上转型为动物\n//Cat cat = (Cat) animal;//本来是猫，已经被当做动物了，还原为本来的猫\n```\n\n含义：将父类对象，【还原】成为本来的子类对象。\n\n注意事项：\n\n1. 必须保证对象本来创建的时候，就是猫，才能向下转型成为猫\n2. 如果对象创建的时候本来不是猫，现在非要向下转型为猫，就会报错。**java.lang.ClassCastException**\n\n类似于：\n\n```\nint num = (int) 10.0;//可以\nint num = (int) 10.5;//不可以，精度损失\n```\n\nAnimal.java\n\n```\npublic abstract class Animal {\n\t\n\tpublic abstract void eat();\n}\n```\n\nCat.java\n\n```\npublic class Cat extends Animal {\n\n\t@Override\n\tpublic void eat() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"猫吃鱼\");\n\t}\n\t\n\tpublic void catchMouse() {\n\t\tSystem.out.println(\"猫抓老鼠\");\n\t}\n\n}\n```\n\nDemo04Main.java\n\n```\n/*\n向上转型一定是安全的，没有问题的，正确的，但是也有一个弊端：\n对象一旦向上转型为父类，那么就无法调用子类原本特有的内容。\n\n解决方案：用对象的向下转型【还原】\n */\npublic class Demo04Main {\n\tpublic static void main(String[] args) {\n\t\t// 对象的向上转型，就是：父类引用指向子类对象\n\t\tAnimal animal = new Cat();//本来是一只猫，向上转型为动物；向上转型必定是成功的。\n\t\tanimal.eat();\n\t\t// animal.catchMouse();//错误写法!要改成向下转型\n\n\t\t\n\t\t//向下转型，正确的转型，本来是只猫，还转换成猫，所以是正确的\n\t\tCat cat = (Cat) animal;//类似于强制转换\n\t\tcat.catchMouse();//猫抓老鼠\n\t\t\n\t\t//下面是错误的转型\n\t\t//本来是只猫，现在当做狗\n\t\t//Dog dog=(Dog) animal;//编译时没错，运行会出现异常。java.lang.ClassCastException  \n\t}\n}\n```\n\n## 六、instanceof判断类型\n\n如何才能知道一个父类引用的对象，本来是什么子类？\n\n格式：\n\n```\n对象 instanceof 类名称\n```\n\n这将会得到一个boolean值结果，也就是判断前面的对象能不能做后面类型的实例\n\n*向下转型，一定要进行instanceof判断，否则，可能会出现转换异常*\n\nAnimal.java跟Cat.java跟上面那个是一个类，直接看Instanceof类\n\nDemo02Instanceof.java\n\n```\npublic class Demo02Instanceof {\n\tpublic static void main(String[] args) {\n\t\tAnimal animal = new Cat();\n\t\tanimal.eat();// 猫吃鱼\n\t\tgiveMeAPat(animal);\n\n\t\t\n\t}\n\n\tpublic static void giveMeAPat(Animal animal) {\n\t\t// 如果希望调用子类特有方法，需要向下转型\n\t\tif (animal instanceof Dog) {\n\t\t\tDog dog = (Dog) animal;\n\t\t\tdog.watchHouse();\n\t\t}\n\t\tif (animal instanceof Cat) {\n\t\t\tCat cat = (Cat) animal;\n\t\t\tcat.catchMouse();\n\t\t}\n\t}\n}\n\n```\n\n## 七、接口多态综合案例\n\n{% asset_img 多态4.png 案例要求 %}\n\nUSB.java\n\n```\npublic interface USB {\n\n    public abstract void open(); // 打开设备\n\n    public abstract void close(); // 关闭设备\n\n}\n```\n\nMouse.java\n\n```\n//鼠标就是一个USB设备\npublic class Mouse implements USB {\n\t@Override\n\tpublic void open() {\n\t\tSystem.out.println(\"打开鼠标\");\n\t}\n\n\t@Override\n\tpublic void close() {\n\t\tSystem.out.println(\"关闭鼠标\");\n\t}\n\n\tpublic void click() {\n\t\tSystem.out.println(\"鼠标点击\");\n\t}\n}\n```\n\nKeyboard.java\n\n```\n//键盘就是一个USB设备\npublic class Keyboard implements USB {\n\t@Override\n\tpublic void open() {\n\t\tSystem.out.println(\"打开键盘\");\n\t}\n\n\t@Override\n\tpublic void close() {\n\t\tSystem.out.println(\"关闭键盘\");\n\t}\n\n\tpublic void type() {\n\t\tSystem.out.println(\"键盘输入\");\n\t}\n}\n```\n\nComputer.java\n\n```\npublic class Computer {\n\n    public void powerOn() {\n        System.out.println(\"笔记本电脑开机\");\n    }\n\n    public void powerOff() {\n        System.out.println(\"笔记本电脑关机\");\n    }\n\n    // 使用USB设备的方法，使用接口作为方法的参数\n    public void useDevice(USB usb) {\n        usb.open(); // 打开设备\n        if (usb instanceof Mouse) { // 一定要先判断\n            Mouse mouse = (Mouse) usb; // 向下转型\n            mouse.click();\n        } else if (usb instanceof Keyboard) { // 先判断\n            Keyboard keyboard = (Keyboard) usb; // 向下转型\n            keyboard.type();\n        }\n        usb.close(); // 关闭设备\n    }\n\n}\n```\n\nDemoMain.java\n\n```\npublic class DemoMain {\n\n    public static void main(String[] args) {\n        // 首先创建一个笔记本电脑\n        Computer computer = new Computer();\n        computer.powerOn();\n\n        // 准备一个鼠标，供电脑使用\n//        Mouse mouse = new Mouse();\n        // 首先进行向上转型\n        USB usbMouse = new Mouse(); // 多态写法\n        // 参数是USB类型，我正好传递进去的就是USB鼠标\n        computer.useDevice(usbMouse);\n\n        // 创建一个USB键盘\n        Keyboard keyboard = new Keyboard(); // 没有使用多态写法\n        // 方法参数是USB类型，传递进去的是实现类对象\n        computer.useDevice(keyboard); // 正确写法！也发生了向上转型\n        // 使用子类对象，匿名对象，也可以\n//        computer.useDevice(new Keyboard()); // 也是正确写法\n\n        computer.powerOff();\n        System.out.println(\"==================\");\n\n        method(10.0); // 正确写法，double --> double\n        method(20); // 正确写法，int --> double\n        int a = 30;\n        method(a); // 正确写法，int --> double\n    }\n\n    public static void method(double num) {\n        System.out.println(num);\n    }\n\n}\n```\n\n## 八、多态的练习题\n\n```java\npackage homework;\n\nclass A {\n\tpublic String f(D obj) {\n\t\treturn (\"A and D\");\n\t}\n\tpublic String f(A obj) {\n\t\treturn (\"A and A\");\n\t}\n}\nclass B extends A {\n\tpublic String f(B obj) {\n\t\treturn (\"B and B\");\n\t}\n\tpublic String f(A obj) {\n\t\treturn (\"B and A\");\n\t}\n}\nclass C extends B {\n\t\n}\nclass D extends B {\n\t\n}\npublic class Homework02 {\n\t/*\n\t * 这个地方需要注意的点：\n\t * 1. 如果public String f(A obj)方法传进来的对象是B对象，发现没有，就会自动向上转型！因为B extends A\n\t * 2. 向上转型的写法中：A a2=new B();a2调用变量是A中的，调用方法是B中的(只能是A中已有的方法，被重写的可以被调用，独有的是不可以被调用的)\n\t */\n\tpublic static void main(String[] args) {\n\t\tA a1=new A();\n\t\tA a2=new B();\n\t\tB b=new B();\n\t\tC c=new C();\n\t\tD d=new D();\n\t\t\n\t\tSystem.out.println(a1.f(a1));// A and A\n\t\tSystem.out.println(a1.f(b));// A and A\n\t\tSystem.out.println(a1.f(c));// A and A\n\t\tSystem.out.println(a1.f(d));// A and D\n\t\t\n\t\tSystem.out.println(a2.f(a1));//B and A\n\t\tSystem.out.println(a2.f(b)); //B and A\n\t\tSystem.out.println(a2.f(c));//B and A\n\t\tSystem.out.println(a2.f(d));//A and D\n\t\t\n\t\tSystem.out.println(b.f(a1));//B and A\n\t\tSystem.out.println(b.f(b));//B and B\n\t\tSystem.out.println(b.f(c));//B and B\n\t\tSystem.out.println(b.f(d));//A and D\n\t}\n}\n\n```\n\n","tags":["java"]},{"title":"pr入门笔记","url":"/blog/2020/premierepro-learn/","content":"\n记录pr学习的笔记\n\n<!--more-->\n\n如果整个界面设置弄乱了，可以点击窗口-工作区-重置为保存的布局\n\n也可以，直接右键编辑栏-重置为保存的布局\n\n全屏工作栏，点击工作栏，然后点击键盘的`~`键，即可全屏，注意是英文状态下 \n\n全屏视频，点击键盘`Ctrl`+`~`键即可\n\n# 一、基础流程\n\n{% asset_img 1.png %}\n\n新建序列\n\nP制一般是亚洲国家用，N制一般是欧洲国家用，24P是拍电影用，HDV是高清的\n\n> 大部分情况下，会使用自定义的，1920*1080高清，16:9，逐行扫描\n\n导入素材\n\n1. 可以通过文件选项\n2. 可以通过项目右键导入\n\n添加素材\n\n添加视频\n\n添加声音\n\n导出（可以通过文件-导出-媒体或者直接ctrl+M）\n\n一般选择H.264和匹配高比特率\n\n# 二、视频转场\n\n选择边界处，按ctrl+D就是添加默认过渡效果\n\n{% asset_img 2.png %}\n\n如图所示，进行选择视频过渡，点击分界处，将视频过渡效果拖拽过去即可。\n\n点击过渡处的效果，然后点击左上角效果控件\n\n{% asset_img 3.png %}\n\n# 三、音频过渡\n\n跟视频转场操作类似\n\n# 四、视频编辑\n\n在素材箱导入图片素材，双击素材，可打开图片编辑页面\n\n{% asset_img 4.png %}\n\n双击左边的时间，输入400，就会变成00:00:04:00，按下O键，时间就会变成从4秒往后取1s素材\n\n新建序列，点击插入，可以插入到视频轨道，如果点击覆盖，会覆盖在视频轨道上的当前的视频\n\n添加字幕可以通过点击左下T来进行添加。也可以通过新建-旧版标题来添加，不过这个是老版的添加字幕的方法了。\n\n设置完了以后，直接退出字幕，将字幕从素材箱拉到视频轨道上即可\n\n# 五、简单动画\n\n比方说加旋转，在要结束的点，设置结束的动画参数，点击左边的点，变成蓝色，就添加了关键帧。然后在开始的点，设置起始的动画参数，点击运行即可。\n\n{% asset_img 5.png %}\n\n# 六、素材嵌套\n\n添加素材时，点击素材箱，然后编辑-首选项-时间轴，可以设置添加图片默认持续时间，就不用一个一个改了。\n\n可以双击任何一个素材，看，是不是设置成想要的时间了。\n\n# 七、自定义转场\n\n用ps制作灰度图，设置字体，或者渐变工具，保存为灰度图片.tif\n\npr在效果栏选择视频过渡-擦除-径向擦除，选择灰度图，即可设置自定义转场\n\n> 个人感觉没啥用，自带的已经挺好使了。\n\n# 八、视频效果\n\n左下角选择效果-视频效果-图像控制，选择黑白，拖到指定视频上，就会形成一个黑白视频。\n\n杂色与颗粒，点击指定的视频片段，然后双击杂色，在左上角找到效果控件，调整杂色数量即可\n\n类似的高斯模糊，也是这么处理。\n\n如果想要去掉效果的话，点击fx即可。也可以右键-清除\n\n{% asset_img 6.png %}\n\n视频效果右键复制，可以粘贴到别的视频上\n\n如果不想把效果加到视频上，可以在素材箱新建图层，将图层拉满整个视频，然后在图层加效果。\n\n添加光照效果：视频效果-调整-光照效果 \n\n# 九、模板素材下载\n\n* [模板](https://www.cgown.com/edit/premiere/)\n* [音频素材](http://www.aigei.com/)\n* [字库素材](https://www.iconfont.cn/)\n\n# 十、pr实战笔记\n\n## 10.1 电子相册\n\n* 批量添加视频过渡，设置为默认过渡，然后全选，按Ctrl+D来添加默认效果。\n\n* 批量复制某个视频的属性，复制，然后全选视频，按粘贴属性即可。\n\n* 添加的素材光效全黑时，选择不透明度，设置混合模式-滤色\n\n## 10.2  CG混剪\n\n* 在导入视频素材时，如果出现视频没有铺满全屏的情况（比方说序列是1080p，而素材是720p）下，可以右键-缩放为帧大小即可\n* 做大片时，做字幕遮罩，点击新建序列的按钮，点击颜色遮罩，然后添加上视频效果-变换-裁剪效果，调整即可，结束完成之后，alt+鼠标可以再复制一个字幕遮罩\n* 右侧视频编辑处，没有调整控件时，参照[这个](https://tieba.baidu.com/p/6127676586)\n* 添加字幕时，可以设置标记点\n* 剪辑精彩片段\n  1. 可以下拉序列，然后将新序列内截出来的视频，拖到上一个序列\n  2. 可以将素材箱设置成浮动面板，然后将序列截出来的视频，直接拖到素材箱\n* 预览视频倍速\n  1. 按快捷键L，按一次就是一倍速度，两次就是两倍，按几次就是几倍\n  2. 按快捷键K，暂停（空格也可以）\n  3. 按快捷键J，回退，按几次就是几倍回退\n* 右侧完整就是特效全满预览，1/4就是特效1/4预览\n  1. 仅影响预览画质，不影响导出画质 \n* 最后结尾视频可以设置`视频过渡-溶解-黑场过渡`，声音可以设置`音频过渡-恒定功率`\n\n{% asset_img 7.png %}\n\n","tags":["pr"]},{"title":"自动滑块验证登录QQ","url":"/blog/2020/qq-autologin/","content":"\n\n之前，我用php配合java写了一个qq群签到的脚本。需要手动更新cookie，很烦。\n\n最近学习刷题过程中，碰到了很多事情，很烦。就准备写几天代码，把之前的脚本，完整的只用java来实现，顺便平复一下最近烦躁的情绪。\n\n<!--more-->\n\n登录QQ之后，能干的事情很多。这里只讲述如何自动登录，至于自动登录之后干啥，根据自己需求自由发挥。\n\n授人以鱼不如授人以渔，我把思路分享出来。\n\n{% asset_img 1.png 自动登录 %}\n\n其实也有很多不可控的因素，比方说QQ自己的服务器不行，我就碰到过几次，访问QQ，贼慢，结果导致脚本异常。\n\n现在的处理方法就是，捕获所有异常，只要捕获到异常，脚本终止，通知管理员。这应该是我目前觉得稍微好点的处理方法了。\n\n# 一、登录\n\n下载selenium相应的[jar包](https://www.selenium.dev/downloads/)。加载ChromeDriver驱动，[下载地址](http://chromedriver.storage.googleapis.com/index.html)\n\n\n加载驱动之后，就可以考虑开始登录了。\n\n1. 切换账号密码登录\n2. 输入账号\n3. 输入密码\n4. 登录\n\n注意，这期间是需要有时间间隔的，因为可能会有网速的影响，所以我在**切换账号密码登录**和**登录**这两步中，分别设定了间隔1秒和5秒。\n\n如果页面还没加载完成，就开始执行程序，那会报错。因为没有找到指定的元素。\n\n# 二、自动解锁滑块验证码\n\n> 也可以到[这里](https://007.qq.com/online.html?ADTAG=demo.head)进行滑块测试，代码需要进行修改\n\n\n本来是想通过识别图像像素或者对比度的方法，来找出滑块缺失的位置。后来发现，腾讯并没有做得那么牛逼。\n\n经过多次测试，发现，QQ的滑块验证，并不是随机产生的，而是固定的。不管怎么弄，都会有三个固定位置。190px,205px,215px.\n\n换句话说，我们顶多尝试进行三次登录，肯定是能登录成功的。\n\n---\n\n2020年7月10日更新\n\n今天答辩，正好早上4点多我在床上躺着翻来覆去睡不着，想答辩的事。结果到点了，我的签到通知没发给我，我就意识到，坏了，出bug。\n\n然后睡意全无，由于我答辩的报告还没写，所以还是写报告为重，整到上午12点，我的答辩报告和程序优化得差不多了。下午答辩完之后，上传开源内容到github，打了一个多小时游戏，不好玩，就去睡了两个小时觉。醒来已经七点半了。\n\n仔细分析一波，原来是正确输入账号密码后，登录验证没了，导致脚本还在按有验证码的时候处理，所以只需要判断一下当前页面是否是验证码页面\n\n若是，则解锁\n\n若否，则已经成功了\n\n为了让发生错误能够及时提醒我，我把所有的异常都捕获，只要捕获到异常，立即终止程序，并邮件通知我\n\n放上完整代码\n\n```java\npublic class AutoLogin {\n\tprivate static ChromeDriver driver;\n\tprivate static String oldUrl;\n\tprivate static String newUrl;\n\n\tpublic static void quitDriver(Exception e) {\n\t\te.printStackTrace();\n\t\tdriver.quit();\n\t\tString[] mail = { \"QQ自动登录异常\", \"登录失败，原因：\"+e.getClass().getName()+\"\\n引起该异常的原因\\n1.网络超时\\n2.需要输入手机验证码\" };\n\t\tSendMail.send(mail);\n\t\tSystem.exit(0);\n\t}\n\t/**\n\t * 获取驱动\n\t */\n\tpublic static void getDriver() {\n\t\t// 本地测试\n//\t\tSystem.setProperty(\"webdriver.chrome.driver\", \"C:\\\\Users\\\\kitchen\\\\Desktop\\\\chromedriver.exe\");\n\t\t// 打包\n\t\tSystem.setProperty(\"webdriver.chrome.driver\", \"chromedriver.exe\");\n\t\t// 下面两行代码关闭无用的log\n\t\tSystem.setProperty(\"webdriver.chrome.silentOutput\", \"true\");\n\t\tjava.util.logging.Logger.getLogger(\"org.openqa.selenium\").setLevel(Level.OFF);\n\t\tChromeOptions chromeOptions = new ChromeOptions();\n\t\t// 这是指不打开GUI模式\n\t\tchromeOptions.addArguments(\"--headless\");\n\t\tdriver = new ChromeDriver(chromeOptions);\n\t}\n\n\t/**\n\t * 获取登录的skey\n\t * @param u\n\t * @param p\n\t * @return\n\t */\n\tpublic static String getSkey(String u, String p) {\n\t\tString skey = null;\n\t\tif (login(u, p)) {\n\t\t\tskey = driver.manage().getCookieNamed(\"skey\").toString().split(\";\")[0].substring(5);\n\t\t} else {\n\t\t\tString[] mail = { \"QQ自动登录异常\", \"获取skey失败\\n请检查网络是否超时，或者腾讯是否已更新验证码\" };\n\t\t\tSendMail.send(mail);\n\t\t\tdriver.quit();\n\t\t\tSystem.exit(0);\n\t\t}\n\t\tdriver.quit();\n\t\treturn skey;\n\t}\n\n\t/**\n\t * 登录\n\t * \n\t * @param u\n\t * @param p\n\t * @return true表示登录成功\n\t */\n\tpublic static boolean login(String u, String p) {\n\t\tDate date=new Date();\n\t\tSystem.out.println(date.toLocaleString()+\" 开始登录...\");\n\t\tgetDriver();\n\t\tboolean flag = false;\n\t\tdriver.get(\n\t\t\t\t\"https://xui.ptlogin2.qq.com/cgi-bin/xlogin?proxy_url=https%3A//qzs.qq.com/qzone/v6/portal/proxy.html&daid=5&&hide_title_bar=1&low_login=0&qlogin_auto_login=1&no_verifyimg=1&link_target=blank&appid=549000912&style=22&target=self&s_url=https%3A%2F%2Fqzs.qzone.qq.com%2Fqzone%2Fv5%2Floginsucc.html%3Fpara%3Dizone%26specifyurl%3Dhttp%253A%252F%252Fuser.qzone.qq.com%252F252252252&pt_qr_app=%E6%89%8B%E6%9C%BAQQ%E7%A9%BA%E9%97%B4&pt_qr_link=http%3A//z.qzone.com/download.html&self_regurl=https%3A//qzs.qq.com/qzone/v6/reg/index.html&pt_qr_help_link=http%3A//z.qzone.com/download.html&pt_no_auth=1\");\n\t\ttry {\n\t\t\tThread.sleep(1000);\n\t\t\t// 切换登录模式\n\t\t\tdriver.findElement(By.id(\"switcher_plogin\")).click();\n\t\t\tThread.sleep(500);\n\t\t\t// 输入账号以及密码进行登录\n\t\t\tdriver.findElement(By.id(\"u\")).clear();\n\t\t\tdriver.findElement(By.id(\"u\")).sendKeys(u);\n\t\t\tdriver.findElement(By.id(\"p\")).clear();\n\t\t\tdriver.findElement(By.id(\"p\")).sendKeys(p);\n\t\t\tdriver.findElement(By.id(\"login_button\")).click();\n\n\t\t\tThread.sleep(5000);\n\t\t\t\n\t\t\tint[][] arr = { { 10, 20, 30, 40, 50, 18 }, { 10, 20, 30, 40, 50, 18, 30 }, { 10, 20, 30, 40, 50, 18, 15 },\n\n\t\t\t};\n\t\t\toldUrl = driver.getCurrentUrl();\n\t\t\t\n\t\t\t/*\n\t\t\t * 此处2020年7月10号更新，我已经使用该脚本实现连续自动登录90天。\n\t\t\t * 今天突然出问题了。\n\t\t\t * 由于今天还要准备考试，我就拖到了晚上才整\n\t\t\t * 分析了一波，是因为固定ip地址登录90天，腾讯认为我的账号不具备威胁性了，\n\t\t\t * 所以没了验证码，而脚本还是按有验证码执行肯定会报错。\n\t\t\t * 加个逻辑判断即可\n\t\t\t */\n\t\t\tif(oldUrl.contains(\"https://user.qzone.qq.com/\")) {\n\t\t\t\tflag=true;\n\t\t\t}else {\n\t\t\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\t\t\tSystem.out.print(\"正在尝试第\" + (i + 1) + \"次登录：\");\n\t\t\t\t\tif (unlock(arr[i])) {\n\t\t\t\t\t\tSystem.out.println(\"登录成功\");\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(\"登录失败\");\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t}\n\t\t\t\t\tThread.sleep(2000);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t} catch (Exception e) {\n\t\t\tquitDriver(e);\n\t\t}\n\t\treturn flag;\n\n\t}\n\n\t/**\n\t * 自动进行滑块解锁\n\t * \n\t * @return true表示解锁成功\n\t */\n\tpublic static boolean unlock(int[] arr) {\n\t\tboolean flag = false;\n\t\tActions actions = new Actions(driver);\n\t\ttry {\n\t\t\tdriver.switchTo().frame(\"tcaptcha_iframe\");\n\t\t\tWebElement slideBtn = driver.findElement(By.id(\"tcaptcha_drag_button\"));\n\t\t\t// 按下滑动按钮\n\t\t\tactions.clickAndHold(slideBtn).perform();\n\t\t\tfor (int i : arr) {\n\t\t\t\tactions.moveByOffset(i, 0).perform();\n\t\t\t}\n\t\t\t// 松开按钮\n\t\t\tactions.release(slideBtn).perform();\n\t\t\tThread.sleep(3000);\n\t\t\tnewUrl = driver.getCurrentUrl();\n\t\t\tif (oldUrl.equals(newUrl)) {\n\t\t\t\tdriver.switchTo().defaultContent();\n\t\t\t\tflag = false;\n\t\t\t} else {\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t\tThread.sleep(500);\n\t\t} catch (Exception e) {\n\t\t\tquitDriver(e);\n\t\t}\n\t\treturn flag;\n\t}\n}\n```\n\n# 三、总结\n\n## 3.1 感谢大佬\n\n[java selenium破解腾讯滑动验证码](https://blog.csdn.net/qq_38534107/article/details/85005891)\n\n[java Selenium 滑块验证破解](https://blog.csdn.net/weixin_39660224/article/details/103163797)\n\n[java opencv 计算滑块横移距离](https://blog.csdn.net/weixin_39660224/article/details/103161484)\n\n[QQ空间访客爬虫](https://github.com/APTXOUS/QzoneSpider)\n\n[QQ空间模拟登录](https://mp.weixin.qq.com/s/Awnj0x_E7XJtbOW_7OBwbA)\n\n## 3.2 个人收获以及最近的状况\n\n刚开始学习编程时的大大小小的愿望都已经实现了。原来以为，我只要能做到这些，就很牛逼了。\n\n现在发现，自己还是很菜。离牛逼，很远很远。\n\n实现功能很容易。代码量也不多。这是因为已经有伟人把我们该做的，做完了。\n\n站在巨人的肩膀上，应该保持谦逊的姿态。\n\n身为开发者，应该也要有这样的追求。Make IT Easy and Better。为开源做出贡献！\n\n最近情绪很低落，要考研，却又没有什么大的进步，不会的东西很多很多。导致心烦意乱。\n\n有想做的事，也有不得不做的事，这就导致了我的迷茫和焦虑。我也不知道如何处理。半夜了，写得很乱，就这样吧。睡觉去了。","tags":["java","open"]},{"title":"Q群自动签到php&java版","url":"/blog/2020/qqsign/","content":"\n腾讯在8月12日，对QQ群进行了大幅度的更新，24小时全程自动登录签到脚本失效，脚本弃用。\n\n新的脚本是通过php手动更新加密值到数据库，java多线程执行签到，并随时监测会话是否失效，失效则通知管理员进行数据更新。\n\n<!--more-->\n\n> 2020年9月10日更新：腾讯在9月9日，再次对签到系统进行了大幅度的更新，整个实现思路失效！\n\n本篇文章仅记录开发流程，其实实现过程很简单，我把整个思路记录下来。\n\n本篇文章开放评论，有问题可以随时交流。\n\n# 一、前因后果\n\n之前的QQ是所有的cookie通用的，比如QQ空间跟QQ群跟手机app，都是同一套加密值。我之前就是通过登录QQ空间，获取到cookie，来实现自动的群签到。当时是纯java实现的，[自动滑块验证登录QQ](https://meethigher.top/blog/2020/qq-autologin/)\n\n在8月12之前，签到只需要skey即可，也可以携带p_skey。\n\n经过8月12日更新之后，必须携带p_skey，QQ空间跟群的加密数据完全分离开了，也就是两者的数据并不通用了，qq空间的p_skey跟qq群的p_skey并不通用。\n\n举个例子来说，之前登录QQ空间，就可以查看你的群信息，进行一系列群操作，反之登录Q群，同样可以进行Q空间的一系列操作，现在就不能了。\n\n8月12日到8月13日这两天，看了下旧的脚本，犹豫要不要写个新的。\n\n写个新的可能就要手动更新了，一想就很麻烦，果断放弃了。\n\n如果说加密值不一样，那肯定就是服务器对session处理逻辑不一样了，服务器的自然没法看。但是，手机apk上面可以反编译来查看它的加密算法啊，这是我的下意识。\n\n说干就干，反编译QQ。\n\n先找pskey，找到了方法getPskey\n\n{% asset_img 1.png %}\n\n然后根据里面逻辑，继续找getLocalTicket\n\n{% asset_img 2.png %}\n\n再找getLocalSig\n\n{% asset_img 3.png %}\n\n此时看到这里，已经接近崩溃了，我整了一上午毫无进度，尝试用别的方法（MT管理）进行编译，但是还是失败了。\n\n> 我有种直觉，pskey的生成逻辑，apk的源码里就有，只不过太麻烦\n\n# 二、实现原理\n\n具体流程\n\n1. php：手动更新cookie（加密值）到数据库\n2. java：多线程监测会话是否失效，失效则下发邮件通知\n3. java：多线程定时签到->随机地点、随机图片、自增天数\n\n通过手机或者电脑，将数据更新到服务器数据库（数据库采用触发器，更新之前，将数据库的time更改为当前时间）\n\n{% asset_img 4.png %}\n\n麻烦是麻烦了点，不过也是我目前所能想到的最方便的解决方法了。如果出了问题，手机是随时随地都能更新数据的。\n\n{% asset_img 6.png %}\n\njava取出数据，然后开启线程，进行每隔10分钟的访问，如果出错，就会下发邮件通知（通过一个类的成员变量errorTime，判断errorTime与数据库中的时间是否相同，如果相同就是没有更新数据，不会再次下发通知）\n\n访问时，需要携带bkn。通过chrome开发者工具全局ctrl+shift+f搜索bkn，可以找到加密算法。\n\n```java\nAccount account = QQSkey.getAccount();\nString skey=account.getSkey();\nint t=5381;\nfor(int n=0,o=skey.length();n<o;n++) {\n\tt+=(t<<5)+(int)skey.charAt(n);\n}\nint bkn=2147483647&t;//即所求\n```\n\n接下来，只要cookie有效，就可以签到咯\n\n{% asset_img 5.png %}\n\n{% asset_img 7.png %}","tags":["life","open"]},{"title":"java中的反射与注解","url":"/blog/2020/reflection-and-annotation/","content":"\n简单了解一下反射跟注解\n\n<!--more-->\n\n先附上java14的官方[最新文档](https://docs.oracle.com/en/java/javase/14/docs/api/index.html)，不懂就查，方便快捷，一步到位。\n\n# 一、反射\n\n反射：框架设计的灵魂。\n\n框架：半成品软件。可以在框架的基础上进行软件开发，简化编码。\n\n在使用框架的时候，不会反射，没有问题；但如果要开发一个框架，就需要用到反射。\n\n## 1.1 反射的概念\n\njava代码在计算机中经历三个阶段：源代码阶段、类对象阶段、运行时阶段\n\n{% asset_img 1.png 理解反射 %}\n\n上图中，在类对象阶段，将成员方法，封装成Constructor[]数组这种过程，这就是反射。\n\n举个例子，就比如写代码时，定义的一个String变量，可以通过快捷键将其所有方法显示出来，这就是通过反射完成的。\n\n**概念：**将类的各个组成部分封装为其他对象，这个过程叫做`反射`，也就是反射机制。\n\n好处：\n\n1. 可以在程序运行过程中，操作这些对象。\n2. 可以解耦，提高程序的可扩展性。\n\n很抽象，一会上案例。\n\n## 1.2 获取Class对象\n\n### 通过Class.forName(\"全类名\")\n\n如果此时处于`源代码阶段`，那我们可以通过`Class.forName(\"全类名\")`这种方式，是将字节码文件加载进内存，返回`class`对象。\n\n> 全类名：包名.类名\n\n```java\npublic class Demo01Reflect {\n\tpublic static void main(String[] args) throws ClassNotFoundException {\n\t\t//Class.forName(\"全类名\")，全类名指包名.类名，即使是同一个包的，也不能省略包名\n\t\tClass cls=Class.forName(\"demo44.Person\");\n\t\tSystem.out.println(cls);\n\t}\n}\n```\n\n> 适用场景：\n>\n> 多用于配置文件，将类名定义在配置文件中。读取文件，加载类\n\n### 通过类名.class\n\n如果此时处于`类对象阶段`，那我们可以通过类名的属性`类名.class`获取class对象\n\n```java\npublic class Demo01Reflect {\n\tpublic static void main(String[] args) throws ClassNotFoundException {\n\t\t//类名.class\n\t\tClass cls2=Person.class;\n\t\tSystem.out.println(cls2);\n\t}\n}\n```\n\n> 适用场景：\n>\n> 多用于参数的传递\n\n### 通过对象.getClass()\n\n如果此时处于`运行时阶段`，那我们可以通过`对象名.getClass`来获取class对象。\n\ngetClass()是在Object类中定义的，所以所有的类，都有这个方法\n\n```java\npublic class Demo01Reflect {\n\tpublic static void main(String[] args) throws ClassNotFoundException {\n\t\t//对象名.getClass\n\t\tPerson p=new Person();\n\t\tClass cls3=p.getClass();\n\t\tSystem.out.println(cls3);\n\t}\n}\n```\n\n> 适用场景：\n>\n> 多用于对象获取字节码的方式\n\n### 一次运行只会加载一次字节码文件\n\n将三个不同过程中，获取到的对象，进行地址值的比较，会发现都是同一个地址。\n\n由此，我们可以得出结论：<u>同一字节码文件(.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的class对象，都是同一个</u>\n\n## 1.3 使用Class对象的获取功能\n\n以下面这个`Person类`为例\n\n```java\npublic class Person {\n\tprivate String name;\n\tprivate int age;\n\tpublic int sex;\n\tprotected String intro;\n\tString education;\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n\n\tpublic Person(String name, int age) {\n\t\tsuper();\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t}\n\n\tpublic Person() {\n\t\tsuper();\n\t\t// TODO Auto-generated constructor stub\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Person [name=\" + name + \", age=\" + age + \", sex=\" + sex + \", intro=\" + intro + \", education=\"\n\t\t\t\t+ education + \"]\";\n\t}\n\n\tpublic void say() {\n\t\tSystem.out.println(name + \"最美！我爱\" + name);\n\t}\n\n}\n```\n\n### 获取成员变量\n\n#### 常用方法\n\n* Field  getField(String name) 返回一个Field对象，它反映此 Class对象所表示的类或接口的指定**公共成员字段**。  \n* Field[]  getFields() 返回一个包含某些 Field 对象的数组，这些对象反映此 Class 对象所表示的类或接口的所有可访问**公共字段**。 \n* Field  getDeclaredField(String name) 返回一个 Field 对象，该对象反映此 Class 对象所表示的类或接口的指定**已声明字段**。  \n* Field[]  getDeclaredFields() 返回 Field 对象的一个数组，这些对象反映此 Class 对象所表示的类或接口所声明的**所有字段**。\n\n#### 操作\n\n* 获取值：Object get(Object obj) 返回指定对象上此 Field 表示的字段的值。 \n* 设置值：void set(Object obj, Object value) 将指定对象变量上此 Field 对象表示的字段设置为指定的新值。 \n\n#### 代码\n\n```java\npublic class Demo02Reflect {\n\tpublic static void main(String[] args) throws Exception {\n\t\t//获取Person的class对象\n\t\tClass personClass=Person.class;\n\t\t\n\t\t//获取成员变量\n\t\t//getFields()，获取所有public修饰的成员变量\n\t\tField[] fields=personClass.getFields();\n\t\tfor(Field field:fields) {\n\t\t\tSystem.out.println(field);//只能获取到public修饰的成员变量\n\t\t}\n\t\t\n\t\t//getField(String)同样是获取指定public修饰的成员变量\n\t\tField sex=personClass.getField(\"sex\");\n\t\t//获取成员变量sex的值\n\t\tPerson p=new Person();\n\t\tObject value=sex.get(p);\n\t\tSystem.out.println(value);//因为没有给他赋值，所以获取的是默认的值0\n\t\t//设置sex的值\n\t\tsex.set(p, 1);\n\t\tSystem.out.println(p);//Person{name='null',age=0,sex=1,intro='null',education='null'}\n\t\t\n\t\tSystem.out.println(\"===============\");\n\t\t\n\t\t//getDeclaredFields()，获取所以的成员变量，不考虑修饰符\n\t\t//连私有的都可以获取，这就很牛逼，不用反射时，私有的属性是不能在类外面进行访问或设置的;\n\t\t//但是在反射里面，不存在私有。我的就是我的，你的还是我的\n\t\tField[] declaredFields=personClass.getDeclaredFields();\n\t\tfor(Field declaredField:declaredFields) {\n\t\t\tSystem.out.println(declaredField);\n\t\t}\n\t\tField name=personClass.getDeclaredField(\"name\");\n//\t\tObject value2=name.get(p);\n//\t\tSystem.out.println(value2);//java.lang.IllegalAccessException，会报错。虽然私有的可以访问，但不能直接访问。\n\t\t\n\t\t//在访问非public的成员变量的时候，需要忽略访问权限修饰符的安全性检查\n\t\tname.setAccessible(true);//暴力反射\n\t\tObject value2=name.get(p);\n\t\tSystem.out.println(value2);//null\n\t\tname.set(p, \"胡列娜\");\n\t\tSystem.out.println(p);//Person{name='胡列娜',age=0,sex=1,intro='null',education='null'}\n\t}\n}\n```\n\n> 注意点：\n>\n> 1. 一般地，私有的成员变量不能在类外面进行访问或设置；但是在反射中，私有成员变量就可以获取和设置。这就是反射一个很牛逼的点。\n> 2. 在访问非public的成员变量的时候，会抛异常`IllegalAccessException`。这就需要忽略访问权限修饰符的安全性检查`setAccessible(boolean flag)`，`true`表示忽略，这也叫做`暴力反射`\n\n### 获取构造方法\n\n#### 常用方法\n\n* Constructor<T>  getConstructor(Class<?>... parameterTypes) 返回一个 Constructor 对象，它反映此 Class 对象所表示的类的指定公共构造方法。  \n* Constructor<?>[]  getConstructors() 返回一个包含某些 Constructor 对象的数组，这些对象反映此 Class 对象所表示的类的所有公共构造方法。  \n* Constructor<T>  getDeclaredConstructor(Class<?>... parameterTypes) 返回一个 Constructor 对象，该对象反映此 Class 对象所表示的类或接口的指定构造方法。  \n* Constructor<?>[]  getDeclaredConstructors() 返回 Constructor 对象的一个数组，这些对象反映此 Class 对象表示的类声明的所有构造方法。\n\n#### 操作\n\n* 创建对象：T newInstance(Object... initargs) Uses the constructor represented by this Constructor object to create and initialize a new instance of the constructor's declaring class, with the specified initialization parameters.\n\n#### 代码\n\n```java\npublic class Demo03Reflect {\n\tpublic static void main(String[] args) throws Exception {\n\t\t// 获取Person的class对象\n\t\tClass personClass = Person.class;\n\t\t\n\t\t\n\t\t//获取构造方法\n\t\t//Constructor<T>  getConstructor(Class<?>... parameterTypes)  参数是一个可变参数\n\t\t//参数列表，表示名称和性别\n\t\tConstructor c=personClass.getConstructor(String.class,int.class);//注意Integer.class!=int.class\n\t\tSystem.out.println(c);\n\t\t//T newInstance(Object... initargs)通过这个来创建对象\n\t\tObject person=c.newInstance(\"胡列娜\",22);\n\t\tSystem.out.println(person);\n\t\t\n\t\tSystem.out.println(\"======================\");\n\t\t//也可以通过空参来获取构造方法\n\t\tConstructor c2=personClass.getConstructor();\n\t\tSystem.out.println(c2);\n\t\tObject person2=c2.newInstance();\n\t\tSystem.out.println(person2);\n\t\t\n\t\t//如果想使用空参构造方法创建对象，操作可以简化：Class对象的newInstance()\n\t\t//但是，这个方法在java9以后，就已经过时了，不推荐使用。\n\t\tSystem.out.println(personClass.newInstance());\n\t\t\n\t}\n}\n```\n\n> 注意：\n>\n> 私有的构造方法，也是需要通过暴力反射来解决。同理，获取成员方法时也一样。\n\n### 获取成员方法\n\n#### 常用方法\n\n* Method  getMethod(String name, Class<?>... parameterTypes) 返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。  \n* Method[]  getMethods() 返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。  \n* Method  getDeclaredMethod(String name, Class<?>... parameterTypes) 返回一个 Method 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。  \n* Method[]  getDeclaredMethods() 返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。\n\n#### 操作\n\n* 执行方法：Object invoke(Object obj, Object... args) 在具有指定参数的指定对象上，调用此Method对象表示的基础方法\n* 获取方法名：String getName() 以String形式返回此Method对象表示的方法的名称。\n\n#### 代码\n\n```java\npublic class Demo04Reflect {\n\tpublic static void main(String[] args) throws Exception {\n\t\t// 获取Person的class对象\n\t\tClass personClass = Person.class;\n\t\t\n\t\t//获取成员方法\n\t\t//Method getMethod(String name, Class<?>... parameterTypes)\n\t\tMethod m=personClass.getMethod(\"say\");\n\t\t//Object invoke(Object obj, Object... args)\n\t\t//执行方法\n\t\tm.invoke(new Person(\"胡列娜\",20));//胡列娜最美！我爱胡列娜\n\t\t\n\t\tSystem.out.println(\"===========\");\n\t\t\n\t\t//获取所有public修饰的方法getMethods\n\t\tMethod[] ms=personClass.getMethods();\n\t\tfor(Method method:ms) {\n\t\t\tSystem.out.println(method.getName());//包含父类里面的public方法\n\t\t}\n\t}\n}\n```\n\n下面放出一个坑\n\n```java\npublic class TestCircle {\n\tpublic double getArea(double r) {\n\t\treturn Math.PI*r*r;\n\t}\n\tpublic static void main(String[] args) throws NoSuchMethodException, SecurityException {\n\t\tClass c=TestCircle.class;\n\t\tMethod m=c.getDeclaredMethod(\"getArea\", Double.class);\n\t\tSystem.out.println(m);//java.lang.NoSuchMethodException\n\t}\n\n}\n```\n\n仔细一看报错了吧。这是我老师上课写的，结果我下课研究的时候，整了两个小时才整明白，找到错误。\n\n这个错，就是方法中变量的类型跟反射里面定义的类型不一样。\n\n通俗点说，就是你的方法的变量类型是int，那么反射中获取方法时，变量的类型是int.class，同理，如果是Integer，那么反射中应是Integer。可以参照[这篇文章](https://www.jianshu.com/p/f7f5cf5e08dd)\n\n### 获取类名\n\n#### 常用方法\n\n* String  getName() 以 String 的形式返回此 Class 对象所表示的实体（类、接口、数组类、基本类型或 void）名称。\n\n#### 代码\n\n``` java\nClass personClass = Person.class;\nSystem.out.println(personClass.getName());//输出的是全类名，即包名+类名\n```\n\n## 1.4 反射案例\n\n### 需求\n\n使用反射，写一个框架类，在不改变该类的任何代码的情况下，可以创建任意类的对象，并且执行其中任意的方法\n\n实现：\n\n1. 配置文件\n2. 反射\n\n步骤：\n\n1. 将需要创建的对象的全类名和需要执行的方法定义在配置文件中\n2. 在程序中加载读取配置文件\n3. 使用反射技术来加载类文件进内存\n4. 创建对象\n5. 执行方法\n\n> 通过这样，我们以后如果修改的话，就只需要改配置文件，而不需要改代码了\n\n### 代码\n\n```java\n/**\n * 框架类\n * @author kitchen\n *\n */\npublic class ReflectTest {\n\tpublic static void main(String[] args) throws Exception {\n\t\t// 使用反射，在不改变任何代码的情况下，可以帮我们创建任意类的对象，并且执行其中任意方法\n\n\t\t// 1.加载配置文件\n        // 加载文件方法由很多，比方说，可以通过文件io流来进行读取，但是java里面有现成的对象可以处理配置文件\n\t\t// 1.1创建Properties对象\n\t\tProperties pro = new Properties();\n\t\t// 1.2加载配置文件，转换为一个集合\n\t\t// 1.2.1获取class目录下的配置文件的方式\n\t\tClassLoader classLoader = ReflectTest.class.getClassLoader();\n//\t\tpro.load(new FileInputStream(\"src/demo44/pro.properties\"));//这个是读取demo44下的配置文件\n\t\tInputStream is = classLoader.getResourceAsStream(\"pro.properties\");// 这样读取的话，默认是放到src根目录下的\n\t\tpro.load(is);\n\n\t\t// 2.获取配置文件中定义的数据\n\t\tString className = pro.getProperty(\"className\");\n\t\tString methodName = pro.getProperty(\"methodName\");\n\n\t\t// 3.加载该类进内存\n\t\tClass cls = Class.forName(className);\n\t\t// 4.创建对象\n\t\tObject obj = cls.newInstance();\n\t\t// 5.获取方法对象\n\t\tMethod met = cls.getMethod(methodName);\n\t\t// 6.执行方法\n\t\tSystem.out.println(cls.getName());\n\t\tmet.invoke(obj);\n\n\t}\n}\n```\n\n当类是GirlFriend时，执行marry方法\n\n{% asset_img 2.png GirlFriend %}\n\n当类是Wife时，执行divorce方法\n\n{% asset_img 3.png Wife %}\n\n同样的代码，可以有不同的运行结果，这个过程只需要改配置文件。\n\n```properties\n# className=demo44.domain.GirlFriend\n# methodName=marry\n\nclassName=demo44.domain.Wife\nmethodName=divorce\n```\n\n### 好处\n\n当项目比较庞大的时候，如果直接改代码，改完之后还需要进行测试，容易出问题。而通过反射，只需要改配置文件就可以了。\n\n# 二、注解\n\n## 2.1 注解的概念\n\n注释：**用文字描述程序**。比方说描述程序的功能，程序变量的含义之类的。**注释给开发者看的**。\n\n注解：**说明程序的**。**注解给计算机看的**。\n\n{% asset_img 4.png 注解 %}\n\n**概念描述**\n\n* jdk1.5之后的新特性\n* 说明程序的\n* 使用注解：@注解名称\n\n**作用分类**\n\n1. 编写文档：通过代码里标识的注解生成文档（通过`javadoc 文件全名`生成doc文档）\n2. 代码分析：通过代码里标识的元数据对代码进行分析（使用反射）\n3. 编译检查：通过代码里标识的元数据让编译器能够实现基本的编译检查（Override）\n\n## 2.2 jdk的内置注解\n\n### 常用内置注解\n\n* @Override：检测被该注解标注的方法是否是继承自父类（接口）的\n\n* @Deprecated：将该注解标注的内容，已过时\n\n* @SuppressWarnings： 指示编译器去忽略注解中声明的警告。 \n\n了解更多的[java注解](https://www.runoob.com/w3cnote/java-annotation.html)，移步到菜鸟教程。\n\n### 使用\n\n```java\n@SuppressWarnings(\"all\")\npublic class Demo01Annotation {\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Demo01Annotation []\";\n\t}\n\n\t@Deprecated\n\tpublic void play() {\n\t\t// 这个方法后来发现有缺陷，又新增了一个play2方法\n\t}\n\n\tpublic void play2() {\n\t\t// 替代play方法，推荐开发者使用play2，而不使用play。\n\t\t// 同时为了保证能够兼容低版本jdk，play方法选择保留，但是要提示开发者不建议使用\n\t\tArrayList list = new ArrayList();\n\t}\n\n\tpublic void demo() {\n\t\tplay();\n\t}\n\n}\n```\n\n描述一下@SuppressWarning注解的使用。如果代码段报警告，可以通过@SuppressWarnings(\"all\")标注在其方法上来忽略警告，不过一般地，会直接将其标注在类上。\n\n{% asset_img 5.png 忽略警告 %}\n\n## 2.3 自定义注解\n\n### 格式\n\n如何自定义注解？先来看一下内置注解的格式：\n\n{% asset_img 6.png 内置注解 %}\n\n通过对两个内置注解的观察，我们可以发现，注解是由下面这两个部分组成的。\n\n* 元注解\n* public @interface 注解名称{}\n\n举个例子\n\n```java\npublic @interface Demo02Annotation {\n}\n```\n\n以上面这个为例，我们将其进行`javac`编译，然后再通过`javap`反编译，得到以下这个代码\n\n```java\npublic interface Demo02Annotation extends java.lang.annotation.Annotation {\n}\n```\n\n{% asset_img 7.png 编译反编译 %}\n\n注解本质上就是一个接口，该接口默认继承了Annotation。接口里面可以定义什么，注解里面同样可以定义什么\n\n### 属性\n\n注解里的**属性**，可以认为是接口中的**抽象方法**，因为它可以在使用时，跟属性（成员变量）一样用\n\n要求：\n\n1. 属性的返回值类型：基本数据类型、String、枚举、注解、以上类型的数组\n2. 定义了属性，在使用时，需要给属性赋值。\n   * 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值\n   * 如果只有一个属性需要赋值，并且属性的名称是**value**，则value可以省略（可以参考@SuppressWarnings的源码）\n   * 数组赋值时，用{}包裹。如果其中只有一个值的时候，{}可以省略不写\n\n使用\n\n```java\n//定义一个枚举\nenum Person {\n\tMale, Female\n}\n\n//定义一个注解\n@interface Anno {\n\n}\n\npublic @interface Demo02Annotation {\n\tint value();\n\n\tString name() default \"胡列娜\";\n\tPerson p();//这是枚举\n\tAnno a();//这是注解\n\tString[] pers();//这是String类型数组\n}\n\n//尝试使用注解\n//@Demo02Annotation(age = 22, name = \"江厌离\")\n//如果我们不想给他赋值，我们可以在定义的时候，默认给他值\n//如 String name() default \"初值\"\n@Demo02Annotation(value=22,a = @Anno, p = Person.Male, pers = { \"胡列娜\",\"江厌离\",\"邱若水\" }) \nclass Worker {\n}\n```\n\n### 元注解\n\n元注解：用于描述注解的注解\n\n常用的元注解：\n\n* @Target：描述注解能够作用的位置\n  * ElementType取值\n    * TYPE：可以作用在类上\n    * METHOD：可以作用在方法上\n    * FIELD：可以作用在成员变量上\n* @Retention：描述注解被保留的阶段\n  * @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被jvm读取到。一般也只会用到这个\n* @Documented：描述注解是否被抽取到api文档中\n* @Inherited：描述注解是否被子类继承\n\n对于@Retention，把源码截图放到这里，其中刚好对应java代码经过的三个阶段\n\n{% asset_img 8.png @Retention %}\n\n像Documented，还有@Inherited就不多赘述了，演示过程也就不放上来了。通过命令**javadoc**生成文档时，会发现区别。\n\n```java\n//表示Demo03Annotation注解只能做作用于类、方法和变量上\n//注解被保留到Runtime阶段\n//同时因为只有一个变量，所以value可以省略\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ ElementType.TYPE,ElementType.METHOD,ElementType.FIELD })\npublic @interface Demo03Annotation {\n\n}\n@Demo03Annotation\nclass Worker01 {\n\t@Demo03Annotation\n\tpublic void show() {\n\t\t\n\t}\n}\n```\n\n## 2.4 使用（解析）注解\n\n在程序中使用（解析）注解：**获取注解中定义的属性值**\n\n由此，在大多数时候，注解是**用来替换配置文件**的\n\n### 步骤\n\n1. 获取注解定义的位置的对象\n2. 获取指定的注解\n   * getAnnotation(Class)\n3. 调用注解中的抽象方法，获取配置的属性值\n\n### 代码\n\n跟[反射案例](#1-4-反射案例)一样，实现同样的功能。**用注解替代配置文件**。\n\n**Pro.java**\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Pro {\n\tString className();\n\n\tString methodName();\n}\n\n//下面这个代码，请忽略，只是为了帮助ReflectAnnotationTest.java理解第2步\n//相当于实现了注解接口的实现类，具体代码参照ReflectAnnotationTest.java\nclass ProImpl implements Pro {\n\n\t@Override\n\tpublic Class<? extends Annotation> annotationType() {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic String className() {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic String methodName() {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\n}\n```\n\n**ReflectAnnotation.java**\n\n```java\n@Pro(className = \"demo44.domain.GirlFriend\", methodName = \"marry\")\npublic class ReflectAnnotationTest {\n\tpublic static void main(String[] args) throws Exception {\n\t\t// 1.解析注解\n\t\t// 1.1获取该类的字节码文件对象\n\t\tClass<ReflectAnnotationTest> c = ReflectAnnotationTest.class;\n\t\t// 2.获取上边的注解对象\n\t\tPro an = c.getAnnotation(Pro.class);// 其实就是在内存中生成了一个该注解接口的子类实现对象，这个过程我另外写一个代码ProImpl.java\n\t\t// 3.调用注解对象中定义的抽象方法，获取返回值。因为该注解接口，已经在上一步中被实现了\n\t\tString className = an.className();\n\t\tString methodName = an.methodName();\n\n\t\t// 4.加载该类进内存\n\t\tClass cls = Class.forName(className);\n\t\t// 5.创建对象\n\t\tObject obj = cls.newInstance();\n\t\t// 6.获取方法对象\n\t\tMethod met = cls.getMethod(methodName);\n\t\t// 7.执行方法\n\t\tSystem.out.println(cls.getName());\n\t\tmet.invoke(obj);\n\t}\n}\n```\n\n## 2.5 实现简单的测试框架\n\n**Check.java**\n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Check {\n}\n```\n\n**Calculator.java**\n\n```java\npublic class Calculator {\n\n\t// 加法\n\t@Check\n\tpublic void add() {\n\t\tString str = null;\n\t\tstr.toString();\n\t\tSystem.out.println(\"1 + 0 =\" + (1 + 0));\n\t}\n\n\t// 减法\n\t@Check\n\tpublic void sub() {\n\t\tSystem.out.println(Integer.parseInt(\"hahah123\"));\n\t\tSystem.out.println(\"1 - 0 =\" + (1 - 0));\n\t}\n\n\t// 乘法\n\t@Check\n\tpublic void mul() {\n\t\tSystem.out.println(\"1 * 0 =\" + (1 * 0));\n\t}\n\n\t// 除法\n\t@Check\n\tpublic void div() {\n\t\tSystem.out.println(\"1 / 0 =\" + (1 / 0));\n\t}\n\n\tpublic void show() {\n\t\tSystem.out.println(\"永无bug...\");\n\t}\n\n}\n```\n\n**TestCheck.java**\n\n```java\n/**\n * 简单的测试框架\n * 当主方法执行后，会自动去执行被检测的所有方法（加了check注解的方法）\n * 判断是否有异常，然后记录到文件中\n * @author kit chen\n */\npublic class TestCheck {\n\tpublic static void main(String[] args) throws IOException {\n\t\tint count=0;//记录出错的次数\n\t\tBufferedWriter bw=new BufferedWriter(new FileWriter(\"bug.txt\"));\n\t\t//1.创建计算器对象\n\t\tCalculator c=new Calculator();\n\t\t//2.获取字节码文件\n\t\tClass cls=c.getClass();\n\t\t//3.获取所有方法\n\t\tMethod[] methods=cls.getMethods();\n\t\t//4.判断方法上是否有check注解，有就执行，无就跳过\n\t\tfor(Method m:methods) {\n\t\t\tif(m.isAnnotationPresent(Check.class)) {\n\t\t\t\ttry {\n\t\t\t\t\tm.invoke(c);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t//5.捕获异常，记录到文件\n\t\t\t\t\tcount++;\n\t\t\t\t\tbw.write(\"异常的方法：\"+m.getName());\n\t\t\t\t\tbw.newLine();\n\t\t\t\t\tbw.write(\"异常的名称：\"+e.getCause().getClass().getSimpleName());\n\t\t\t\t\tbw.newLine();\n\t\t\t\t\tbw.write(\"异常的原因：\"+e.getCause().getMessage());\n\t\t\t\t\tbw.newLine();\n\t\t\t\t\tbw.write(\"======================\");\n\t\t\t\t\tbw.newLine();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbw.write(\"本次测试一共出现 \"+count+\" 次异常\");\n\t\tbw.flush();\n\t\tbw.close();\n\t}\n}\n```\n\n**运行结果**\n\n{% asset_img 9.png 测试结果 %}\n\n这就实现了一个简单的测试框架。\n\n同样的道理，像原来学过的Junit就算是一个测试框架了，里面的@Test就是注解。\n\n> 总结：\n>\n> * 大多数时候，会使用注解，而不是自定义注解\n>\n> * 注解为谁服务？\n>   * 编译器\n>   * 解析程序。像刚才的TestCheck.java就算是一个解析程序了。如果没有程序的存在，注解的存在将毫无意义\n> * 注解不是程序的一部分，可以将注解理解成一种标签。以刚才例子来说，给方法加上@Check，就表示，这个方法要被检测的意思。\n\nPS：今天形式政策考试考了65，老师在群里让同学发成绩单，我的分数是最低的。这也算是我一段时间来学习态度的反映吧。像数学跟线代还有英语，这学期，上网课期间，我不是上课睡觉，就是在玩电脑，一点都没听，我也该收收心好好学学数学了。加油！奥利给！好好学习！","tags":["java"]},{"title":"报告管理信息系统","url":"/blog/2020/record-management/","content":"\n最后的java课程设计，只是完成了逻辑功能，但是想要美化的还是可以的，懒得整了。\n\n要啥自行车！\n\n<!--more-->\n\n#  报告管理信息系统\n\n## 一、效果演示\n\n###  1.1 登录窗口\n\n![登录窗口](https://meethigher.github.io/record-management/resources/login.png )\n\n### 1.2 主窗口\n\n![主窗口](https://meethigher.github.io/record-management/resources/main.png )\n\n### 1.3 功能模块\n\n![添加数据](https://meethigher.github.io/record-management/resources/add.png  )\n\n\n\n## 二、运行环境\n\njdk 1.8+\n\nmysql 8.0+\n\n## 三、项目功能\n\n1. 登录\n   * 错输三次退出\n2. 数据模块\n   * 添加数据\n   * 查询数据\n   * 修改数据\n   * 删除数据\n   * 导出数据\n3. 帮助模块\n   * 下载源码\n   * 在线文档\n   * 关于作者\n4. 退出\n\n## 四、项目文档\n\n[在线文档](https://meethigher.github.io/record-management/)\n\n[下载源码](https://github.com/meethigher/record-management/)\n\n","tags":["java","open"]},{"title":"早起之后的反思","url":"/blog/2019/reflection/","content":"\n今天是四六级考试的一天，也是我反思的一天，当然不是反思的四六级啦~\n\n<!--more-->\n\n忙碌了一个晚上，加一上午，我的qq群自动签到程序完成了。\n\n还是挺开心的，下面附几张图吧。\n\n{% asset_img qiandao.png java签到程序 %}\n\n{% asset_img shoujiqiandao.png Tim签到效果 %}\n\n但是，主要好多东西还是借鉴了别人的思想来实现自己的逻辑，没有独立的思想。通俗点说吧，抄的。\n\n今天早上看到了一个大佬的博客，感慨颇深。\n\n别人（[Jack Cui](https://cuijiahua.com/)）开源的一个项目，拥有`9.6k`的`star`，我开源的一个也没有。\n\n我写的好多东西，一般碰到不会的，就是去百度查，已经成为了一种惯性思维，最终的目的只是想要实现这个功能，而忽略了一些重要的东西——通过这个过程，能学到自己所需的知识或者技术。\n\n如果只是想要实现最终的功能，那跟一些底层的程序员，一些因为完成不了工作而猝死的程序员，有什么区别呢？\n\n那么，如果百度没有呢？我觉得，肯定会淘汰一大批程序员了，包括我这样的在内。\n\n像我到目前为止，我所碰到的牛逼的程序员——高薪而又活得充实的，无一不是享受这个职业的。\n\n去他们的github上逛逛，人家写的东西，大多数是之前没有的东西，也就是**创造**出来的。\n\n而我，是在已有的基础上，添加一些自定义的功能，有什么意思呢？**不过是站在巨人的肩膀上罢了**。\n\n既然你选择了这个职业，就注定要一辈子都要坚持学习这个习惯，有自己的独立思想，不随波逐流，并且**热爱**\n\n\" 我也想成为一个牛逼的人！\"\n\n\" 虽然我秉承代码是一种艺术的理念，但事实上我承认是个菜逼，接受各种批评  \"\n\n大学里，牛逼的人那么多，你怎敢放纵你的时间？\n\n> 想起啥，就写得啥，就这样吧。\n>\n> 下午还有英语六级考试，随缘吧，反正我也没准备。\n>\n> 人生啊，永远不要放弃学习啊~","tags":["life"]},{"title":"记录小米root的一些心得","url":"/blog/2020/root/","content":"\n\n之前小米平板root过一次，很麻烦。后来又把手机root了，发现小米手机的话，相对来说容易点。\n\n<!--more-->\n\n本来是学太极来着，然后学着学着，就看了李连杰的[《太极张三丰》](https://v.youku.com/v_show/id_XMzk0NTA2NTc2.html)。不得不说，老电影是真的经典，我本来就想着吃饭看一样，结果一看不可收拾。\n\n下面放上我收藏app的截图，还有[一篇文章](https://mp.weixin.qq.com/s/DhDKXFuMQaKE5VdG2Sy6mA)\n\n{% asset_img 2.png 宝贝 %}\n\n# 一、如何root\n\n线刷：通过USB连接数据线和电脑来进行刷机。这种情况，一般用于android被刷成砖头的时候。只要硬件不坏，随便刷，玩不坏的。不过，好的线刷包，免费的很少。\n\n卡刷：通过内存卡里的刷机包来进行刷机。比方说小米官方的推送。\n\n小米的产品支持root，但是，是不完全的root，root之后，仍然有部分功能是没法使用的。比方说操作系统文件。\n\n所以，我就采取了安装Magisk来获取完全root。\n\nMagisk的作者是台湾的一个大佬，我找到了他的[github](https://github.com/topjohnwu)，附上Magisk的[论坛地址](https://forum.xda-developers.com/apps/magisk)\n\n## 1.1 小米平板\n\n1. 下载Magisk框架。去xda下载，一个国外论坛，需要翻墙。\n2. 将压缩包移入手机存储。进入Recovery模式，使用第三方Recovery（我用的是twrp）模式，进行卡刷。\n3. 刷入成功后，重启手机，就会发现MagiskManager的图标。这是一个管理应用，而Magisk已经装入手机内部，此时也就有了root权限。换句话说，即使删掉MagiskManager，Magisk也还是存在与手机里的。\n\n## 1.2 小米手机\n\n1. 获得官方开发版的[root权限](https://www.miui.com/unlock/download.html)，这其实是个不完全root\n2. 授予MagiskManager管理应用root权限\n3. 点击安装（推荐）\n4. 重启之后，手机就获得root了。\n\n# 二、隐藏root\n\n我原来把手机root过一次，但实在受不了一些app老是检测root，我也不想整一些乱七八糟的模块。\n\n后来，实在是root之后的功能太实用了，又重新root了。\n\n接下来就碰到一些APP检测root，比方说建行APP，移动APP。\n\nMagisk里面自带了MagiskHide，启动之后，像移动app，就不会再检测了。但是建行还是会检测到。所以，我就百度了下，[网上](https://tieba.baidu.com/p/6477672358?red_tag=c0825192138)是这么说的\n\n{% asset_img 1.png 解决 %}\n\n原因就是在安装系统root的过程中，/system/xbin/下残留着su文件，虽然启动了MagiskHide，但是建行这类的app可能就是通过检测su文件来判断有没有root。删掉，就OK了。\n\n至此，root完美使用！\n\n# 三、系统升级\n\n* 如果是小米平板那种情况，刷入了第三方rec。需要下载完整包，twrp里刷入，刷面具，重启\n* 如果是小米手机那种情况，直接下载完整包，升级后重新开启root，重新安装面具\n\n具体的过程讲解看这个大佬[视频](https://www.bilibili.com/video/BV1o7411j7ks)\n\n# 四、修改步数\n\n下载的是[小米步数管理](https://github.com/LinYuLuo/XMStepManage)，一个几百k的app。需要将其转成系统应用。用Mt管理器，将data的相应app数据转到system下的priv-app，重启就可以了。\n\n原理就是直接修改了本地应用的数据，但是如何修改的，我还不清楚。\n","tags":["android","root"]},{"title":"开源主题Starry2.0发布","url":"/blog/2020/starry2-0/","content":"\n原来的页面太丑了，这次把主题大改了一下。\n\n<!--more-->\n\n先打个卡吧，今天干了10个小时，现在脑子嗡嗡的，看来我该休息了。\n\n{% asset_img 打卡.jpg 打卡 %}\n\nStarry1.0[源码](https://github.com/meethigher/hexo-theme-starry/tree/1.0)\n\nStarry2.0[源码](https://github.com/meethigher/hexo-theme-starry/tree/2.0)\n\n本次更新基本上属于一次大改了，主要还是碰到了之前一直崇拜的[偶像](https://maintao.com)，偶像看了我博客，说挺好。\n\n{% asset_img 榜样.jpg 我学习的榜样 %}\n\n但是我自己还是有自知之明的啊，首先我之前采用的rem布局，在移动端，字体就会偏小，移动端其实本来应该更注重于阅读的，然后我的站内搜索做的也很垃圾，我一直觉得自己看，无所谓，也就没优化了。\n\n因为被偶像夸奖的原因，连夜将整个主题大改了一遍。历时10个小时。\n\n这次主要更新的地方：\n\n1. 界面\n2. 搜索速度\n3. seo\n4. 页面压缩\n\n就这样啦，本身我就很菜，我感觉能做成这样，还是挺开心的啦。\n\n参考文档：\n\n* [hexo博客添加本地搜索功能](https://blog.csdn.net/nineya_com/article/details/103338696)\n* [Hexo瞎折腾系列(5) - 使用hexo-neat插件压缩页面静态资源](https://blog.csdn.net/lewky_liu/article/details/82432003)\n\n**1.0版本界面**\n\nPC端\n\n{% asset_img starry1.0PC端.png 旧版本PC端 %}\n\n移动端\n\n{% asset_img starry1.0移动端.jpg 旧版本移动端 %}\n\n**2.0版本界面**\n\nPC端\n\n{% asset_img starry2.0PC端.png 新版本PC端 %}\n\n移动端\n\n{% asset_img starry2.0移动端.jpg 新版本移动端 %}","tags":["open","hexo"]},{"title":"正则表达式","url":"/blog/2019/regular-expression/","content":"\n每次用到正则表达式的时候，总是去百度。虽然平时不常用，但是一到关键时候，就要百度，太费事了。今天，就总结一下吧\n\n<!--more-->\n\n# 概念\n\n什么是正则表达式？\n\n**正则表达式：**用于匹配规律规则的表达式。\n\n正则表达式，又称规则表达式。(英语:Regular Expression，在代码中常简写为regex、regexp或RE) \n\n# 作用\n\n* **匹配：**给定的字符串是否符合正则表达式的过渡逻辑\n* **提取：**从字符串中获取我们想要的特定部分\n* **替换：**强大的字符串替换能力\n\n## 特点\n\n* 灵活性、逻辑性和功能性强\n* 迅速地用极简单的方式达到字符串的复杂控制\n\n## 测试\n\n[在线测试正则](https://c.runoob.com/front-end/854)\n\n## 组成\n\n由**普通字符**和**元字符**两部分组成\n\n### 普通字符\n\n普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。 \n\n### 元字符\n\n#### 常用元字符串\n\n| 元字符 | 说明                                          |\n| ------ | --------------------------------------------- |\n| \\d     | 匹配数字 [0-9]                                |\n| \\D     | 匹配任意非数字的字符 \\[^0-9]                  |\n| \\w     | 匹配字母或数字或者下划线 [a-zA-Z_0-9]         |\n| \\W     | 匹配任意不是字母、数字、下划线 \\[^a-zA-Z_0-9] |\n| \\s     | 匹配任意的空白符 [ \\t\\n\\x0B\\f\\r]              |\n| \\S     | 匹配任意不是空白符的字符 \\[^\\s]               |\n| .      | 匹配除换行符以外的任意单个字符                |\n| ^      | 表示匹配行首的文本（以...开始）               |\n| $      | 表示匹配行尾的文本（以...结束）               |\n\n#### 限定符\n\n| 限定符 | 说明            |\n| ------ | --------------- |\n| *      | 重复0次或者多次 |\n| +      | 重复1次或者多次 |\n| ？     | 重复0次或者1次  |\n| {n}    | 重复n次         |\n| {n,}   | 重复n次或者多次 |\n| {n,m}  | 重复n到m次      |\n\n#### 其他\n\n| 其他 | 含义                                                         |\n| ---- | ------------------------------------------------------------ |\n| []   | 字符串用中括号括起来，表示匹配其中的任一字符，相当于或的意思 |\n| [^]  | 匹配除中括号以内的内容                                       |\n| \\    | 转义符                                                       |\n| \\|   | 或者，选择两个中的一个，注意\\|将左右两边分为两部分，而不管左右两边有多长多乱 |\n| ()   | 从两个直接量中选择一个，分组 eg：gr(a\\|e)y匹配gray和grey     |\n\n[\\u4e00-\\u9fa5] 匹配汉字\n\n## 案例\n\n验证手机号：\n\n```regex\n^\\d{11}$\n```\n\n验证邮编：\n\n```regex\n^\\d{6}$\n```\n\n验证日期 2019-11-29\n\n```regex\n^\\d{4}-\\d{1,2}-\\d{1-2}$\n```\n\n验证邮箱meethigher@qq.com\t\n\n```regex\n^\\w+@\\w+\\.\\w+$\n```\n\n验证ip地址 192.168.1.10\n\n```regex\n^\\d{1,3}\\(.\\d{1,3}){3}$\n```\n\n# JavaScript 中使用正则表达式\n\n## 创建正则对象\n\n方式1：\n\n```javascript\nvar reg = new Regex('\\d', 'i');\nvar reg = new Regex('\\d', 'gi');\n```\n\n方式2：\n\n```javascript\nvar reg = /\\d/i;\nvar reg = /\\d/gi;\n```\n\n### 参数\n\n| 标志 | 说明                |\n| ---- | ------------------- |\n| i    | 忽略大小写          |\n| g    | 全局匹配            |\n| gi   | 全局匹配+忽略大小写 |\n\n## 正则匹配\n\n```javascript\n// 匹配日期\nvar dateStr = '2015-10-10';\nvar reg = /^\\d{4}-\\d{1,2}-\\d{1,2}$/\nconsole.log(reg.test(dateStr));\n```\n\n### 匹配正则表达式\n\n\n    console.log(/./.test(\"除了回车换行以为的任意字符\"));//true\n    console.log(/.*/.test(\"0个到多个\"));//true\n    console.log(/.+/.test(\"1个到多个\"));//true\n    console.log(/.?/.test(\"哈哈\"));//true\n    console.log(/[0-9]/.test(\"9527\"));//true\n    console.log(/[a-z]/.test(\"what\"));//true\n    console.log(/[A-Z]/.test(\"Are\"));//true\n    console.log(/[a-zA-Z]/.test(\"干啥子\"));//false\n    console.log(/[0-9a-zA-Z]/.test(\"9ebg\"));//true\n    console.log(/b|(ara)/.test(\"abra\"));//true\n    console.log(/[a-z]{2,3}/.test(\"arfsf\"));//true\n    console.log(/\\d/.test(\"998\"));//true\n    console.log(/\\d*/.test(\"998\"));//true\n    console.log(/\\d+/.test(\"998\"));//true\n    console.log(/\\d{0,}/.test(\"998\"));//true\n    console.log(/\\d{2,3}/.test(\"998\"));//true\n    console.log(/\\D/.test(\"eat\"));//true\n    console.log(/\\s/.test(\"  \"));//true\n    console.log(/\\S/.test(\"嘎嘎\"));//true\n    console.log(/\\w/.test(\"_\"));//true\n    console.log(/\\W/.test(\"_\"));//true\n\n### 正则表达式案例\n\n1.验证密码强弱\n2.验证邮箱：[0-9a-zA-Z_.-]+[@][0-9a-zA-Z._-]+([.][a-zA-Z]+){1,2}\n3.验证中文名字[\\u4e00-\\u9fa5]\n\n自己完成\n\n## 正则提取\n\n```javascript\n// 1. 提取工资\nvar str = \"张三：1000，李四：5000，王五：8000。\";\nvar array = str.match(/\\d+/g);\nconsole.log(array);\n\n// 2. 提取email地址\nvar str = \"123123@xx.com,fangfang@valuedopinions.cn 286669312@qq.com 2、emailenglish@emailenglish.englishtown.com 286669312@qq.com...\";\nvar array = str.match(/\\w+@\\w+\\.\\w+(\\.\\w+)?/g);\nconsole.log(array);\n\n// 3. 分组提取  \n// 3. 提取日期中的年部分  2015-5-10\nvar dateStr = '2016-1-5';\n// 正则表达式中的()作为分组来使用，获取分组匹配到的结果用Regex.$1 $2 $3....来获取\nvar reg = /(\\d{4})-\\d{1,2}-\\d{1,2}/;\nif (reg.test(dateStr)) {\n  console.log(RegExp.$1);\n}\n\n// 4. 提取邮件中的每一部分\nvar reg = /(\\w+)@(\\w+)\\.(\\w+)(\\.\\w+)?/;\nvar str = \"123123@xx.com\";\nif (reg.test(str)) {\n  console.log(RegExp.$1);\n  console.log(RegExp.$2);\n  console.log(RegExp.$3);\n}\n```\n\n## 正则替换\n\n```javascript\n// 1. 替换所有空白\nvar str = \"   123AD  asadf   asadfasf  adf \";\nstr = str.replace(/\\s/g,\"xx\");\nconsole.log(str);\n\n// 2. 替换所有,|，\nvar str = \"abc,efg,123，abc,123，a\";\nstr = str.replace(/,|，/g, \".\");\nconsole.log(str);\n```\n\n## 案例：表单验证\n\n```html\nQQ号：<input type=\"text\" id=\"txtQQ\"><span></span><br>\n邮箱：<input type=\"text\" id=\"txtEMail\"><span></span><br>\n手机：<input type=\"text\" id=\"txtPhone\"><span></span><br>\n生日：<input type=\"text\" id=\"txtBirthday\"><span></span><br>\n姓名：<input type=\"text\" id=\"txtName\"><span></span><br>\n```\n\n```javascript\n//获取文本框\nvar txtQQ = document.getElementById(\"txtQQ\");\nvar txtEMail = document.getElementById(\"txtEMail\");\nvar txtPhone = document.getElementById(\"txtPhone\");\nvar txtBirthday = document.getElementById(\"txtBirthday\");\nvar txtName = document.getElementById(\"txtName\");\n\n//\ntxtQQ.onblur = function () {\n  //获取当前文本框对应的span\n  var span = this.nextElementSibling;\n  var reg = /^\\d{5,12}$/;\n  //判断验证是否成功\n  if(!reg.test(this.value) ){\n    //验证不成功\n    span.innerText = \"请输入正确的QQ号\";\n    span.style.color = \"red\";\n  }else{\n    //验证成功\n    span.innerText = \"\";\n    span.style.color = \"\";\n  }\n};\n\n//txtEMail\ntxtEMail.onblur = function () {\n  //获取当前文本框对应的span\n  var span = this.nextElementSibling;\n  var reg = /^\\w+@\\w+\\.\\w+(\\.\\w+)?$/;\n  //判断验证是否成功\n  if(!reg.test(this.value) ){\n    //验证不成功\n    span.innerText = \"请输入正确的EMail地址\";\n    span.style.color = \"red\";\n  }else{\n    //验证成功\n    span.innerText = \"\";\n    span.style.color = \"\";\n  }\n};\n```\n\n表单验证部分，封装成函数：\n\n```javascript\nvar regBirthday = /^\\d{4}-\\d{1,2}-\\d{1,2}$/;\naddCheck(txtBirthday, regBirthday, \"请输入正确的出生日期\");\n//给文本框添加验证\nfunction addCheck(element, reg, tip) {\n  element.onblur = function () {\n    //获取当前文本框对应的span\n    var span = this.nextElementSibling;\n    //判断验证是否成功\n    if(!reg.test(this.value) ){\n      //验证不成功\n      span.innerText = tip;\n      span.style.color = \"red\";\n    }else{\n      //验证成功\n      span.innerText = \"\";\n      span.style.color = \"\";\n    }\n  };\n}\n```\n\n通过给元素增加自定义验证属性对表单进行验证：\n\n```html\n<form id=\"frm\">\n  QQ号：<input type=\"text\" name=\"txtQQ\" data-rule=\"qq\"><span></span><br>\n  邮箱：<input type=\"text\" name=\"txtEMail\" data-rule=\"email\"><span></span><br>\n  手机：<input type=\"text\" name=\"txtPhone\" data-rule=\"phone\"><span></span><br>\n  生日：<input type=\"text\" name=\"txtBirthday\" data-rule=\"date\"><span></span><br>\n  姓名：<input type=\"text\" name=\"txtName\" data-rule=\"cn\"><span></span><br>\n</form>\n```\n\n```javascript\n// 所有的验证规则\nvar rules = [\n  {\n    name: 'qq',\n    reg: /^\\d{5,12}$/,\n    tip: \"请输入正确的QQ\"\n  },\n  {\n    name: 'email',\n    reg: /^\\w+@\\w+\\.\\w+(\\.\\w+)?$/,\n    tip: \"请输入正确的邮箱地址\"\n  },\n  {\n    name: 'phone',\n    reg: /^\\d{11}$/,\n    tip: \"请输入正确的手机号码\"\n  },\n  {\n    name: 'date',\n    reg: /^\\d{4}-\\d{1,2}-\\d{1,2}$/,\n    tip: \"请输入正确的出生日期\"\n  },\n  {\n    name: 'cn',\n    reg: /^[\\u4e00-\\u9fa5]{2,4}$/,\n    tip: \"请输入正确的姓名\"\n  }];\n\naddCheck('frm');\n\n\n//给文本框添加验证\nfunction addCheck(formId) {\n  var i = 0,\n      len = 0,\n      frm =document.getElementById(formId);\n  len = frm.children.length;\n  for (; i < len; i++) {\n    var element = frm.children[i];\n    // 表单元素中有name属性的元素添加验证\n    if (element.name) {\n      element.onblur = function () {\n        // 使用dataset获取data-自定义属性的值\n        var ruleName = this.dataset.rule;\n        var rule =getRuleByRuleName(rules, ruleName);\n\n        var span = this.nextElementSibling;\n        //判断验证是否成功\n        if(!rule.reg.test(this.value) ){\n          //验证不成功\n          span.innerText = rule.tip;\n          span.style.color = \"red\";\n        }else{\n          //验证成功\n          span.innerText = \"\";\n          span.style.color = \"\";\n        }\n      }\n    }\n  }\n}\n\n// 根据规则的名称获取规则对象\nfunction getRuleByRuleName(rules, ruleName) {\n  var i = 0,\n      len = rules.length;\n  var rule = null;\n  for (; i < len; i++) {\n    if (rules[i].name == ruleName) {\n      rule = rules[i];\n      break;\n    }\n  }\n  return rule;\n}\n```\n\n## ","tags":["js","regular-expression"]},{"title":"Servlet","url":"/blog/2020/servlet/","content":"\n\n记录Servlet的学习使用过程，另外typora的自带的小表情挺有意思。格式是**:emoji:**，可惜我这款主题还没添加这个功能，网上有别人写的现成的插件，傲娇的我又不是很想用。打算哪天空闲的时候，自己写一套支持emoji的插件\n\n<!--more-->\n\n先附上[JavaEE官方文档](https://docs.oracle.com/javaee/7/api/toc.htm)。\n\n之前课堂上学过jsp，jsp的每次修改之后不需要重启服务器，而Servlet修改一次需要重启一次。\n\nservlet和jsp本质都是servlet，运行时都是运行.class文件。但是它们的部署方式不一样。\n\nservlet是先编译后部署，修改完以后，IDE进行编译，然后部署.class文件到servlet容器中。如果web服务器已启动，则之前class已被servlet容器加载，可能修改后的class文件不会被servlet容器执行。\n\n而jsp是web服务器进行编译。tomcat可以设置为监视jsp文件的改动，改动之后则重新编译、执行。\n\n# 一、入门Servlet\n\n概念：运行在服务器端的小程序\n\n本质：Servlet就是一个接口，定义了java类被浏览器访问到（Tomcat识别到）的规则。\n\n## 1.1 快速入门\n\n1. 创建JavaEE项目\n2. 创建类，实现Servlet接口\n3. 实现接口中的抽象方法\n4. 配置Servlet\n\n配置Servlet，修改WEB-INF下的web.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n    <!--配置Servlet-->\n    <servlet>\n        <servlet-name>demo01</servlet-name>\n        <servlet-class>demo01_servlet.Demo01Servlet</servlet-class>\n    </servlet>\n    <!--Servlet映射-->\n    <servlet-mapping>\n        <servlet-name>demo01</servlet-name>\n        <!-- 访问路径，过滤器中这个地方是拦截路径 -->\n        <url-pattern>/demo01</url-pattern>\n    </servlet-mapping>\n</web-app>\n```\n\nDemo01Servlet.java\n\n```java\n/**\n * Servlet快速入门\n * @author https://github.com/meethigher\n */\npublic class Demo01Servlet implements Servlet {\n    @Override\n    public void init(ServletConfig servletConfig) throws ServletException {\n\n    }\n\n    @Override\n    public ServletConfig getServletConfig() {\n        return null;\n    }\n\n    /**\n     * 提供服务的方法\n     * @param servletRequest\n     * @param servletResponse\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {\n        System.out.println(\"Hello Servlet\");\n    }\n\n    @Override\n    public String getServletInfo() {\n        return null;\n    }\n\n    @Override\n    public void destroy() {\n\n    }\n}\n```\n\n访问localhost:8080/demo01，然后控制台就会输出Hello Servlet\n\n{% asset_img 1.png %}\n\n> 之前一直在用eclipse，最近改用idea，不得不说，真香！\n\n# 二、详解Servlet\n\n## 2.1 执行原理\n\n浏览器访问localhost:8080/demo01，tomcat从web.xml找资源路径/demo01，通过url找到配对的servlet-name，然后找到类文件（看到全类名，首先应该想到反射）\n\ntomcat将全类名对应的字节码文件加载进内存`Class.forName`，创建对象`class.newInstance`，调用方法`service`，这些过程都是在服务器完成的。\n\n总结\n\n1. 当服务器接收到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径\n2. 查找web.xml，是否有对应的`<url-pattern>`便签体内容\n3. 如果有，则再找到对应的`<servlet-class>`找到全类名，Tomcat将字节码文件加载进内存，并创建其对象\n4. 调用方法\n\n## 2.2 生命周期\n\n1. 被创建：执行init方法，只执行一次。\n   * 默认情况下，第一次访问时，Servlet被创建\n   * 可以指定Servlet启动的时机为启动服务器时，Servlet被创建，一般用于加载资源\n2. 提供服务：执行service方法，执行多次\n   * 每次访问Servlet时，service都会被调用一次\n3. 被销毁：执行destroy方法（服务器正常关闭时），只执行一次\n   * Servlet被销毁时执行。如果服务器不是正常关闭，不会执行。destroy可以理解为“临终遗言”，在Servlet销毁之前执行。一般用于释放资源。\n\n```java\npublic class Demo02Servlet implements Servlet {\n    /**\n     * 初始化方法\n     * 在Servlet被创建时执行。只会执行一次\n     * @param servletConfig\n     * @throws ServletException\n     */\n    @Override\n    public void init(ServletConfig servletConfig) throws ServletException {\n        System.out.println(\"init...\");\n    }\n\n    /**\n     * 获取Servlet对象\n     * @return\n     */\n    @Override\n    public ServletConfig getServletConfig() {\n        return null;\n    }\n\n    /**\n     * 提供服务的方法\n     * 每一次Servlet被访问，都会被执行。执行多次\n     * @param servletRequest\n     * @param servletResponse\n     * @throws ServletException\n     * @throws IOException\n     */\n    @Override\n    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {\n        System.out.println(\"service...\");\n    }\n\n    /**\n     * 获取Servlet的一些信息，版本、作者等等\n     * @return\n     */\n    @Override\n    public String getServletInfo() {\n        return null;\n    }\n\n    /**\n     * 销毁方法\n     * 在服务器正常关闭时，执行一次\n     */\n    @Override\n    public void destroy() {\n        System.out.println(\"destory...\");\n    }\n}\n```\n\n配置Servlet启动的时机\n\n  1. 第一次被访问时创建。`<load-on-startup>`为负数，一般为-1\n  2. 在服务器启动时创建。`<load-on-startup>`为0或正整数，一般为0-10\n\n```xml\n<!--配置Servlet-->\n    <servlet>\n        <servlet-name>demo02</servlet-name>\n        <servlet-class>demo01_servlet.Demo02Servlet</servlet-class>\n        <!--指定Servlet的创建时机\n        1. 第一次被访问时，创建。<load-on-startup>为负数，一般为-1\n        2. 在服务器启动时，创建。<load-on-startup>为0或正整数，一般为0-10\n        -->\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n```\n\n> Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的。\n>\n> 多个用户同时访问时，可能存在线程安全问题。就比方说买票，容易数据错乱\n>\n> 解决方法：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对其赋值和修改值。\n\n## 2.3 注解配置\n\n在Servlet3.0之前，需要通过配置文件web.xml来配置。但是，太麻烦。\n\n在Servlet3.0之后，可以通过注解来配置，web.xml可以不需要了。\n\n从JavaEE6之后，才开始支持Servlet3.0。\n\n步骤\n\n1. 创建JavaEE项目，选择Servlet的版本为3.0以上，可以不创建web.xml\n2. 定义一个类，实现Servlet接口\n3. 实现接口中的抽象方法\n4. 在类上使用注解@WebServlet\n   * `@WebServlet(\"资源路径\")`，当然@WebServlet还可以配置别的内容，具体参照其源码\n\n{% asset_img 2.png %}\n\n> 参照文章[注解](https://meethigher.top/blog/2020/reflection-and-annotation/#2-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3)\n>\n> 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值\n>\n> 如果只有一个属性需要赋值，并且属性的名称是**value**，则value可以省略（可以参考@SuppressWarnings的源码）\n>\n> 数组赋值时，用{}包裹。如果其中只有一个值的时候，{}可以省略不写\n\n{% asset_img 3.png %}\n\n## 2.4 编译器与其Tomcat相关配置\n\n如果直接使用tomcat的bin目录下脚本打开服务器，他的配置文件就放在服务器根目录下了。\n\n{% asset_img 4.png %}\n\n对于编译器，他们会给集成到自身的tomcat单独建立配置文件。eclipse和idea这两款编译器，我都用过。\n\n如果使用eclipse，那么eclipse会给他单独配置一个路径\n\n{% asset_img 5.png %}\n\n同样地，idea也会单独配置路径来存储配置文件\n\n{% asset_img 6.png %}\n\n项目分为工作空间目录和tomcat部署的Web项目\n\n* tomcat真正访问的是tomcat部署的Web项目，而tomcat会将编译后的工作空间目录内容的字节码文件放到WEB-INF下的classes中\n* WEB-INF下的文件不能直接被浏览器访问\n* 断点调试：不能直接运行服务器，需要通过Debug模式来运行服务器\n\n## 2.5 Servlet体系结构\n\n每次都像上面那样实现Servlet接口，却只用到了service方法，多余！那就需要通过一个实现类来帮助完成。Servlet自身有这种体系结构。\n\nHttpServlet继承自GenericServlet，GenericServlet实现Servlet接口。看[文档](https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServlet.html)或者源码\n\nGenericServlet：将Servlet接口中的其他方法做了默认空实现，只将service()方法作为抽象\n\n* 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可。其他方法可以自选重写\n\nHttpServlet：对http协议的一种封装，简化操作\n\n1. 定义类继承HttpServlet\n2. 重写doGet和doPost方法\n\n> 在实际使用中，继承HttpServlet的方法会更好\n\n## 2.6 Servlet相关配置\n\nurlPattens：Servlet访问路径\n\n* 一个Servlet可以定义多个访问路径：@WebServlet({\"/d6\",\"/dd6\",\"/demo06\"})\n* 路径定义规则：如`/xxx`、`/xxx/xxx`（多层路径，目录结构）、` /*`（`*`的优先级很低，如果在访问已经配置的路径时，则会访问已配置的路径）、`*.do`（如果写`*.do`是会报错的，这个只是换了一个扩展名而已）\n\n> 在注解中，如果属性值是value，那么value可以省略。\n>\n> 在配置访问路径的时候，是走的value，而不是urlPattens。我就在想，那么实现类是如何将value转换成url的呢？\n>\n> 找了半天，百度，和官网源码，也没找到@WebServlet的实现类。\n>\n> 后来再文档中看到说，value跟urlPatterns是一个东西。WTF！可能官方是为了让书写更加简洁？\n\n{% asset_img 7.png %}\n\n# 三、HTTP请求协议\n\n概念：Hyper Text Transfer Protocol 超文本传输协议\n\n传输协议：定义了客户端和服务端通信时，发送数据的格式\n\n特点\n\n1. 基于TCP/IP的高级协议\n2. 默认端口号：80\n3. 基于请求/响应模型的：一次请求对应一次响应\n4. 无状态的协议：每次请求之间相互独立\n\n历史版本\n\n* 1.0：每一次请求响应都会建立新的连接\n* 1.1：复用连接\n\n具体的[各版本的区别](https://www.cnblogs.com/surui/p/11669346.html)\n\n## 3.1 请求消息数据格式\n\n1. 请求行\n   * 请求方式 请求url 请求协议/版本。如GET /login.html HTTP/1.1\n2. 请求头\n   * 请求头名称:请求头值1,请求头值2,...\n3. 请求空行：作分割作用\n4. 请求体（正文）：get方式是没有请求体的。用来封装post请求消息的请求参数的\n\n字符串格式的请求数据\n\n```http\nPOST http://meethigher.top/admin/login.php HTTP/1.1\nHost: meethigehr.top\nConnection: keep-alive\nContent-Length: 35\nCache-Control: max-age=0\nOrigin: http://baixiu-dev.top\nUpgrade-Insecure-Requests: 1\nContent-Type: application/x-www-form-urlencoded\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.79 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nReferer: http://meethigher.top/\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9\nCookie: PHPSESSID=cdtnkpj4apnarjhtqugqegsfmn\n\nemail=admin@qq.com&password=admin\n```\n\n### 请求方式\n\nHttp协议中有7种请求方式，常用的有2种\n\n* get\n  * 请求参数在请求行中（也可以理解在url中）\n  * 请求的url长度是有限制的\n  * 相对不安全\n* post\n  * 请求参数在请求体中\n  * 请求的url长度是没有限制的\n  * 相对安全\n\n### 请求头\n\n常见的请求头\n\n1. User-Agent：浏览器访问服务器内容时，使用的浏览器版本信息\n2. Referer：告诉服务器，当前请求从哪里来\n3. Connection：keep-alive一直连接，表示可复用\n\nReferer有两个作用\n\n1. 防盗链（盗取超链接）\n2. 统计功能\n\n比如看斗罗大陆，一般是通过选了集数，跳转到腾讯播放页观看，这是用户正常的播放流程。但是如果，用户通过自己建的网页，直接指向腾讯播放页，这个过程就叫做**盗链**。\n\n## 3.2 响应消息数据格式\n\n1. 响应行\n   * 请求协议/版本 响应状态码 状态码描述\n2. 响应头\n   * 响应头名称:响应头值1,响应头值2,...\n3. 响应空行\n4. 响应体\n\n字符串格式的响应数据\n\n```http\nHTTP/1.1 302 Found\nDate: Tue, 09 Jun 2020 01:43:26 GMT\nServer: Apache/2.4.34 (Win64) PHP/7.2.10\nX-Powered-By: PHP/7.2.10\nExpires: Thu, 19 Nov 1981 08:52:00 GMT\nCache-Control: no-store, no-cache, must-revalidate\nPragma: no-cache\nLocation: /admin/index.php\nContent-Length: 2508\nKeep-Alive: timeout=5, max=100\nConnection: Keep-Alive\nContent-Type: text/html; charset=UTF-8\n\n<html>返回一套html代码，此处省略</html>\n```\n\n### 响应状态码\n\n服务器告诉客户端浏览器本次请求和响应的状态，状态码都是三位数字\n\n[状态码](https://www.runoob.com/http/http-status-codes.html)分类\n\n1. 1xx：服务器接收客户端消息，但是没有接收完成，等待一段时间后，发送1xx多状态码\n2. 2xx：表示成功。最常见的就是200\n3. 3xx：表示重定向。最常见的302（重定向），304（访问缓存）\n4. 4xx：客户端错误。最常见的404（代表请求路径没有对应的资源），405（请求方式没有相应的方法，比方说在Servlet中，没有doGet方法或者doPost方法）\n5. 5xx：服务器端错误 。最常见的500（代表服务器内部错误）\n\n### 响应头\n\n常见的响应头\n\n1. Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式\n2. Content-disposition：服务器告诉客户端以什么格式打开响应体数据\n   * in-line：默认值（在当前页面内打开）\n   * attachment;filename=xxx：以附件形式打开响应体。在文件下载中，会使用这个，文件名是xxx\n\n### 响应体\n\n响应体就是真实的传输的数据\n\n# 四、Request\n\nRequest对象和Response对象的原理\n\n1. request和response是由服务器来创建，开发者来使用\n2. request获取请求消息，response设置响应消息\n\n## 4.1 Request对象继承体系结构\n\ntomcat里面的`RequestFacade`类实现了继承自`ServletRequest`接口的实现类`HttpServletRequest`\n\n具体的实现可以在Tomcat的源码中查看。\n\n## 4.2 Request功能\n\n1. 获取请求消息\n   * 获取请求行数据（标❤比较常用）\n     * 获取请求方式：String getMethod()\n     * ❤获取虚拟目录：String getContextPath()\n     * 获取Servlet路径：String getServletPath()\n     * 获取get请求参数：String getQueryString()\n     * ❤获取请求URI：String getRequestURI()和String getRequestURL()\n     * 获取协议以及版本：String getProtocol()\n     * 获取客户机ip地址：String getRemoteAddr()\n   * 获取请求头数据（标❤比较常用，请求头是不区分大小写的）\n     * ❤String getHeader(String name)：通过请求头的名称，获取请求头的值\n     * Enumeration<String> getHeaderNames()：获取所有的请求头名称\n   * 获取请求体数据：只有post请求方式，才有请求体，在请求体中封装了post请求的请求参数\n     1. 获取流对象\n        * BufferedReader getReader()：获取字符输入流，只能操作字符\n        * ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据。用于文件上传比较好\n     2. 流对象中拿数据\n2. ❤其他功能\n   * 获取请求参数通用方式：不论get或是post请求，都可以使用下面这些方法\n     * String getParameter(String name)：根据参数名称获取参数值\n     * String[] getParameterValues(String name)：根据参数名称获取参数值数组，多用于复选框\n     * Enumeration<String> getParameterNames()：获取所有请求的参数名称\n     * Map<String,String[]> getParameterMap()：获取所有参数的map集合\n   * 请求转发：一种在服务器内部的资源跳转方式\n   * 共享数据\n   * 获取ServletContext对象\n\n### 获取请求消息\n\n#### 获取请求行\n\n```java\n@WebServlet(\"/demo01request\")\npublic class Demo01Request extends HttpServlet {\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        /*\n         * 获取请求方式：String getMethod()\n         * ❤获取虚拟目录：String getContextPath()\n         * 获取Servlet路径：String getServletPath()\n         * 获取get请求参数：String getQueryString()\n         * ❤获取请求URI：String getRequestURI()和String getRequestURL()\n         * 获取协议以及版本：String getProtocol()\n         * 获取客户机ip地址：String getRemoteAddr()\n         */\n        System.out.println(request.getMethod());// GET\n        System.out.println(request.getContextPath());// /demo\n        System.out.println(request.getServletPath());// /demo01request\n        System.out.println(request.getQueryString());// user=hh&password=123\n        System.out.println(request.getRequestURI()+\"---\"+request.getRequestURL());// /demo/demo01request---http://localhost:8080/demo/demo01request\n        System.out.println(request.getProtocol());// HTTP/1.1\n        System.out.println(request.getRemoteAddr());// 这是获取的ipv6地址 0:0:0:0:0:0:0:1\n    }\n}\n```\n\n> URL 统一资源定位符\n>\n> URI 统一资源标识符\n>\n> URI代表的范围更大一些（并不是取决于路径的长度的），URL限制了指定的服务器，而URI是没有限制的，应该这样理解\n\n{% asset_img 8.png idea中配置虚拟目录的方法 %}\n\n#### 获取请求头\n\n```java\n@WebServlet(\"/demo02request\")\npublic class Demo02Request extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        Enumeration<String> headerNames = request.getHeaderNames();\n        while (headerNames.hasMoreElements()) {\n            String str = headerNames.nextElement();\n            if (\"user-agent\".equals(str)) {\n                String agent = request.getHeader(str);\n                if (agent.contains(\"Chrome\")) {\n                    System.out.println(\"Chrome\");\n                } else if (agent.contains(\"Firefox\")) {\n                    System.out.println(\"Firefox\");\n                }\n\n            }\n        }\n\n    }\n}\n```\n\n#### 获取请求体\n\n```java\n@WebServlet(\"/demo03request\")\npublic class Demo03Request extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //获取请求消息体 请求参数\n        request.setCharacterEncoding(\"utf-8\");\n        //1.获取字符流\n        BufferedReader br=request.getReader();\n        //2.读取数据\n        String line=null;\n        while((line=br.readLine())!=null){\n            System.out.println(line);\n        }\n    }\n}\n```\n\n> 这个部分出了点问题，就是它输出的内容，将字符串以url编码形式打印出来了。而后面的getParameter是直接原样输出的。那这两个的区别是啥？我尝试查看HttpServletRequest这个接口的实现类，最后通过request.getClass().getName()输出全类名，发现实现类是在tomcat里面。\n>\n> 结果里面的代码，也是超级简洁，我也没咋看明白两者的不同之处，惆怅。\n\n### 4.3 其他功能\n\n#### 获取请求参数通用方式\n\n这个方式既适用于post也适用于get，所以说是通用方式\n\n```java\n@WebServlet(\"/demo04request\")\npublic class Demo04Request extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        request.setCharacterEncoding(\"utf-8\");\n        //post获取请求参数\n        //根据参数名称获取参数值\n//        String user = request.getParameter(\"user\");\n//        String password = request.getParameter(\"password\");\n//        System.out.println(user+\"--\"+password);\n//        //根据参数名称获取参数值数组\n//        String[] hobbies=request.getParameterValues(\"beauty\");\n//        for (String hobby: hobbies) {\n//            System.out.println(hobby);\n//        }\n        //获取所有请求的参数名称\n//        Enumeration<String> parameterNames = request.getParameterNames();\n//        while(parameterNames.hasMoreElements()){\n//            System.out.println(parameterNames.nextElement());\n//        }\n        //测试热部署\n        System.out.println(\"奥利给\");//没卵用，百度一下，发现要用debug模式运行才可以\n\n        //获取所有参数的Map集合\n        Map<String, String[]> parameterMap = request.getParameterMap();\n        //遍历\n        Set<String> strings = parameterMap.keySet();\n        for(String key:strings){\n            System.out.println(key+\"↓↓↓↓↓↓\");\n            //根据key获取值\n            String[] strings1 = parameterMap.get(key);\n            //遍历值数组\n            for (String value:strings1) {\n                System.out.println(value);\n            }\n            System.out.println(\"------\");\n        }\n\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request,response);\n    }\n}\n```\n\n#### 请求转发\n\n步骤\n\n1. 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path)\n2. 使用RequestDispatcher对象进行转发：void forward(ServletRequest request, ServletResponse response)  \n\n特点\n\n1. 浏览器地址栏路径没有发生变化\n2. 只能转发到当前的服务器内部中\n3. 转发是一次请求\n\n#### 共享数据\n\n域对象：一个有作用范围的对象，可以在范围内共享数据\n\nrequest域：代表一次请求的范围。一般用于**请求转发**的多个资源中共享数据\n\n方法\n\n1. setAttribute(String name,Object object)：存储数据\n2. Object getAttribute(String name)：通过键获取值\n3. removeAttribute(String name)：通过键移除值\n\n```java\n@WebServlet(\"/demo05request\")\npublic class Demo05Request extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        System.out.println(\"demo05request\");\n        request.setAttribute(\"女神\",\"胡列娜\");\n        RequestDispatcher requestDispatcher = request.getRequestDispatcher(\"/demo06request\");\n        requestDispatcher.forward(request,response);\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request,response);\n    }\n}\n```\n\ndemo05将请求转发到demo06，同时在request域内共享数据\n\n```java\n@WebServlet(\"/demo06request\")\npublic class Demo06Request extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        System.out.println(\"demo06request\");\n        System.out.println(request.getAttribute(\"女神\"));\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request,response);\n    }\n}\n```\n\n#### 获取ServletContext\n\nServletContext getServletContext()\n\n### 4.4 中文乱码问题\n\nget方式：Tomcat8已经将get方式乱码解决了\n\npost方式：会乱码。解决方式是在获取参数前，将request的编码设置为utf-8\n\n```java\nrequest.setCharacterEncoding(\"utf-8\")\n```\n\n# 五、用户登录案例\n\n## 5.1 需求\n\n1. 编写登录页面，账号密码\n2. 使用Druid数据库连接技术\n3. 使用JDBCTemplate技术封装JDBC\n4. 登录成功，跳转SuccessServlet，提示登录成功\n5. 登录失败，跳转到FailServlet，提示登录失败\n\n## 5.2 实现\n\n1. 创建项目、登录界面，配置文件以及数据库，导入jar包（在Web项目下，jar包一般是放在WEB-INF的lib目录下）\n2. 创建包domain，包下建User表，对应着数据库表\n3. 创建包dao，包下建UserDao，提供Login方法\n4. 创建包utils，包下建JDBCUtils（连接池工具类）\n5. 创建包servlet，包下建响应的Servlet\n6. 创建包test，通过Junit进行单元测试\n\n### 代码\n\nlogin.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>登录</title>\n</head>\n<body>\n<form action=\"loginServlet\" method=\"post\">\n    名：<input type=\"text\" name=\"user\"><br>\n    密：<input type=\"password\" name=\"password\"><br>\n    <input type=\"submit\" value=\"提交\">\n</form>\n</body>\n</html>\n```\n\ndao层下的UserDao.java\n\n```java\n/**\n * 操作数据中user表的类\n * @author https://github.com/meethigher\n */\npublic class UserDao {\n    private JdbcTemplate temp=new JdbcTemplate(JDBCUtils.getDs());\n    /**\n     * 登录方法\n     * @param loginUser 只有用户名和密码\n     * @return 包含用户全部方法\n     */\n    public User login(User loginUser){\n        try {\n            //1.编写sql,只查询一条数据，因为我数据库里存储的内容有重复值，所有...\n            String sql=\"select * from user where user=? and password=? limit 0,1\";\n            //2.调用template的查询方法\n            User user = temp.queryForObject(sql,\n                    new BeanPropertyRowMapper<User>(User.class),\n                    loginUser.getUser(),loginUser.getPassword());\n            return user;\n        } catch (DataAccessException e) {\n            //如果没有查到内容，返回null\n            e.printStackTrace();//后期不再会使用打印异常，而是通过记录日志的方式\n            return null;\n        }\n    }\n}\n```\n\ndomain层的User.java\n\n```java\n/**\n * 用户的JavaBean\n * @author https://github.com/meethigher\n */\npublic class User {\n    private int id;\n    private String user;\n    private String password;\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public String getUser() {\n        return user;\n    }\n\n    public void setUser(String user) {\n        this.user = user;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n}\n```\n\nutils层下的JDBCUtils.java\n\n```java\n/**\n * JDBC工具类，使用Druid连接池\n *\n * @author https://github.com/meethigher\n */\npublic class JDBCUtils {\n    private static DataSource ds;\n\n    /**\n     * 静态代码块初始化连接池对象\n     */\n    static {\n        try {\n            //1.加载配置文件\n            Properties pro = new Properties();\n            InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(\"druid.properties\");\n            pro.load(is);\n            //2.初始化连接池对象\n            ds = DruidDataSourceFactory.createDataSource(pro);\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n\n    }\n\n    /**\n     * 获取连接池对象\n     * @return\n     */\n    public static DataSource getDs() {\n        return ds;\n    }\n\n    /**\n     * 获取连接对象\n     * @return\n     * @throws SQLException\n     */\n    public static Connection getConnection() throws SQLException {\n        return ds.getConnection();\n    }\n}\n```\n\ntest层下的UserDaoTest.java\n\n```java\n/**\n * @author https://github.com/meethigher\n */\npublic class UserDaoTest {\n    @Test\n    public void testLogin(){\n        User u=new User();\n        u.setUser(\"胡列娜\");\n        u.setPassword(\"123f\");\n        UserDao udao=new UserDao();\n        udao.login(u);\n    }\n}\n```\n\nservlet层下的LoginServlet.java\n\n```java\n@WebServlet(\"/example/loginServlet\")\npublic class LoginServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //设置编码\n        request.setCharacterEncoding(\"utf-8\");\n        //获取请求参数\n        String user = request.getParameter(\"user\");\n        String password = request.getParameter(\"password\");\n        //封装User对象\n        User loginUser = new User();\n        loginUser.setUser(user);\n        loginUser.setPassword(password);\n        //调用UserDao的登录方法\n        User login = new UserDao().login(loginUser);\n        //判断是否登录成功\n        if(login!=null){\n            request.setAttribute(\"user\",login);\n            request.getRequestDispatcher(\"/example/successServlet\").forward(request,response);\n        }else{\n            request.getRequestDispatcher(\"/example/failServlet\").forward(request,response);\n        }\n\n    }\n}\n```\n\nservlet层下的SuccessServlet和FailServlet\n\n```java\n//SuccessServlet.java\n@WebServlet(\"/example/successServlet\")\npublic class SuccessServle extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        request.setCharacterEncoding(\"utf-8\");\n        response.setContentType(\"text/html;charset=utf-8\");\n        User user = (User) request.getAttribute(\"user\");\n        response.getWriter().write(user.getUser()+\"登录成功\");\n    }\n}\n//----------------------------------------------\n\n//FailServlet.java\n@WebServlet(\"/example/failServlet\")\npublic class FailServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        request.setCharacterEncoding(\"utf-8\");\n        response.setContentType(\"text/html;charset=utf-8\");\n        response.getWriter().write(\"登录失败\");\n    }\n}\n```\n\n### BeanUtils工具类\n\nJavaBean：标准的Java类\n\nJavaBean要求\n\n* 类必须被public修饰\n* 必须提供空参的构造方法\n* 成员变量必须使用private修饰\n* 提供公共的getter和setter方法\n* 一般在项目中放在domain或者entity下\n\n功能：简化数据封装\n\n概念\n\n* 成员变量\n* 属性：setter和getter方法截取后的产物，比方说getUser()，对应的属性就是user\n\n{% asset_img 10.png 成员变量跟属性的区别 %}\n\n方法\n\n* setProperty()\n* getProperty()\n* populate()\n\n> 我个人的理解，其实属性跟成员变量是一回事。只不过有的库在封装（比如BeanUtils）的时候，需要拆分出方法的设置或获取的属性，由此产生属性这个概念。\n>\n> 其实，从这个角度来想，好多东西，都是人规定的，因为你整的东西好，用的人多了，自然而然也就成了规定。就像js，php，这种叫做弱类型语言，底层可能还是通过基本数据类型来实现，但是我也可以说，他没有数据类型，因为在用的时候，根本不需要去定义数据类型。\n\n```java\npublic class BeanUtilsTest {\n    @Test\n    public void test() throws InvocationTargetException, IllegalAccessException, NoSuchMethodException {\n        User user = new User();\n        BeanUtils.setProperty(user,\"user\",\"胡列娜\");\n        String user1 = BeanUtils.getProperty(user, \"user\");\n        System.out.println(user+\"--\"+user1);// User{id=0, user='胡列娜', password='null'}--胡列娜\n    }\n}\n```\n\n### 优化\n\n登录功能只有两条数据需要封装成User对象。获取数据，创建对象，赋值，6步完成。如果是一个很多条数据，要获取十几次数据，赋值十几次，岂不是很麻烦。这就需要优化一下了。\n\n一次能获取所有数据，一次赋完所有值。可以通过下载BeanUtils来完成数据的封装\n\n优化后的代码\n\n```java\n@WebServlet(\"/example/loginServlet\")\npublic class LoginServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //设置编码\n        request.setCharacterEncoding(\"utf-8\");\n//        //获取请求参数\n//        String user = request.getParameter(\"user\");\n//        String password = request.getParameter(\"password\");\n//        //封装User对象\n//        User loginUser = new User();\n//        loginUser.setUser(user);\n//        loginUser.setPassword(password);\n\n        //改用BeanUtils优化\n        //获取所有请求参数\n        Map<String, String[]> parameterMap = request.getParameterMap();\n        //创建对象\n        User loginUser = new User();\n        //使用BeanUtils封装\n        try {\n            BeanUtils.populate(loginUser,parameterMap);\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            e.printStackTrace();\n        }\n        //调用UserDao的登录方法\n        User login = new UserDao().login(loginUser);\n        //判断是否登录成功\n        if(login!=null){\n            request.setAttribute(\"user\",login);\n            request.getRequestDispatcher(\"/example/successServlet\").forward(request,response);\n        }else{\n            request.getRequestDispatcher(\"/example/failServlet\").forward(request,response);\n        }\n\n    }\n}\n```\n\n# 六、Response\n\n## 6.1 Response功能\n\n设置响应消息\n\n* 设置响应行\n  * 设置状态码：setStatus(int sc)\n* 设置响应头：setHeader(String name,String value)\n* 设置响应体\n  * 获取输出流 \n    * 字符输出流：PrintWriter getWriter();\n    * 字节输出流：ServletOutputStream getOutputStream()\n  * 使用输出流，将输出流输出到客户端\n\n## 6.2 重定向\n\n重定向：资源跳转的方式\n\n```java\n@WebServlet(\"/demo01Response\")\npublic class Demo01Response extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        System.out.println(\"demo01Response...\");\n        //访问 /demo01Response会自动跳转/demo02Response\n//        //1.设置状态码为302\n//        response.setStatus(302);\n//        //2.设置响应头location\n//        response.setHeader(\"location\",\"/demo02Response\");\n\n        //因为重定向的步骤是一样的，所以java提供了简化版\n        System.out.println(response.getClass().getName());\n        response.sendRedirect(\"/demo02Response\");\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n}\n```\n\n转发的特点（forward）\n\n1. 浏览器地址栏路径没有发生变化\n2. 只能转发到当前的服务器内部中\n3. 转发是一次请求，可以使用request来共享数据\n\n重定向的特点(redirect)\n\n1. 地址栏发生变化\n2. 可以访问其他站点资源\n3. 重定向是两次请求，不能使用request来共享数据\n\n## 6.3 路径\n\n分类\n\n1. 相对路径：通过相对路径，不可以确定唯一资源\n   * 如./index.html（当前路径下的index.html，./是可以省略的），../index.html（上一级的index.html，上上级之类的以此类推）\n   * 不以/开头，以.开头路径；./表示当前路径，当然，这个是可以省略的。\n   * 规则：要使用相对路径，要确定当前的资源和目标资源之间的相对位置关系\n2. 绝对路径：通过绝对路径，可以确定唯一的资源\n   * 如https://meethigher.top/blog/2020/blogs、/blog/2020/blogs\n   * 完整地址或者以/开头都是绝对路径\n\n规则：判断定义的路径是给谁用的\n\n* 给客户端浏览器使用：需要加虚拟目录（项目的访问路径），比方说重定向\n* 给服务器使用：不需要加虚拟目录，比方说请求转发\n\n在实际项目中，虚拟目录的路径不能写死，可以通过`request.getContextPath()`动态获取虚拟目录\n\n{% asset_img 11.png 动态获取虚拟目录 %}\n\n## 6.4 服务器输出数据到客户端\n\n获取流对象\n\n* 获取字符输出流：PrintWriter getWriter()\n* 获取字节输出流：ServletOutputStream getOutputStream()\n\n### 字符输出流\n\n步骤\n\n1. 获取字符输出流\n2. 输出数据\n\n> 注意：乱码问题，客户端的默认编码，与服务端返回消息体的编码不一致\n>\n> response.getWriter()获取的流的默认编码是ISO-8859-1，我们需要设置该流的默认编码\n>\n> response获取的流，不需要刷新和关闭。因为response在一次响应结束之后，自动销毁\n\n```java\n@WebServlet(\"/demo03Response\")\npublic class Demo03Response extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //response获取的流，不需要刷新和关闭。因为response在一次响应结束之后，自动销毁\n        //获取流对象之前，设置流的默认编码，但是如果客户端的机器有的是u8，有的是国标，还是会乱码\n//        response.setCharacterEncoding(\"utf-8\");\n        //设置消息体数据的编码，建议浏览器使用该编码。不区分大写\n//        response.setHeader(\"content-type\",\"text/html;charset=utf-8\");\n        //当然，javaEE也给提供了更简便的方法\n        response.setContentType(\"text/html;charset=utf-8\");\n\n        //1.获取字符输出流\n        PrintWriter pw = response.getWriter();\n        //2.输出数据\n        pw.write(\"Hello Response\");\n        pw.write(\"胡列娜 我女神\");\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n}\n```\n\n### 字节输出流\n\n步骤\n\n1. 获取字节输出流：response.getOutputStream()\n2. 输出数据\n\n```java\n@WebServlet(\"/demo04Response\")\npublic class Demo04Response extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=utf-8\");\n        //1.获取字节输出流\n        ServletOutputStream os = response.getOutputStream();\n        //2.输出数据\n        os.write(\"胡列娜 我女神\".getBytes(\"utf-8\"));\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n}\n```\n\n## 6.5 案例-验证码\n\n本质：图片\n\n目的：防止表单恶意注册\n\n[关于Graphics的常用方法](https://blog.csdn.net/weixin_42950079/article/details/83389220)\n\n```java\n@WebServlet(\"/checkCodeServlet\")\npublic class CheckCodeServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        int width=500;\n        int height=300;\n        //1.创建对象，在内存中画图（验证码图片对象）\n        BufferedImage image=new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);\n        //2.美化图片\n        //2.1填充背景色\n        Graphics g=image.getGraphics();//绘图对象\n        g.setColor(Color.PINK);\n        g.fillRect(0,0,width,height);\n        //2.2画边框\n        g.setColor(Color.RED);\n        g.drawRect(0,0,width-1,height-1);\n        System.out.println(\"奥利给\");\n        //2.3写验证码\n        String str=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz\";\n        Random r=new Random();\n        for (int i = 0; i < 4; i++) {\n            g.drawString(str.charAt(r.nextInt(str.length()))+\"\",width/5*(i+1),height/2);\n        }\n        //2.4 画干扰线\n        g.setColor(Color.green);\n        for (int i = 0; i < 10; i++) {\n            int x1=r.nextInt(width);\n            int y1=r.nextInt(height);\n            int x2=r.nextInt(width);\n            int y2=r.nextInt(height);\n            g.drawLine(x1,y1,x2,y2);\n        }\n        //3.将图片输出到页面展示\n        ImageIO.write(image,\"jpg\",response.getOutputStream());\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request,response);\n    }\n}\n```\n\n通过html对齐进行访问以及单击修改\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<img src=\"/checkCodeServlet\">\n<a href=\"javascript:void(0)\">看不清换一张</a>\n<script>\n    let $img=document.querySelector(\"img\");\n    $img.onclick = function () {\n        let url = \"/checkCodeServlet\";\n        let date=new Date().getTime();\n        this.setAttribute(\"src\", url+\"?\"+date)\n    };\n    document.querySelector(\"a\").onclick=()=>{\n        let url = \"/checkCodeServlet\";\n        let date=new Date().getTime();\n        $img.setAttribute(\"src\", url+\"?\"+date)\n    }\n</script>\n</body>\n</html>\n```\n\n# 七、ServletContext对象\n\n概念：代表整个web应用，可以和程序的容器（服务器）来通信 \n\n获取\n\n1. 通过request获取：request.getServletContext()\n2. 通过HttpServlet获取：getServletContext\n\n> 其实通过这两个方式获取的都是同一个对象。因为本身HttpServletRequest就是HttpServlet的子类，调用的就是其父类的方法\n\n功能\n\n1. 获取MIME类型\n   * MIME类型：在互联网通信过程中定义的一种文件数据类型\n   * 格式：大类型/小类型 如：htm或者html对应text/html、jpg对应image/jpeg\n   * 获取：String getMimeType(String filename)\n2. 域对象：共享数据\n   * setAttribute(String name,Object value)\n   * getAttribute(String name)\n   * removeAttribute(String name)\n3. 获取文件的真实路径（服务器完整路径）\n   * String getRealPath(String path)\n\n## 7.1 获取MIME类型\n\n具体的MIME的相关的映射，都在tomcat的web.xml里面配置着。Tomcat的web.xml相当于是所有集成到ide的web.xml的父类。\n\n```java\n@WebServlet(\"/demo02ServletContext\")\npublic class Demo02ServletContext extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        ServletContext servletContext = getServletContext();\n        //定义文件名称\n        String name=\"a.jpg\";\n        //获取MIME类型\n        String mimeType = servletContext.getMimeType(name);\n        System.out.println(mimeType);//image/jpeg\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n}\n```\n\n{% asset_img 12.png %}\n\n## 7.2 域对象\n\nServletContext对象范围：所有用户所有请求的数据（范围最大的）\n\n在一个servlet设置属性\n\n```java\n@WebServlet(\"/demo03ServletContext\")\npublic class Demo03ServletContext extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        ServletContext servletContext = getServletContext();\n        //设置数据\n        servletContext.setAttribute(\"fairy\",\"胡列娜\");\n\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n}\n```\n\n在另外的servlet访问属性\n\n```java\n@WebServlet(\"/demo04ServletContext\")\npublic class Demo04ServletContext extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        ServletContext servletContext = getServletContext();\n        //获取数据\n        Object fairy = servletContext.getAttribute(\"fairy\");\n        System.out.println(fairy.toString());//胡列娜\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n}\n```\n\n> 一般用这个，也比较谨慎，所有用户都是可以共享和操作的。而且，生命周期也非常长，服务器启动，它就创建了，服务器关闭，才会销毁。驻留在内存的时间非常久，造成的内存的压力会很大。\n\n## 7.3 获取文件真实路径（服务器完整路径）\n\n* 获取web目录下文件\n* 获取WEB-INF目录下文件\n* 获取src目录下文件\n\n```java\n@WebServlet(\"/demo05ServletContext\")\npublic class Demo05ServletContext extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        ServletContext servletContext = getServletContext();\n        String realPath = servletContext.getRealPath(\"/example/login.html\");//获取web下文件\n        System.out.println(realPath);//E:\\Develop\\JavaDev\\JavaEE\\out\\artifacts\\JavaEE_war_exploded\\example\\login.html\n        String realPath1 = servletContext.getRealPath(\"/WEB-INF/web.xml\");//获取WEB-INF目录下文件\n        System.out.println(realPath1);\n        //如果是直接放在src根目录下的，需要去/WEB-INF/classes/下找\n        String realPath2 = servletContext.getRealPath(\"/WEB-INF/classes/a.html\");//获取src目录下文件\n        System.out.println(realPath2);\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n}\n```\n\n# 八、文件下载与上传案例\n\n## 8.1 文件下载\n\n需求\n\n1. 页面显示超链接\n2. 点击超链接后弹出下载框\n3. 完成图片文件下载\n\n> HTML中超链接指向的资源如果能够被浏览器解析，则在浏览器中展示；若不能解析，就会进行下载到本地。当然，我们也可以通过添加download属性，直接让它所有的都下载。但是这个是没有提示框的。\n>\n> 我们可以使用响应头设置资源打开的方式\n>\n> content-disposition:attachment;filename=xxx这个表示已附件的形式打开，文件名为xxx\n\n步骤\n\n1. 定义页面\n2. 定义Servlet\n   * 获取文件名称\n   * 用字节输入流加载进内存\n   * 设置响应头为附件形式打开\n   * 将内存写出到响应输出流\n\n> 中文名称的文件下载时会乱码，改成utf-8的即可，垃圾ie浏览器已经没救了，兼容不了\n\n```java\n@WebServlet(\"/downloadServlet\")\npublic class DownloadServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        request.setCharacterEncoding(\"utf-8\");\n        //1.获取请求参数，文件名称\n        String filename = request.getParameter(\"filename\");\n        //2.使用字节输入流加载文件进内存\n        //2.1找到文件服务器路径\n        ServletContext sc = getServletContext();\n        String realPath = sc.getRealPath(\"/壁纸5.jpg\");\n        //2.2用字节流关联\n        FileInputStream fis = new FileInputStream(realPath);\n        //3设置response响应头\n        //3.1设置响应格式\n        String mimeType = sc.getMimeType(filename);\n//        response.setHeader(\"content-type\",mimeType);\n        response.setContentType(mimeType);\n        //3.2设置响应头打开格式\n        //解决中文文件名问题，垃圾ie，去他妈的吧，兼容不了\n        filename= URLEncoder.encode(filename,\"utf-8\");\n        response.setHeader(\"content-disposition\",\"attachment;filename=\"+filename);\n        //4.将输入流数据写出到输出流中\n        ServletOutputStream sos = response.getOutputStream();\n        byte[] bytes = new byte[1024 * 8];\n        int len=0;\n        while((len=fis.read(bytes))!=-1){\n            sos.write(bytes,0,len);\n        }\n        //5.释放资源\n        fis.close();\n\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n}\n```\n\nhtml中的代码\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<a href=\"downloadServlet?filename=壁纸5.jpg\">图片下载</a>\n</body>\n</html>\n```\n\n## 8.2 文件上传\n\n我一开始以为文件上传跟文件下载一样，获取请求的传过来的数据，然后写。\n\n但是，一直写出数据都是0kb，我就很纳闷了，我的代码是没有问题的。想了一会，搞明白了，request获取的输入流，是获取到的请求体的数据，而不是获取上传文件的内容\n\n","tags":["java","web"]},{"title":"浅谈static关键字","url":"/blog/2019/static/","content":"\n有关static的一系列注意点\n\n<!--more-->\n\n### 浅谈static关键字\n\n如果一个**成员变量**使用了static关键字，则该成员变量不再属于对象自己，而是**属于类**。\n\n如果一个**成员方法**使用了static关键字，则该成员方法不再属于对象自己，而是**属于类**。\n\n如果没有static关键字，则必须创建对象，然后才能通过对象使用它。\n\n如果有了static关键字，则不需要创建对象，直接就能通过**类名称**来访问\n\n无论是成员变量，还是成员方法，**如果有了static，都推荐使用类名称来调用**\n\n静态变量：类名称.静态变量\n\n静态方法：类名称.静态方法()\n\n```\npackage demo03;\n\nclass MyClass {\n\tString name;\n\tstatic int age;\n\tpublic void method() {\n\t\tSystem.out.println(\"这是一个成员方法\");\n\t}\n\tpublic static void methodStatic() {\n\t\tSystem.out.println(\"这是一个静态方法\");\n\t\t//System.out.println(name);//报错，静态方法中不能访问非静态变量\n\t\tSystem.out.println(age);//静态方法中可以访问静态变量\n\t}\n}\npublic class Demo03StaticMethod {\n\n\t/*\n\t * 一旦使用了static修饰成员方法，那么这就成为了静态方法。静态方法不属于对象，而是属于类 \n\t * 如果没有static关键字，那么必须创建对象，然后才能通过对象使用他\n\t * 如果有了static关键字，那么不需要创建对象，直接就能通过类名称来访问他\n\t * \n\t * 无论是成员变量，还是成员方法，如果有了static,都推荐使用类名称进行调用\n\t * 静态变量：类名称.静态变量\n\t * 静态方法：类名称.静态方法()\n\t * \n\t * \n\t *注意事项：\n\t *1.静态不能直接访问非静态\n\t *原因：因为在内存当中是`先`有静态的内容，`后`有非静态的内容\n\t *\"先人不知道后人，但是后人知道先人\"\n\t *2.静态方法中不能使用this\n\t *原因：this代表当前对象，通过谁调用的方法，谁就是当前的对象\n\t * \n\t * \n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tMyClass obj=new MyClass();\n\t\tobj.method();\n\t\t\n\t\t//对于本类当中的静态方法，前面的类名称可以省略\n\t\t//test.haha();//如果没有使用static关键字，则会报错\n\t\thaha1();\n\t\tDemo03StaticMethod.haha1();//这两个是完全等效\n\t\t\n\t\t//对于静态方法来书，可以通过对象名进行调用，也可以直接通过类名进行调用\n\t\tobj.methodStatic();//正确，不推荐。这种方法在编译之后也会被javac翻译成\"类名称.静态方法名\"\n\t\tMyClass.methodStatic();//正确，推荐\n\t}\n\tpublic void haha() {\n\t\tSystem.out.println(\"haha\");\n\t}\n\tpublic static void haha1() {\n\t\tSystem.out.println(\"haha1\");\n\t}\n\n}\n\n```\n\n\n\n> 注意事项:\n>\n\n* 静态不能直接访问非静态。\n  * 原因：因为在内存当中是`先`有静态的内容，`后`有非静态的内容\n  * `先人不知道后人，但是后人知道先人`\n* 静态方法中不能使用this\n  * 原因：this 代表当前对象，通过谁调用的方法，谁就是当前的对象\n\n### 浅谈静态代码块\n\n静态代码块：\n\npublic class 类名称 {\n\n​\t\tstatic {\n\n​               // 静态代码块的内容\n\n​        }\n\n}\n\n特点：当第一次用到本类时，静态代码执行唯一的一次\n\n静态内容总是优先于非静态，所以静态代码块比构造方法先执行\n\n\n\n静态代码块的典型用途：\n\n用来一次性地对静态成员变量进行赋值\n\n```\npackage demo03;\n\n/*\n静态代码块：\npublic class 类名称 {\n  static {\n     // 静态代码块的内容\n  }\n}\n特点：当第一次用到本类时，静态代码执行唯一的一次\n静态内容总是优先于非静态，所以静态代码块比构造方法先执行\n\n静态代码块的典型用途：\n用来一次性地对静态成员变量进行赋值\n */\nclass Student {\n\n\tpublic Student() {\n\t\tSystem.out.println(\"构造函数执行\");\n\t}\n\tstatic {\n\t\tSystem.out.println(\"静态代码执行唯一一次\");\n\t}\n}\npublic class Demo03Static {\n\tpublic static void main(String[] args) {\n\t\tStudent s=new Student();\n\t\tStudent s1=new Student();\n\t\t\n\t\t//经过上述测试，静态代码块，只执行一次\n\t}\n\t\n}\n\n```\n\n","tags":["java"]},{"title":"古人的话一定对吗","url":"/blog/2019/study-and-life/","content":"\n关于一些古人流传下来的`至理名言`的思考\n\n<!--more-->\n\n今天是周六，是可以睡懒觉的一天。早上7点半才起的，洗漱半个小时，已经8点了。\n\n周末一楼食堂关门比较早，早餐在7点半左右，就没啥好吃的了。\n\n所以就打算直接去学习，还可以省一顿饭钱。\n\n进了自习室，开始背英语作文，并且默写了一遍。之后开始做数学题，此时已经9点了，一种饥饿感涌上心头。到了10点，饥饿感让我越来越心焦，最后干脆不学习了，在那里玩手机，但是手机玩起来也心烦。\n\n因为我——太饿了！\n\n由此突然想到了，原来高中学到的那些古文。\n\n> 子曰:\"女奚不曰:其为人也，发愤忘食，乐以忘忧，不知老之将至云尔。\" \n\n>  北齐·颜之推《颜氏家训·勉学》:\"元帝在江荆间，复所爱习，召置学生，亲为教授，废寝忘食，以夜继朝。\" \n\n像什么发愤忘食，废寝忘食，当时高中老师拿来教育我们，\"你们就应该像伟人学习，不把难题钻研出来，不能吃饭！\"。 \n\n当时还觉得挺有道理，但是现在，越来越觉得，这些东西太虚了，净他妈扯淡！\n\n不吃饱喝足睡好，哪有心思去学习，去钻研。哲学家天天坐着思考我是谁，还得吃饭呢。\n\n就我平时的状态，每次写代码，折腾到午夜12点后，都是小事，第二天起床，发现昨晚熬夜几个小时实现的那些逻辑，现在写，顶多只要半小时。熬夜时，感觉自己做了好多东西，但是效率真的低。\n\n学习也一样，吃饱了睡好了，我可以连着嗑一上午数学题，不带看手机的。但是吃不饱就不一样，学一会，想一会别的事情，效率不是一般的低。\n\n那些`废寝忘食`的伟人，我不知道你为世界省了多少粮食，但是我敢肯定的是，如果你按时吃饭，按时睡觉的话，所得到的成就肯定远超现在。\n\n但是古人说的话，对于一些特定的事情，还是有道理的，就比方说：\n\n> 酒足饭饱思淫欲\n\n有些人做的某些事，不过是吃饱了撑的罢了\n\n> 个人总结：\n>\n> 不吃饱，不学习；不睡好，不学习\n\n","tags":["life"]},{"title":"Stream流式思想","url":"/blog/2020/streaming-thought/","content":"\n说到Stream便容易想到I/O Stream，而实际上，谁规定“流”就一定是“IO流”呢？\n\n在Java 8中，得益于Lambda所带来的函数式编程，引入了一个全新的Stream概念，用于解决已有集合类库既有的弊端。  \n\n<!--more-->\n\n## 1 引言\n\n### 传统集合的多步遍历代码\n\n几乎所有的集合（如 Collection接口或 Map接口等）都支持直接或间接的遍历操作。而当我们需要对集合中的元素进行操作的时候，除了必需的添加、删除、获取外，最典型的就是集合遍历。例如：  \n\n```java\npublic class Demo01ForEach {\n\tpublic static void main(String[] args) {\n\t\tArrayList<String> list=new ArrayList<String>();\n\t\tlist.add(\"小舞\");\n\t\tlist.add(\"胡列娜\");\n\t\tlist.add(\"江厌离\");\n\t\tfor(String s:list) {\n\t\t\tSystem.out.println(s);\n\t\t}\n\t}\n}\n```\n\n这是一段非常简单的集合遍历操作：对集合中的每一个字符串都进行打印输出操作。 \n\n### 循环遍历的弊端\n\nJava 8的Lambda让我们可以更加专注于做什么（What），而不是怎么做（How），这点此前已经结合内部类进行 了对比说明。现在，我们仔细体会一下上例代码，可以发现：\n\n* for循环的语法就是“怎么做” \n\n* for循环的循环体才是“做什么” \n\n为什么使用循环？因为要进行遍历。但循环是遍历的唯一方式吗？遍历是指每一个元素逐一进行处理，而并不是从 第一个到最后一个顺次处理的循环。前者是目的，后者是方式。\n\n试想一下，如果希望对集合中的元素进行筛选过滤：\n\n1.  将集合A根据条件一过滤为子集B； \n\n2. 然后再根据条件二过滤为子集C。 \n\n那怎么办？在Java 8之前的做法可能为： \n\n```java\npublic class Demo01ForEach {\n\tpublic static void main(String[] args) {\n\t\tArrayList<String> list=new ArrayList<String>();\n\t\tlist.add(\"小舞\");\n\t\tlist.add(\"胡列娜\");\n\t\tlist.add(\"江厌离\");\n\t\tlist.add(\"江澄\");\n\t\tlist.add(\"江枫眠\");\n\t\t\n\t\t//对list中的元素进行过滤，将以江开头的元素，存储到一个新的集合中\n\t\tArrayList<String> listJiang=new ArrayList<String>();\n\t\tfor(String s:list) {\n\t\t\tif(s.startsWith(\"江\"))\n\t\t\t\tlistJiang.add(s);\n\t\t}\n\t\t\n\t\t//对listJiang中元素进行过滤，将长度为3的，存储到新的集合中\n\t\tArrayList<String> list3=new ArrayList<String>();\n\t\tfor(String s:listJiang) {\n\t\t\tif(s.length()==3)\n\t\t\t\tlist3.add(s);\n\t\t}\n\t\t\n\t\t//遍历list3\n\t\tfor(String s:list3) {\n\t\t\tSystem.out.println(s);\n\t\t}\t\t\n\t}\n}\n```\n\n这段代码中含有三个循环，每一个作用不同： \n\n1. 首先筛选所有姓江的人； \n\n2. 然后筛选名字有三个字的人； \n\n3. 最后进行对结果进行打印输出。 \n\n每当我们需要对集合中的元素进行操作的时候，总是需要进行循环、循环、再循环。这是理所当然的么？不是。循 环是做事情的方式，而不是目的。另一方面，使用线性循环就意味着只能遍历一次。如果希望再次遍历，只能再使 用另一个循环从头开始。\n\n那，Lambda的衍生物Stream能给我们带来怎样更加优雅的写法呢？\n\n### Stream的更优写法\n\n```java\npublic class Demo02Stream {\n\tpublic static void main(String[] args) {\n\t\tArrayList<String> list = new ArrayList<String>();\n\t\tlist.add(\"小舞\");\n\t\tlist.add(\"胡列娜\");\n\t\tlist.add(\"江厌离\");\n\t\tlist.add(\"江澄\");\n\t\tlist.add(\"江枫眠\");\n\n\t\t// 对list中的元素进行过滤，将以江开头的元素，存储到一个新的集合中\n\t\t// 对listJiang中元素进行过滤，将长度为3的，存储到新的集合中\n\t\t// 遍历list3\n\t\tlist.stream().filter(new Predicate<String>() {\n\n\t\t\t@Override\n\t\t\tpublic boolean test(String s) {\n\t\t\t\treturn s.startsWith(\"江\");\n\t\t\t}\n\t\t}).filter(new Predicate<String>() {\n\n\t\t\t@Override\n\t\t\tpublic boolean test(String s) {\n\t\t\t\treturn s.length() == 3;\n\t\t\t}\n\t\t}).forEach(new Consumer<String>() {\n\n\t\t\t@Override\n\t\t\tpublic void accept(String t) {\n\t\t\t\tSystem.out.println(t);\n\n\t\t\t}\n\t\t});\n\n\t\t// 升级为Lambda写法，优雅不？艺术不？\n\t\tlist.stream()\n\t\t.filter(s -> s.startsWith(\"江\"))\n\t\t.filter(s -> s.length() == 3)\n\t\t.forEach(s -> System.out.println(s));\n\t}\n}\n\n```\n\n直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：获取流、过滤出姓江、过滤出长度为3、逐一打印。代码中并没有体现使用线性循环或是其他任何算法进行遍历，我们真正要做的事情内容被更好地体现在代码中。 \n\n## 2 流式思想概述\n\n**注意：请暂时忘记对传统IO流的固有印象！** \n\n整体来看，流式思想类似于工厂车间的“生产流水线”。 \n\n当需要对多个元素进行操作（特别是多步操作）的时候，考虑到性能及便利性，我们应该首先拼好一个“模型”步骤 方案，然后再按照方案去执行它。 \n\n{% asset_img screaming-thought.png 流式思想 %}\n\n这张图中展示了过滤、映射、跳过、计数等多步操作，这是一种集合元素的处理方案，而方案就是一种“函数模型”。图中的每一个方框都是一个“流”，调用指定的方法，可以从一个流模型转换为另一个流模型。而最右侧的数字3是最终结果。 \n\n这里的 filter 、 map 、 skip 都是在对函数模型进行操作，集合元素并没有真正被处理。\n\n只有当终结方法 count 执行的时候，整个模型才会按照指定策略执行操作。而这得益于Lambda的延迟执行特性。 \n\n> 备注：**Stream流**其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何 元素（或其地址值）。 \n\nStream（流）是一个来自数据源的元素队列，\n\n* 元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。 \n\n* **数据源** 流的来源。 可以是集合，数组等。\n\n和以前的Collection操作不同， Stream操作还有两个基础的特征：\n\n* **Pipelining：** 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。\n\n* **内部迭代：** 以前对集合遍历都是通过Iterator或者增强for的方式, 显式的在集合外部进行迭代， 这叫做外部迭 代。 Stream提供了内部迭代的方式，流可以直接调用遍历方法。 \n\n当使用一个流的时候，**通常包括三个基本步骤：获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象**（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道。  \n\n## 3 获取流\n\n`java.util.stream.Stream` 是`Java 8`新加入的最常用的流接口（这并不是一个函数式接口） \n\n获取一个流非常简单，有以下几种常用的方式： \n\n* 所有的 `Collection` 集合都可以通过 `stream` 默认方法获取流； \n* `Stream` 接口的静态方法 `of` 可以获取数组对应的流。 \n\n### 根据Collection获取流 \n\n首先， `java.util.Collection` 接口中加入了`default`方法 `stream` 用来获取流，所以其所有实现类均可获取流。 \n\n```java\n//把集合List转换为Stream\nList<String> list=new ArrayList<String>();\nStream<String> stream1=list.stream();\n\t\t\nSet<String> set=new HashSet<String>();\nStream<String> stream2=set.stream();\n```\n\n### 根据Map获取流\n\n `java.util.Map` 接口不是 `Collection` 的子接口，且其K-V数据结构不符合流元素的单一特征，所以获取对应的流 需要分key（键）、value（值）或entry（键与值的映射关系）等情况：  \n\n```java\nMap<String,String> map=new HashMap<String, String>();\n//获取键，存储到Set集合中\nSet<String> keyset=map.keySet();\nStream<String> stream3=keyset.stream();\n\t\t\n//或者获取值，存到Collection中，然后再通过Collection集合中的stream默认方法获取流\nStream<String> stream4=map.values().stream();\n\t\t\n//或者获取键与值的映射关系 entrySet\nSet<Map.Entry<String, String>> entries=map.entrySet();\nStream<Map.Entry<String, String>> stream5=entries.stream();\n```\n\n### 根据数组获取流\n\n 如果使用的不是集合或映射而是数组，由于数组对象不可能添加默认方法，所以 Stream 接口中提供了静态方法 of ，使用很简单：  \n\n```java\n//把数组转换为Stream\nStream<Integer> stram6=Stream.of(1,2,3,4,5);\n//可变参数可以传递数组\nInteger[] arr= {\n\t1,2,3,4,5\n};\nStream<Integer> stream7=Stream.of(arr);\n```\n\n>  备注： of 方法的参数其实是一个可变参数，所以支持数组 \n\n## 4 常用方法\n\n{% asset_img common-methods.png 常用方法 %}\n\n流模型的操作很丰富，这里介绍一些常用的API。这些方法可以被分成两种：\n\n* 延迟方法：返回值类型仍然是 Stream 接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方 法均为延迟方法。） \n* 终结方法：返回值类型不再是 Stream 接口自身类型的方法，因此不再支持类似 StringBuilder 那样的链式调用。本小节中，终结方法包括 count 和 forEach 方法。 \n\n> 流的特点：Stream流属于管道流，只能被消费（使用）一次。第一个Stream流调用完毕方法，数据就会流转到下一个Stream流， 而这时第一个Stream流已经使用完毕，就会关闭了。所以第一个Stream流就不能再调用方法了。\n\n### 逐一处理：forEach\n\n虽然方法名字叫 `forEach` ，但是与for循环中的“for-each”昵称不同。\n\n```java\nvoid forEach(Consumer<? super T> action);\n```\n\n 该方法接收一个 `Consumer` 接口函数，会将每一个流元素交给该函数进行处理。 \n\n**复习Consumer接口**\n\n```java\njava.util.function.Consumer<T>接口是一个消费型接口。\n//Consumer接口中包含抽象方法void accept(T t)，意为消费一个指定泛型的数据。\n```\n\n**基本使用：** \n\n```java\npublic class Demo04StreamForEach {\n\tpublic static void main(String[] args) {\n\t\t//获取一个Stream流\n\t\tStream<String> stream=Stream.of(\"小舞\",\"朱竹清\",\"水冰儿\",\"胡列娜\",\"邱若水\");\n\t\t//使用Stream中的forEach方法，对Stream流中的数据进行遍历\n//\t\tstream.forEach(new Consumer<String>() {\n//\n//\t\t\t@Override\n//\t\t\tpublic void accept(String t) {\n//\t\t\t\tSystem.out.println(t);\n//\t\t\t\t\n//\t\t\t}\n//\t\t});\n\t\t\n\t\t//改用Lambda优化\n\t\tstream.forEach(name->System.out.println(name));\n\t}\n}\n```\n\n### 过滤：filter\n\n可以通过 `filter` 方法将一个流转换成另一个子集流。方法签名：\n\n```java\nStream<T> filter(Predicate<? super T> predicate);\n```\n\n该接口接收一个 `Predicate` 函数式接口参数（可以是一个`Lambda`或方法引用）作为筛选条件。 \n\n{% asset_img filter.png filter %}\n\n**复习Predicate接口** \n\n此前我们已经学习过 `java.util.stream.Predicate` 函数式接口，其中唯一的抽象方法为： \n\n```java\nboolean test(T t);\n```\n\n该方法将会产生一个boolean值结果，代表指定的条件是否满足。如果结果为true，那么`Stream流`的 `filter` 方法 将会留用元素；如果结果为false，那么 `filter` 方法将会舍弃元素。 \n\n**基本使用** \n\nStream流中的 filter 方法基本使用的代码如： \n\n```java\npublic class Demo05StreamFilter {\n\tpublic static void main(String[] args) {\n\t\t//创建一个Stream流\n\t\tStream<String> stream=Stream.of(\"朱竹清\",\"宁荣荣\",\"江厌离\",\"胡列娜\",\"火舞\",\"水冰儿\",\"邱若水\",\"水月儿\");\n\t\t\n\t\t//对Stream流中的元素进行过滤，只要姓水的人\n//\t\tstream.filter(new Predicate<String>() {\n//\n//\t\t\t@Override\n//\t\t\tpublic boolean test(String t) {\n//\t\t\t\t// TODO Auto-generated method stub\n//\t\t\t\treturn t.startsWith(\"水\");\n//\t\t\t}\n//\t\t}).forEach(name->System.out.println(name));\n\t\t\n\t\t//Lambda优化\n\t\tstream.filter(t->t.startsWith(\"水\")).forEach(name->System.out.println(name));\n\t}\n}\n```\n\n在这里通过Lambda表达式来指定了筛选的条件：必须姓水。  \n\n### 映射：map\n\n如果需要将流中的元素映射到另一个流中，可以使用 `map` 方法。方法签名：\n\n```java\n<R> Stream<R> map(Function<? super T, ? extends R> mapper);\n```\n\n该接口需要一个 `Function` 函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。 \n\n{% asset_img map.png map %}\n\n**复习Function接口** \n\n此前我们已经学习过 `java.util.stream.Function` 函数式接口，其中唯一的抽象方法为： \n\n```java\nR apply(T t);\n```\n\n这可以将一种T类型转换成为R类型，而这种转换的动作，就称为**映射**。 \n\n**基本使用** \n\nStream流中的 map 方法基本使用的代码如： \n\n```java\npublic class Demo06StreamMap {\n\tpublic static void main(String[] args) {\n\t\tStream<String> stream=Stream.of(\"1\",\"2\",\"3\",\"4\");\n\t\t//使用map方法，将字符串类型的整数，转换（映射）为Integer类型的整数\n//\t\tstream.map(new Function<String, Integer>() {\n//\n//\t\t\t@Override\n//\t\t\tpublic Integer apply(String t) {\n//\t\t\t\t// TODO Auto-generated method stub\n//\t\t\t\treturn Integer.parseInt(t);\n//\t\t\t}\n//\t\t}).forEach(num->System.out.println(num));\n\t\t\n\t\t//优化\n\t\tstream.map(t->Integer.parseInt(t)).forEach(num->System.out.println(num));\n\t}\n}\n```\n\n这段代码中， map 方法的参数通过方法引用，将字符串类型转换成为了int类型（并自动装箱为 Integer 类对 象）。 \n\n### 统计个数：count\n\n 正如旧集合 `Collection` 当中的 `size` 方法一样，流提供 `count` 方法来数一数其中的元素个数： \n\n```java\nlong count();\n```\n\n该方法返回一个long值代表元素个数（不再像旧集合那样是int值）。基本使用： \n\n```java\npublic class Demo07StreamCount {\n\tpublic static void main(String[] args) {\n\t\tArrayList<Integer> list=new ArrayList<Integer>();\n\t\tlist.add(1);\n\t\tlist.add(2);\n\t\tlist.add(2);\n\t\tlist.add(2);\n\t\tlist.add(2);\n\t\tlist.add(2);\n\t\tlist.add(2);\n\t\tStream<Integer> stream=list.stream();\n\t\tlong count=stream.count();\n\t\tSystem.out.println(count);\n\t}\n}\n```\n\n### 取用前几个：limit\n\n `limit` 方法可以对流进行截取，只取用前n个。方法签名： \n\n```java\nStream<T> limit(long maxSize);\n```\n\n参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。基本使用： \n\n```java\npublic class Demo08StreamLimit {\n\tpublic static void main(String[] args) {\n\t\tString[] girls= {\n\t\t\t\t\"胡列娜\",\"江厌离\",\"邱若水\",\"朱竹清\",\"宁荣荣\",\"火舞\",\"水冰儿\",\"水月儿\"\n\t\t};\n\t\tStream<String> stream=Stream.of(girls);\n\t\t\n\t\t//使用limit对Stream流中的元素进行截取，只要前三个元素\n\t\tStream<String> stream2=stream.limit(3);\n\t\tstream2.forEach(name->System.out.println(name));\n\t}\n}\n```\n\n> limit方法是一个延迟方法，跟filter、map一样，只是对流中的元素进行截取，返回的是一个新流，所以可以继续调用Stream\n\n### 跳过前几个：skip\n\n如果希望跳过前几个元素，可以使用 `skip` 方法获取一个截取之后的新流： \n\n```java\nStream<T> skip(long n);\n```\n\n如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。基本使用：\n\n{% asset_img skip.png skip %} \n\n```java\npublic class Demo09StreamSkip {\n\tpublic static void main(String[] args) {\n\t\tString[] girls= {\n\t\t\t\t\"胡列娜\",\"江厌离\",\"邱若水\",\"朱竹清\",\"宁荣荣\",\"火舞\",\"水冰儿\",\"水月儿\"\n\t\t};\n\t\tStream<String> stream=Stream.of(girls);\n\t\t\n\t\t//使用skip方法跳过前3个元素\n\t\tstream.skip(3).forEach(name->System.out.println(name));\n\t}\n}\n```\n\n### 组合：concat\n\n如果有两个流，希望合并成为一个流，那么可以使用 Stream 接口的静态方法 concat ： \n\n```java\nstatic <T> Stream<T> concat(Stream<? extends T> a, Stream<? extends T> b)\n```\n\n> 备注：这是一个静态方法，与 java.lang.String 当中的 concat 方法是不同的。\n\n 该方法的基本使用代码如：  \n\n```java\npublic class Demo10StreamConcat {\n\tpublic static void main(String[] args) {\n\t\tStream<String> boys=Stream.of(\"唐三\",\"戴沐白\",\"魏无羡\");\n\t\tStream<String> girls=Stream.of(\"胡列娜\",\"水冰儿\",\"江厌离\");\n\t\tStream<String> stream=Stream.concat(boys, girls);\n\t\tstream.forEach(name->System.out.println(name));\n\t}\n}\n```\n\n## 5 练习：集合元素处理（传统方式）\n\n**题目** \n\n现在有两个 ArrayList 集合存储队伍当中的多个成员姓名，要求使用传统的for循环（或增强for循环）依次进行以 下若干操作步骤： \n\n1. 第一个队伍只要名字小于3个字的成员姓名；存储到一个新集合中。 \n2. 第一个队伍筛选之后只要前3个人；存储到一个新集合中。 \n3. 第二个队伍包含水字的成员姓名；存储到一个新集合中。 \n4. 第二个队伍筛选之后不要前2个人；存储到一个新集合中。 \n5. 将两个队伍合并为一个队伍；存储到一个新集合中。 \n6. 根据姓名创建 Person 对象；存储到一个新集合中。 \n7. 打印整个队伍的Person对象信息。 \n\n**代码**\n\n```java\nclass Person {\n\tprivate String name;\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic Person(String name) {\n\t\tsuper();\n\t\tthis.name = name;\n\t}\n\n\tpublic Person() {\n\t\tsuper();\n\t\t// TODO Auto-generated constructor stub\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\t// TODO Auto-generated method stub\n\t\treturn \"Person{name='\"+name+\"' }\";\n\t}\n\t\n\t\n\t\n}\npublic class Demo11Practice {\n\tpublic static void main(String[] args) {\n\t\tArrayList<String> men=new ArrayList<String>();\n\t\tmen.add(\"唐三\");\n\t\tmen.add(\"邪月\");\n\t\tmen.add(\"焱\");\n\t\tmen.add(\"江澄\");\n\t\tmen.add(\"江枫眠\");\n\t\t\n\t\t//存储名字长度小于3\n\t\tArrayList<String> men1=new ArrayList<String>();\n\t\tfor(String s:men) {\n\t\t\tif(s.length()<3) {\n\t\t\t\tmen1.add(s);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//存储前三个\n\t\tArrayList<String> men2=new ArrayList<String>();\n\t\tfor(int i=0;i<3;i++) {\n\t\t\tmen2.add(men1.get(i));\n\t\t}\n\t\t\n\t\t\n\t\tArrayList<String> women=new ArrayList<String>();\n\t\twomen.add(\"胡列娜\");\n\t\twomen.add(\"水冰儿\");\n\t\twomen.add(\"火舞\");\n\t\twomen.add(\"水月儿\");\n\t\twomen.add(\"邱若水\");\n\t\t\n\t\t\n\t\t//存储包含水的\n\t\tArrayList<String> women1=new ArrayList<String>();\n\t\tfor(String s:women) {\n\t\t\tif(s.contains(\"水\"))\n\t\t\t\twomen1.add(s);\n\t\t}\n\t\t//存储除前两个以外的\n\t\tArrayList<String> women2=new ArrayList<String>();\n\t\tfor(int i=2;i<women1.size();i++) {\n\t\t\twomen2.add(women1.get(i));\n\t\t}\n\t\t\n\t\t//添加两个集合\n\t\tArrayList<String> all=new ArrayList<String>();\n\t\tall.addAll(men2);\n\t\tall.addAll(women2);\n\t\t\n\t\t\n\t\t//根据姓名创建Person对象，存储到集合中\n\t\tArrayList<Person> people=new ArrayList<Person>();\n\t\tfor(String s:all) {\n\t\t\tpeople.add(new Person(s));\n\t\t}\n\t\t\n\t\t//打印Person集合信息\n\t\tfor(Person p:people) {\n\t\t\tSystem.out.println(p);\n\t\t}\n\t\t\n\t}\n}\n```\n\n看看，这代码写得，麻烦不？代码的艺术呢？我们做了这一系列工作，只是为了最后遍历一下结果而已，循环只是方式，而不是我们的目的。所以，直接采用Stream方式会更加方便\n\n## 6 练习：集合元素处理（Stream方式）\n\n**题目**\n\n把上一题当中的传统for循环改为Stream流式处理方式，两个集合的初值保持不变，Person类的定义也不变\n\n**代码**\n\n```java\npublic class Demo12Practice {\n\tpublic static void main(String[] args) {\n\t\tArrayList<String> men = new ArrayList<String>();\n\t\tmen.add(\"唐三\");\n\t\tmen.add(\"邪月\");\n\t\tmen.add(\"焱\");\n\t\tmen.add(\"江澄\");\n\t\tmen.add(\"江枫眠\");\n\n\t\tArrayList<String> women = new ArrayList<String>();\n\t\twomen.add(\"胡列娜\");\n\t\twomen.add(\"水冰儿\");\n\t\twomen.add(\"火舞\");\n\t\twomen.add(\"水月儿\");\n\t\twomen.add(\"邱若水\");\n\n\t\t// 对men,存储名字长度小于3且前3个\n\t\tStream<String> men1=men.stream().filter(name->name.length()<3).limit(3);\n\t\t// 对women,存储名字包含水且不包含前2个\n\t\tStream<String> women1=women.stream().filter(name->name.contains(\"水\")).skip(2);\n\t\t\n\t\t//连接两个，并转存为Person类型，然后遍历\n\t\tStream.concat(men1, women1).map(name->new Person(name)).forEach(person->System.out.println(person));\n\t}\n}\n```\n\n","tags":["java"]},{"title":"数据库学习笔记","url":"/blog/2020/sql/","content":"\n老师给自己讲蒙了，满肚子的疑问，也懒得跟老师交流。让我直接把网课打上了静音。我还不如自己学。\n\n<!--more-->\n\n以下是个人牢骚。\n\n有个场景，很可笑。\n\n某上课场景\n\n学生：老师，我的xx按你说的运行不了啊。\n\n老师：你安装得不对，卸载了重新安。\n\n> 其实是学生安装的是最新版，老师非要让学生下载老古董。更气人的是，某些老古董，都已经找不到完整的原程序了。\n\n某面试场景\n\n面试官：你用过什么数据库？\n\n面试者：我们老师教过小海豚标志的数据库，我用得很熟练。\n\n> 教我们的某个老师，自己就搞不懂，mysql是啥，sqlyog又是啥。教的时候，就把sqlyog当做mysql来操作了。\n>\n> mysql是数据库，可以通过命令行来操作；sqlyog是数据库的界面可视化工具\n\n大部分老师，是不懂得更新自己知识的，毕竟职业已经是铁饭碗，谁还去想，教的东西有没有用，学生到底学到了什么？\n\n好老师有吗？当然有。一些刚入职教师行业的老师，还很理想化。就拿我某个老师来说，他一直说，教书育人是件很神圣的事，上课也要有仪式感。我们也都觉得这个老师好，但是他自己呢？工资低、同时也没有副业。还有的老师，兢兢业业备课，认认真真教书。就连期末学生给他送钱，求个及格，老师都拒绝了。过得清廉，然而他也只是个老师而已。\n\n某些老师，教学混日子，上课出去抽根烟，出去撒泡尿，半节课就过去了。但是他自己有很多职称，有很多副业，有很多关系，有很多专利。你即使去问问题，他也不鸟你。学生确实没学到东西，但是他自己钱包赚得满满的。\n\n当然，还有些老师，教学认真教，各种关系处得也很好，自己手头也有很多项目。这种老师要看自己机缘了。\n\n本文以MySQL8.0+为例，仅做入门参考。具体内容，参照[MySQL官方文档](https://dev.mysql.com/doc/refman/8.0/en/preface.html)。\n\n\n# 一、数据库概念\n\n英文：DataBase 简称DB\n\n概念：用于存储和管理数据的仓库\n\n数据库的特点：\n\n1. 持久化存储数据。本质是一个文件系统\n2. 方便存储和管理数据\n3. 使用了统一的方式（SQL）操作数据库\n\n常见的数据库：\n\n全球数据库排名[DB-Engines Ranking](https://db-engines.com/en/ranking)\n\n{% asset_img 1.png 2020年数据库排名 %}\n\n* Oracle：收费的，大型关系数据库，Oracle公司的产品。Oracle收购Sun公司，收购MySQL\n* MySQL：开源免费的数据库，小型关系数据库。被Oracle收购之后，开始收费\n  * 免费： 免费版本的具有开源协议，在免费版本上进行的任何修改所发布的软件，也必须是开源的（开源牛逼！） \n  * 收费： 如果你想将修改后的软件出售获利，就必须得购买收费版本才可以 。 此外，收费版本卖的不是软件，而是服务，当数据出现问题的时候，购买的服务可以帮助处理发生问题的数据。\n* SQLServer：MicroSoft公司收费的中型关系型数据库。C#，.Net等语言常使用。\n* DB2：IBM公司的大型关系数据库产品，收费的。常用在银行系统中\n* SQLite：嵌入式的小型关系型数据库，内置到软件或系统中去，比方说浏览器。应用在Android手机端\n* SyBase：已经淡出历史舞台。提供了一个非常专业的数据建模工具[PowerDesigner](http://powerdesigner.de/)\n\n# 二、SQL概念\n\nSQL：结构化查询语言（Structured Query Language ），其实就是定义了操作**所有关系型数据库**的规则。每一种数据库操作的方式存在不一样的地方，就类似于“方言”。\n\nSQL通用语法：\n\n1. SQL语句可以单行或者多行书写，以分号结尾\n2. 使用空格和缩进来提高语句可读性\n3. SQL语句不区分大小写，关键字建议使用大写\n4. 注释\n   * 单行注释：-- 注释内容 或者 **# 注释内容（MySQL特有）**\n   * 多行注释：/* 注释 */\n\n```sql\n-- 单行注释\n# 单行注释，MySQL特有\n/* 注释 */\n```\n\nSQL分类：\n\n1.  [DDL](#4-1-DDL：操作数据库、表)(Data Definition Language)数据定义语言。用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 \n2.  [DML](#4-2-DML：增删改表中数据)(Data Manipulation Language)数据操作语言。用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 \n3.  [DQL](#4-3-DQL：查询表中记录)(Data Query Language)数据查询语言。用来查询数据库中表的记录(数据)。关键字：select, where 等 \n4.  [DCL](#4-4-DCL：管理用户与权限)(Data Control Language)数据控制语言。用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 \n\n{% asset_img 2.png 描述 %}\n\n# 三、MySQL使用\n\n数据库可视化操作工具：\n\n1. [Navicat Premium](https://www.navicat.com.cn/download/navicat-premium)（目前为止，感觉最好用的一款）\n2. [SQLyog](https://sqlyog.en.softonic.com/download)（最新版的界面依旧是上古风格，不过还是挺好用的，推荐）\n3. [DBeaver](https://dbeaver.io/download/)（别人推荐，我还没用过）\n\n题外话，讲讲使用技巧\n\n[Navicat生成ER关系图并导出](https://blog.csdn.net/xu1227233860/article/details/78278393)\n\n{% asset_img 15.png %}\n\n[SQLyog生成关系图](https://blog.csdn.net/whdxkcx/article/details/78271845)\n\n{% asset_img 16.png %}\n\nNavicat查看sql语句\n\n{% asset_img 19.png %}\n\nSQLyod查看sql语句\n\n{% asset_img 20.png %}\n\nMySQL下载：[地址](https://dev.mysql.com/downloads/mysql/)\n\n推荐解压版，拒绝傻瓜式。身为开发者，动手能力必须要强。我某同学，至今还以为mysql是个软件。我曾经给人安装了解压版，然后人家跟我说，这不是mysql，有海豚标志的才是mysql（可视化工具sqlyog的图标）。我就回了一句，哦，我还不太会安，你找别人吧。\n\n常用命令行（进入到mysql的bin目录下）：\n\n* mysql -u 用户名 -p 用户名 或mysql -u 用户名 -p; - - 连接数据库\n\n* show databases; - - 展示全部数据库\n* create database name; - - 创建name数据库\n* use name; - - 使用name数据库\n* show tables; - - 展示其中的表\n* create table name (id int,name varchar(20),age int); - - 创建name表，其中有3列，int型id列，varchar型长度为20的name列，int型age列\n* desc name; - - 查看name表的结构\n* source sql.sql; - - 执行本地的sql.sql文件\n* drop table name; - - 删除name表\n* drop database name; - - 删除name数据库\n* exit或quit; - - 退出数据库终端\n\n{% asset_img 3.png mysql操作 %}\n\nwindows下用命令行操作，是件极爽的事情，最进下载了一套数学视频，文件名都被打了小广告，cmd一键批处理，爽地不要不要的\n\n本来想着写一篇cmd命令学习笔记，但奈何内容太庞大了，等哪天有足够的时间，来系统学习的话，我会写一篇的。\n\n# 四、SQL操作\n\n以下例子都是基于MySQL\n\n## 4.1 DDL：操作数据库、表\n\n### 操作数据库：CRUD\n\n也就是所谓的增删改查\n\n1. C(Create)：创建\n   创建beauty数据库，判断是否存在，并设置字符集为UTF-8：create database if not exists beauty character set utf8;\n\n2. R(Retrieve)：读取\n   查询所有数据库：show databases;\n\n3. U(Update)：更新\n\n   查看数据库的字符集：show create database beauty;\n   修改数据库的字符集：alter database beauty character set gbk;\n\n4. D(Delete)：删除\n   删除数据库：drop database if exists beauty; \n\n5. 使用数据库：use beauty;\n\n查看当前使用的数据库：select database();\n\n### 操作表：CRUD\n\n1. C(Create)：创建\n   语法：create table 表名 (列名1 数据类型1,列名2 数据类型2,...,列名n 数据类型n);\n\n   创建表：create table girls(id int,name varchar(20),score double(4,1),birthday date,insert_time timestamp);\n\n   复制表：create table 表名 like 被复制的表名;\n\n2. R(Retrieve)：读取\n   查询所有表：show tables;\n   查询表结构：desc 表名\n\n3. U(Update)：更新\n   修改表名：alter table 表名 rename to 新表名;\n   查看表的字符集：show create table 表名;\n   修改表的字符集：alter table 表名 character set utf8;\n   添加一列：alter table 表名 add 列名 数据类型;\n   修改列的类型：alter table 表名 modify 列名 新类型;\n   修改列名称 类型： alter table 表名 change 列名 新列名 新类型;\n   删除列：alter table 表名 drop 列名;\n\n4. D(Delete)：删除\n   删除表：drop table if exists 表名;\n\n> 数据类型的注意点：\n>\n> double(4,1)表示总长度为4的数，其中小数有1位\n>\n> date表示日期，只包含年月日，yyyy/MM/dd。我在开发starry的时候，发现在ios的safari中，只识别yyyy/MM/dd，而不识别yyyy-MM-dd，使用的时候注意。\n>\n> datetime表示日期，包含年月日时分秒，yyyy/MM/dd HH:mm:ss\n>\n> timestamp表示时间戳，包含年月日时分秒，yyyy/MM/dd HH:mm:ss。有种说法，“如果将来不给这个字段赋值，或者赋值为null，则默认使用系统当前时间，来自动赋值。”，经测验无效。\n\n## 4.2 DML：增删改表中数据\n\n### 添加数据\n\n语法：insert into 表名(列名1,列名2,...,列名n) values(值1,值2,...,值n);\n\n```sql\nINSERT INTO fairy(id,NAME,score) VALUES(1,'胡列娜',80.1);\n```\n\n注意：\n\n1. 列名和值，要一一对应。\n2. 如果表名后，不定义列名，则默认给所有列添加值。insert into 表名 values(值1,值2,...,值n);\n3. 除了数字类型，其他类型都需要使用引号（单双引号都可以）引起来\n\n### 删除数据\n\n语法：delete from 表名 where 条件;\n\n```sql\nDELETE FROM fairy WHERE NAME='水冰儿';\n```\n\n注意：\n\n1. 如果不加条件，则会删除表中所有记录。\n2. 如果要删除所有记录。\n   * delete from 表名; 不推荐使用，有多少条记录，就会执行多少次删除操作。效率比较低。\n   * truncate table 表名; 推荐使用，先删除表，然后再创建一张一模一样的表。效率比较高。\n\n### 修改数据\n\n语法：update 表名 set 列名1=值1,列名2=值2,...,列名n=值n where 条件;\n\n```sql\nUPDATE fairy SET NAME='水月儿' WHERE id=2;\n```\n\n注意：\n\n1. 如果不加任何条件，则会将表中所有记录全部修改\n\n## 4.3 DQL：查询表中记录\n\n导入数据：\n\n```sql\nUSE `beauty`;\n\n/*Table structure for table `fairy` */\n\nDROP TABLE IF EXISTS `fairy`;\n\nCREATE TABLE `fairy` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(20) NOT NULL,\n  `gender` varchar(2) NOT NULL,\n  `age` int(11) NOT NULL,\n  `grade` int(11) NOT NULL,\n  `school` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,\n  `position` varchar(20) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;\n\n/*Data for the table `fairy` */\n\ninsert  into `fairy`(`id`,`name`,`gender`,`age`,`grade`,`school`,`position`) values (1,'胡列娜','女',22,52,'武魂殿学院','武魂殿'),(2,'邱若水','女',18,37,'天水学院','天斗帝国'),(3,'水冰儿','女',17,43,'天水学院','天斗帝国'),(4,'水月儿','女',17,36,'天水学院','天斗帝国'),(5,'邪月','男',22,53,'武魂殿学院','武魂殿'),(6,'唐三','男',16,44,'史莱克','天斗帝国'),(7,'戴沐白','男',21,48,'史莱克学院','天斗帝国'),(8,'胡列娜','女',22,52,'武魂殿学院','武魂殿');\n```\n\n语法：select  字段列表 from 表名列表 where 条件列表 group by 分组字段 having 分组之后的条件限定 order by  排序规则 limit 分页限定\n\n### 基础查询\n\n1. 多个字段的查询\n   select 字段名1,字段名2,... from 表名;\n   如果查询所有字段，可以使用 * 来替代字段列表\n2. 去除重复\n   DISTINCE关键字\n3. 计算列\n   一般可以使用四则运算，来计算列的值\n   IFNULL(表达式1,表达式2) 表达式1是指需要判断为NULL的字段，表达式2是指NULL的替换值。\n4. 起别名\n   AS关键字，也可以省略\n\n```sql\n-- 多个字段查询\nSELECT NAME,school FROM fairy;\n\n-- 去除重复\nSELECT DISTINCT school FROM fairy;\nSELECT DISTINCT NAME,school FROM fairy;\n\n-- 计算age跟grade之和\nSELECT NAME,age,grade,age+grade FROM fairy;\n-- 如果有NULL参与运算，将NULL换位0\nSELECT NAME,age,grade,IFNULL(age,0)+IFNULL(grade,0) AS '年龄+等级' FROM fairy;\n```\n\n### 条件查询\n\n1. where子句后跟条件\n\n2. 运算符\n\n\n| 运算符                   | 含义                                                         |\n| ------------------------ | ------------------------------------------------------------ |\n| \\>、<、<=、>=、=、<>     | <>在 SQL 中表示不等于，在 mysql 中也可以使用!=，没有==这个运算符 |\n| BETWEEN...AND...         | 在一个范围之内，如：between 100 and 200 相当于条件在 100 到 200 之间，包头又包尾 |\n| IN(集合)                 | 集合表示多个值，使用逗号分隔                                 |\n| LIKE '张%' 或 LIKE '张_' | 模糊查询。%指多个占位符，_指单个占位符                       |\n| IS NULL 或 IS NOT NULL   | 查询某一列为 NULL 的值，注：不能写=NULL                      |\n| AND 或 &&                | 与，SQL 中建议使用前者，后者并不通用。                       |\n| OR 或 \\|\\|               | 或                                                           |\n| NOT 或 !                 | 非                                                           |\n\n代码\n\n```sql\n-- 查询年龄大于等于20岁的\nSELECT NAME,age FROM fairy WHERE age>=20;\n\n-- 查询年龄等于22岁的\nSELECT NAME,age FROM fairy WHERE age=22;\n\n-- 查询年龄不等于22岁的\nSELECT NAME,age FROM fairy WHERE age!=22;\nSELECT NAME,age FROM fairy WHERE age<>22;\n\n-- 查询年龄大于等于18岁，小于等于22岁\nSELECT NAME,age FROM fairy WHERE age>=18 AND age<=22;\nSELECT NAME,age FROM fairy WHERE age>=18 && age<=22;\nSELECT NAME,age FROM fairy WHERE age BETWEEN 18 AND 22;\n\n-- 查询所有22岁，18岁，性别为女的人\nSELECT * FROM fairy WHERE age=22 OR age=18;\nSELECT * FROM fairy WHERE age IN (22,18);\n\n-- 查询等级不为NULL的人\nSELECT * FROM fairy WHERE grade IS NOT NULL;\n\n-- 查询姓水的人\nSELECT * FROM fairy WHERE NAME LIKE '水%';\n\n-- 查询姓名中含有水字的人\nSELECT * FROM fairy WHERE NAME LIKE '%水%';\n```\n\n### 排序查询\n\n语法：order by  排序字段1 排序方式1,....;\n\n排序方式：\n\n1. ASC：升序排。默认值\n2. DESC：降序排。\n\n注意：\n\n1. 如果有多个排序条件，则当前面的值一样时，才会去判断第二条件\n\n代码：\n\n```sql\n-- 按age升序排\nSELECT * FROM fairy ORDER BY age;\n\n-- 按age降序排\nSELECT * FROM fairy ORDER BY age DESC;\n\n-- 按照年龄排序，如果年龄一样，则按照等级排序\nSELECT * FROM fairy ORDER BY age ASC,grade ASC;\n```\n\n### 聚合函数\n\n将一列数据作为一个整体，进行纵向计算。\n\n1. count：计算个数\n   一般选择非空的列：主键\n   可以通过count(*)，但实际开发中，少用这个\n2. max：计算最大值\n3. min：计算最小值\n4. sum：计算和\n5. avg：计算平均值\n\n注意：聚合函数的计算，排除NULL值\n\n解决方案：\n\n1. 选择不包含非空的列进行计算\n2. IFNULL(grade,0)\n\n代码：\n\n```sql\n-- 显示总数\nSELECT COUNT(NAME) FROM fairy;\n\n-- 如果grade为NULL的时候，聚合函数就不会统计，可以这样处理\nSELECT COUNT(IFNULL(grade,0)) FROM fairy;\n\n-- 获取最大值与最小值\nSELECT MAX(age) FROM fairy;\nSELECT MIN(age) FROM fairy;\n\n-- 获取等级之和\nSELECT SUM(grade) FROM fairy;\n\n-- 获取平均等级\nSELECT AVG(grade) FROM fairy;\n```\n\n### 分组函数\n\n语法：group by 分组字段；\n\n注意：\n\n1. 分组之后查询的字段：分组字段或者聚合函数；\n2. where和having的区别？\n   * where在分组之前进行限定，如果不满足条件，则不参与分组；having在分组之后进行限定，如果不满足条件，不会被查询出来\n   * where后跟不可跟聚合函数；having可以进行聚合函数的判断\n\n```sql\n-- 按照性别分组，求总人数，并且求不同组的平均等级\nSELECT \n  gender,\n  AVG(grade) '平均等级',\n  COUNT(NAME) '人数' \nFROM\n  fairy \nGROUP BY gender ;\n\n-- 按照性别分组，求总人数，并且求不同组的平均等级。\n-- 要求：等级低于44的，不参与分组\nSELECT \n  gender,\n  AVG(grade) '平均等级',\n  COUNT(NAME) '人数' \nFROM\n  fairy \nWHERE grade >= 44 \nGROUP BY gender ;\n\n-- 按照性别分组，求总人数，并且求不同组的平均等级。\n-- 要求：等级低于44的，不参与分组。分组之后，人数要大于2人\nSELECT \n  gender,\n  AVG(grade) '平均等级',\n  COUNT(NAME) '人数' \nFROM\n  fairy \nWHERE grade >= 44 \nGROUP BY gender \nHAVING COUNT(NAME) > 2 ;\n\nSELECT \n  gender,\n  AVG(grade) '平均等级',\n  COUNT(NAME) '人数' \nFROM\n  fairy \nWHERE grade >= 44 \nGROUP BY gender \nHAVING 人数 > 2 ;\n```\n\n### 分页查询\n\n语法：limit 开始的索引，每页查询的条数;\n\n公式：开始的索引=(当前的页码-1)x每页显示的条数\n\n注意：limit是MySQL的一个“方言”。不同的数据库分页操作是不同的\n\n```sql\n-- 从第1条数据开始，显示3条\nSELECT * FROM fairy LIMIT 0,3;\n\n-- 从第4条数据开始，显示3条\nSELECT * FROM fairy LIMIT 3,3;\n```\n\n### 多表查询\n\n笛卡尔积：A、B两个集合，取这两个集合的所有组成情况。要完成多表查询，要消除无用的数据。\n\n#### 内连接\n\n使用内连接的要求：\n\n1. 从哪些表中查询数据\n2. 条件是啥\n3. 查询哪些字段\n\n**隐式内连接**\n\n语法：*select 字段列表 from 表名列表 where ...;*\n\n```sql\n-- 查询两张表所有数据\nSELECT \n  * \nFROM\n  memeber,\n  position1 \nWHERE memeber.`p_id` = position1.`id` ;\n\n-- 查询第一张表的name,grade和第二张表的school,position\nSELECT \n  NAME,\n  grade,\n  school,\n  POSITION\nFROM\n  memeber,\n  position1 \nWHERE memeber.`p_id` = position1.`id` ;\n\n-- 用表的别名进行优化，先将表命名为别名，再来写select后的别名.xx\nSELECT \n  t1.`name`,\n  t1.`grade`,\n  t2.`school`,\n  t2.`position` \nFROM\n  memeber t1,\n  position1 t2 \nWHERE t1.`p_id` = t2.`id` ;\n```\n\n**显式内连接**\n\n语法：*select 字段列表 from 表1 [inner] join 表2 on 条件;*\n\n> []这个符号表示可以省略的意思\n\n```sql\n-- 查询两张表所有数据\nSELECT \n  * \nFROM\n  memeber \n  JOIN position1 \n    ON memeber.`p_id` = position1.`id` ;\n\n-- 查询第一张表的name,grade和第二张表的school,position\nSELECT \n  NAME,\n  grade,\n  school,\n  POSITION\nFROM\n  memeber \n  JOIN position1 \n    ON memeber.`p_id` = position1.`id` ;\n\n-- 用表的别名进行优化。注意写法，先将表命名为别名，再来写select后的别名.xx\nSELECT \n  t1.name,\n  t1.`grade`,\n  t2.`school`,\n  t2.`position` \nFROM\n  memeber t1 \n  JOIN position1 t2 \n    ON t1.`p_id` = t2.`id` ;\n```\n\n#### 外连接\n\n**左外连接**\n\n语法：*select 字段列表 from 表1 left [outer] join 表2 on  条件;*\n\n```sql\n-- 查询所有人信息，如果有位置，则查询位置信息；如果没有位置，则不显示\nSELECT \n  t1.*,\n  t2.school \nFROM\n  memeber t1,\n  position1 t2 \nWHERE t1.`p_id` = t2.`id` ;\n\n-- 此时，如果有数据的外键是空的，就不会查出来了\n-- 为解决这个问题，我们需要用到外连接\nSELECT \n  t1.*,\n  t2.school \nFROM\n  memeber t1 \n  LEFT JOIN position1 t2 \n    ON t1.`p_id` = t2.`id` ;\n```\n\n> 左外连接：\n>\n> 查询的是左边表的所有数据，以及连接表的交集部分\n\n**右外连接**\n\n语法：*select 字段列表 from 表1 right [outer] join 表2 on 条件;*\n\n```sql\n-- 右外连接，跟上面左外连接的结果一样，写法的区别就是表的顺序，左换右，右换左了\nSELECT \n  t1.*,\n  t2.school \nFROM\n  position1 t2 \n  RIGHT JOIN memeber t1 \n    ON t1.`p_id` = t2.`id` ;\n```\n\n> 右外连接：\n>\n> 查询的是右边表的所有数据，以及连接表的交集部分\n\n### 子查询\n\n概念：查询中嵌套查询，称嵌套的这个查询，为子查询\n\n```sql\n-- 查询等级最高的人\n-- 1.查询最高等级\nSELECT \n  MAX(grade) \nFROM\n  memeber ;\n\n-- 2.查询等级等于最高的人\nSELECT \n  * \nFROM\n  memeber \nWHERE grade = 54 ;\n\n-- 使用子查询\nSELECT \n  * \nFROM\n  memeber \nWHERE grade = \n  (SELECT \n    MAX(grade) \n  FROM\n    memeber) ;\n```\n\n子查询的不同情况\n\n1. 子查询的结果是单行单列的\n   子查询可以作为条件，使用运算符去判断。>,>=, <, <=, =\n2. 子查询的结果是多行单列的\n   子查询可以作为条件，使用运算符in来判断\n3. 子查询的结果是多行多列的\n   子查询可以作为一张虚拟表参与查询\n\n```sql\n-- 子查询结果是单行单列的\n-- 查询等级最高的人\nSELECT \n  * \nFROM\n  memeber \nWHERE grade = \n  (SELECT \n    MAX(grade) \n  FROM\n    memeber) ;\n\n-- 子查询结果是多行单列的\n-- 查询武魂殿和天斗帝国的所有成员信息\nSELECT \n  * \nFROM\n  memeber \nWHERE p_id IN \n  (SELECT \n    id \n  FROM\n    position1 \n  WHERE POSITION= \"武魂殿\" \n    OR POSITION= \"天斗帝国\") ;\n\n-- 子查询结果是多行多列的\n-- 查询成员年龄为18以上的成员信息跟位置信息\nSELECT \n  * \nFROM\n  position1 t1,\n  (SELECT \n    * \n  FROM\n    memeber \n  WHERE age > 18) t2 \nWHERE t1.`id` = t2.p_id ;\n\n-- 可以使用普通内连接，会更好理解\nSELECT \n  * \nFROM\n  memeber t1,\n  position1 t2 \nWHERE t1.`p_id` = t2.`id` \n  AND t1.`age` > 18 ;\n```\n\n### 练习\n\n数据库的架构如图\n\n{% asset_img 13.png 架构 %}\n\n```sql\n-- 需求：\n-- 1.查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述\nSELECT \n  t1.id,\n  ename,\n  salary,\n  jname,\n  description \nFROM\n  emp t1,\n  job t2 \nWHERE t1.`job_id` = t2.`id` ;\n\n-- 2.查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置\nSELECT \n  t1.id,\n  ename,\n  salary,\n  jname,\n  description,\n  dname,\n  loc \nFROM\n  emp t1,\n  job t2,\n  dept t3 \nWHERE t1.`job_id` = t2.`id` \n  AND t1.`dept_id` = t3.`id` ;\n\n \n-- 3.查询员工姓名，工资，工资等级\nSELECT \n  t1.`ename`,\n  t1.`salary`,\n  t2.`grade` \nFROM\n  emp t1,\n  salarygrade t2 \nWHERE t1.`salary` BETWEEN t2.`losalary` \n  AND t2.`hisalary` ;\n\n-- 4.查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级\nSELECT \n  t1.`ename`,\n  t1.`salary`,\n  t2.`jname`,\n  t2.`description`,\n  t3.`dname`,\n  t3.`loc`,\n  t4.`grade` \nFROM\n  emp t1,\n  job t2,\n  dept t3,\n  salarygrade t4 \nWHERE t1.`dept_id` = t3.`id` \n  AND t2.`id` = t1.`job_id` \n  AND t1.`salary` BETWEEN t4.`losalary` \n  AND t4.`hisalary` ;\n\n-- 5.查询出部门编号、部门名称、部门位置、部门人数\nSELECT \n  t1.`id`,\n  t1.`dname`,\n  t1.`loc`,\n  t2.`总人数` \nFROM\n  dept t1,\n  (SELECT \n    dept_id,\n    COUNT(id) 总人数 \n  FROM\n    emp \n  GROUP BY emp.`dept_id`) t2 \nWHERE t1.`id` = t2.dept_id ;\n\n-- 6.查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询\nSELECT \n  t1.`id`,\n  t1.`ename`,\n  t2.ename \nFROM\n  emp t1 \n  LEFT JOIN \n    (SELECT \n      id,ename \n    FROM\n      emp) t2 \n    ON t1.`mgr` = t2.id ;\n```\n\n## 4.4 DCL：管理用户与权限\n\n### 管理用户\n\n查询用户\n\nSELECT * FROM USER;\n注意：通配符%表示可以在任意主机使用用户登录\n\n{% asset_img 14.png 通配符 %}\n\n```sql\n-- 查询用户\n-- 1.切换到MySQL数据库\nUSE mysql;\n-- 2.查询user表\nSELECT * FROM USER;\n-- 通配符%表示可以在任意主机使用用户登录\n```\n\n添加用户\n\ncreate user '用户名'@'主机名' identified by '密码';\n\n```sql\n-- 创建用户\ncreate user '用户名'@'主机名' identified by '密码';\ncreate user 'huliena'@'localhost' identified by '123456';\n```\n\n删除用户\n\nDROP USER '用户名'@'主机名';\n\n```sql\n-- 删除用户\nDROP USER '用户名'@'主机名';\nDROP USER 'huliena'@'localhost';\n```\n\n修改用户密码\n\n```sql\n-- 修改密码\n-- mysql5.7版本\nUPDATE USER SET PASSWORD=PASSWORD('新密码') WHERE USER='用户名';\nSET PASSWORD FOR 'huliena'@'localhost' ='123456';\n-- mysql8.0+版本\nALTER USER '用户名'@'主机名' IDENTIFIED BY '密码';\nALTER USER 'huliena'@'localhost' IDENTIFIED BY '654321';\n-- DCL特有的方式，高低版本都支持\nSET PASSWORD FOR '用户名'@'主机名'='密码';\n\n-- MySQL忘记了root用户的密码,管理员方式打开cmd\n-- 1.停止mysql服务\nnet STOP mysql\n-- 2.使用无验证方式启动mysql服务\nmysqld --skip-GRANT-TABLES;\n-- 3.另开一个窗口登录mysql,直接输入mysql即可\nmysql\n-- 4.修改密码后，关闭所有命令窗口，并去任务管理器里面关闭mysqld.exe\n-- 5.启动mysql服务\nnet START mysql\n```\n\n### 管理权限\n\n查询权限\n\n```sql\n-- 查询权限\nSHOW GRANTS FOR '用户名'@'主机名';\nSHOW GRANTS FOR 'huliena'@'localhost';\nSHOW GRANTS FOR 'root'@'localhost';\n```\n\n授予权限\n\n```sql\n-- 授予权限\nGRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名';\nGRANT SELECT,UPDATE,DELETE ON * TO 'huliena'@'localhost';\n-- 授予所有权限\nGRANT ALL ON *.* TO 'huliena'@'localhost';\n```\n\n撤销权限\n\n```sql\n-- 撤销权限\nrevoke 权限列表 on 数据库名.表名 from '用户名'@'主机名';\nrevoke all on *.* from 'huliena'@'localhost';\n```\n\n刷新权限\n\n```sql\n-- 刷新权限\nFLUSH PRIVILEGES;\n```\n\n## 4.5 约束\n\n概念：对表中的数据进行限定，从而保证数据的正确性、有效性和完整性\n\n约束：\n\n1. 主键约束：primary key\n2. 非空约束：not null\n3. 唯一约束：unique\n4. 外键约束：foreign key\n\n### 非空约束\n\nNOT NULL，值不能为NULL\n\n1. 创建表时，添加非空约束\n2. 已创建表，添加非空约束\n3. 删除非空约束\n\n代码：\n\n```sql\n-- 创建表时添加非空约束\ncreate table hero (\nid INT,\nNAME VARCHAR(20) NOT NULL\n);\n\ndesc hero;\n\n-- 删除name的非空约束\nalter table hero modify name varchar(20);\n\n-- 已经创建表后，添加约束\nalter table hero modify name varchar(20) not null;\n```\n\n### 唯一约束\n\nUNIQUE，值不能重复(但是允许存在多个NULL)\n\n1. 创建表时，添加唯一约束\n2. 已创建表，添加唯一约束\n3. 删除唯一约束\n\n代码：\n\n```sql\n-- 创建表时，添加唯一约束\nCREATE TABLE hero (\nid INT,\nphone_number VARCHAR(11) UNIQUE\n);\n-- 注意mysql中，唯一约束限定的列的值可以有多个NULL\n\n-- 删除唯一约束，index索引，唯一约束也叫做唯一索引\nALTER TABLE hero DROP INDEX phone_number;\n\n-- 在创建表之后，添加唯一约束\nALTER TABLE hero MODIFY phone_number VARCHAR(11) UNIQUE;\n\nDESC hero;\n```\n\n### 主键约束\n\n含义：表示非空且唯一\n\n一张表只能有一个字段表示主键。主键就是表中记录的唯一标识。\n\n主键约束：\n\n1. 创建表时，添加主键约束\n2. 已创建表，添加主键约束\n3. 删除主键约束\n\n代码\n\n```sql\n-- 创建表时，添加主键约束\nCREATE TABLE hero(\nid INT PRIMARY KEY,\nNAME VARCHAR(20)\n);\n\n-- 删除主键\nALTER TABLE hero DROP PRIMARY KEY;\n\n-- 已创建表，添加主键约束\nALTER TABLE hero MODIFY id INT PRIMARY KEY;\n\nDESC hero;\n```\n\n### 自动增长\n\n概念：如果某一列是数值类型的，使用auto_increment 可以完成自动增长\n\n自动增长：\n\n1. 创建表时，添加主键约束，并完成自动增长\n2. 已创建表，添加自动增长\n3. 删除自动增长\n\n```sql\n-- 创建表时，添加自动增长\nCREATE TABLE hero(\nid INT PRIMARY KEY AUTO_INCREMENT,\nNAME VARCHAR(20)\n);\n\n-- 删除自动增长\nALTER TABLE hero MODIFY id INT;\n\n-- 已创建表，添加自动增长\nALTER TABLE hero MODIFY id INT AUTO_INCREMENT;\n\nDESC hero;\n```\n\n> 注意：\n>\n> 自动增长是根据上一条数据的大小来增加的。比防说上一条是9，如果不传值，下一条就会是10\n\n### 外键约束\n\n一张表的数据，会过于冗余，我们可以将其进行拆分，然后再将两张表，通过外键关联起来。\n\n{% asset_img 4.png 外键 %}\n\n外键约束：\n\n1. 创建表时，添加外键约束\n\n   ```sql\n   create table 表名(\n       ....\n       外键列\n       constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)\n   );\n   ```\n\n2. 已创建表，添加外键约束\n\n3. 删除外键约束\n\n4. 级联操作(级联更新和级联删除)\n\n   ```sql\n   -- 添加级联操作\n   alter table 表名 add constraint 外键名称 foreign key (外键列名称) referencs 主表名称(主表列名称) on update cascade on delete cascade\n   \n   --也可以只添加其中某一个，也可以都添加，\n   --实现的功能，就是在删除外键表的内容的时候，主键表与其相关的内容也会一起被删掉\n   ```\n\n代码：\n\n```sql\n-- 创建表时，添加外键约束\nCREATE TABLE memeber1 (\n  id INT(11) NOT NULL PRIMARY KEY AUTO_INCREMENT,\n  NAME VARCHAR(20) NOT NULL,\n  gender VARCHAR(2) NOT NULL,\n  age INT(11) NOT NULL,\n  grade INT(11) NOT NULL,\n  p_id INT(11) NOT NULL,\n  CONSTRAINT m_p_fk FOREIGN KEY (p_id) REFERENCES position1(id)\n);\n\n-- 已创建表，添加外键约束\nALTER TABLE memeber1 ADD CONSTRAINT m_p_fk FOREIGN KEY (p_id) REFERENCES position1(id);\n\n-- 删除外键约束\nALTER TABLE memeber1 DROP FOREIGN KEY m_p_fk;\n\n-- 添加级联更新和级联删除\nALTER TABLE memeber ADD CONSTRAINT m_p_fk FOREIGN KEY (p_id) REFERENCES position1(id) ON UPDATE CASCADE ON DELETE CASCADE;\n\n```\n\n# 五、数据库的设计\n\n## 5.1 多表之间的关系\n\n### 分类\n\n* 一对一关系：如人和身份证号。一个人只有一个身份证号，一个身份证号对应一个人。开发中很少使用\n* 一对多（多对一）关系：如部门和员工。一个部门对应多个员工，一个员工对应一个部门。\n* 多对多关系： 如学生跟课程。一个课程对应多个学生，一个学生对应多个课程。\n\n这三种关系可以表示所有的事务之间的关系。\n\n实现关系\n\n* 一对一（一般情况合成一张表）\n  一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。 \n* 一对多（多对一）\n  在多的一方建立外键，指向一的一方的主键。\n* 多对多\n  多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键\n\n{% asset_img 5.png 数据库设计 %}\n\n### 案例\n\n{% asset_img 6.png 案例 %}\n\n代码\n\n```sql\n-- 创建旅游线路分类表 tab_category\n-- cid 旅游线路分类主键，自动增长\n-- cname 旅游线路分类名称非空，唯一，字符串 100\nCREATE TABLE tab_category (\n    cid INT PRIMARY KEY AUTO_INCREMENT,\n    cname VARCHAR(100) NOT NULL UNIQUE\n);\n-- 创建旅游线路表 tab_route\n/*\nrid 旅游线路主键，自动增长\nrname 旅游线路名称非空，唯一，字符串 100\nprice 价格\nrdate 上架时间，日期类型\ncid 外键，所属分类\n*/\nCREATE TABLE tab_route(\n    rid INT PRIMARY KEY AUTO_INCREMENT,\n    rname VARCHAR(100) NOT NULL UNIQUE,\n    price DOUBLE,\n    rdate DATE,\n    cid INT,\n    FOREIGN KEY (cid) REFERENCES tab_category(cid)\n);\n/*创建用户表 tab_user\nuid 用户主键，自增长\nusername 用户名长度 100，唯一，非空\npassword 密码长度 30，非空\nname 真实姓名长度 100\nbirthday 生日\nsex 性别，定长字符串 1\ntelephone 手机号，字符串 11\nemail 邮箱，字符串长度 100\n*/\nCREATE TABLE tab_user (\n    uid INT PRIMARY KEY AUTO_INCREMENT,\n    username VARCHAR(100) UNIQUE NOT NULL,\n    PASSWORD VARCHAR(30) NOT NULL,\n    NAME VARCHAR(100),\n    birthday DATE,\n    sex CHAR(1) DEFAULT '男',\n    telephone VARCHAR(11),\n    email VARCHAR(100)\n);\n/*\n创建收藏表 tab_favorite\nrid 旅游线路 id，外键\ndate 收藏时间\nuid 用户 id，外键\nrid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次\n*/\nCREATE TABLE tab_favorite (\n    rid INT, -- 线路id\n    DATE DATETIME,\n    uid INT, -- 用户id\n    -- 创建复合主键\n    PRIMARY KEY(rid,uid), -- 联合主键\n    FOREIGN KEY (rid) REFERENCES tab_route(rid),\n    FOREIGN KEY(uid) REFERENCES tab_user(uid)\n);\n```\n\n打开架构设计器，就会自动生成如下关系图\n\n{% asset_img 7.png 架构设计 %}\n\n## 5.2 数据库设计的范式\n\n概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须要遵循前边所有的范式要求\n\n{% asset_img 8.png 范式的概念 %}\n\n分类：\n\n* 第一范式\n* 第二范式\n* 第三范式\n* 其他范式\n\n{% asset_img 9.png 范式分类 %}\n\n### 第一范式\n\n**第一范式理解：每一列都是不可分割的原子数据项。**\n\n{% asset_img 10.png 第一范式 %}\n\n像这样的一张表，就满足第一范式了，但是也存在问题\n\n1. 存在非常严重的数据冗余（重复）：姓名、系名、系主任\n2. 数据添加存在问题：添加新开设的系和系主任时，数据不合法\n3. 数据删除存在问题：如果有人毕业了，删除信息时，会将系一起删掉。\n\n### 第二范式\n\n**第二范式理解：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖）** \n\n**函数依赖**：A-->B，如果A属性（属性组）的值，可以唯一确定B属性的值。则成B依赖于A。例如，学号-->姓名；（学号，课程名称）-->分数\n\n**完全函数依赖：**A-->B，如果A是一个属性组，则B属性值的确定需要依赖于A属性组中的所有的属性值。例如，（学号，课程名称）-->分数\n\n**部分函数依赖：**A-->B，如果A是一个属性组，则B属性值的确定只需要依赖于A属性组中的某一些值即可。例如，（学号，课程名称）-->姓名\n\n**传递函数依赖：**A-->B，B-->C，如果通过A属性（属性组）的值，可以确定唯一B属性的值，再通过B属性（属性组）的值可以确定唯一C属性的值，则称C传递函数依赖于A。例如，学号-->系名，系名-->系主任\n\n**码：**如果在一张表中，一个属性或者属性组，被其他所有属性所依赖，则称这个属性（属性组）为该表的码。例如，在上表中的码，就是（学号，课程名称）。\n\n* 主属性：码属性组中的所有属性\n* 非主属性：除码属性组的属性\n\n详细了解，请移步[这里]( https://blog.csdn.net/sumaliqinghua/article/details/85872446 )\n\n现在根据第二范式的理解，在1NF基础上基础上消除非主属性对主码的**部分函数依赖**。\n\n{% asset_img 11.png 第二范式 %}\n\n### 第三范式\n\n第三范式理解：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖） \n\n{% asset_img 12.png 第三范式 %}\n\n### 其他范式\n\n 巴德斯科范式(BCNF)、第四范式(4NF)和第五范式(5NF) \n\n# 六、数据库的备份与还原\n\n数据库的备份和还原目的：防止出现问题，导致数据丢失的情况。\n\n## 6.1 命令行\n\n备份语法：mysqldmp -u用户名 -p密码 数据库名称 > 保存的路径\n\n还原语法：\n\n1. 登录数据库\n2. 创建数据库\n3. 使用数据库\n4. 执行文件：source 文件路径\n\n## 6.2 可视化工具\n\n不同的可视化工具，具体操作不同，不多赘述\n\n# 七、事务\n\n## 7.1 事务的了解\n\n### 概念\n\n如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。\n\n举个例子，支付宝转钱。A给B转5块钱，成功的话，A账户金额-5，B账户金额+5。如果在A账户减少金额，或者在B账户增加金额的过程中出错，则所有事件回滚。\n\n### 事务的操作\n\n具体操作\n\n1. 开启事务\n2. 回滚\n3. 提交\n\n开启事务：start transaction;\n\n回滚：rollback;\n\n提交：commit;\n\n```sql\n-- zs给ls转账500\n-- 0 开启事务\nstart transaction;\n\n-- 1 zs账户-500\nupdate account set balance=balance-500 where name='zs';\n\n-- 1.5 模拟中间异常\n-- 我来打断，嘿咻嘿咻！\n\n-- 2 ls账户+500\nupdate account set balance=balance+500 where name='ls';\n\n-- 2.5 模拟中间状态，此时可以通过查询看看中间结果\n-- select * from account;\n-- 会发现数据已经变了\n\n-- 3 发现执行没有问题，提交事务，执行成功\ncommit;\n\n-- 3 有问题的话，就回滚事务，执行失败\nrollback;\n```\n\n 事务提交的两种方式：\n\n1. 自动提交\n   MySQL就是自动提交的，然而Oracle默认是手动提交的。\n   一条DML（增删改）语句会自动提交一次事务。\n2. 手动提交\n   需要先开启事务，再提交\n\n修改事务的默认提交方式：\n\n1. 查看事务的默认提交方式：SELECT @@autocommit; -- 1代表自动提交 0代表手动提交\n2. 修改默认提交方式：set @@autocommit=0;\n\n## 7.2 事务的四大特征\n\n特征：\n\n1. **原子性：**是不可分割的最小操作单位，要么同时成功，要么同时失败。\n2. **持久性：**当事务提交或者回滚后，数据库会持久化地保存数据。\n3. **隔离性：**多个事务之间，相互独立。但是，真实的情况下，事务之间是相互影响的，所以，我们要了解事务的隔离级别\n4. **一致性：**事务操作前后，数据总量不变。\n\n## 7.3 事务的隔离级别\n\n概念：多个事务之间是隔离的，即相互独立的。但是，如果多个事务，操作同一批数据，则会引发一些问题，设置不同的隔离级别，就可以解决这些问题。\n\n存在问题：\n\n1. 脏读：一个事务，读取到另一个事务中没有提交的数据。\n2. 不可重复读（虚读）：在同一个事务中，两次读取到的事务不一样。\n3. 幻读：一个事务操作（DML）数据表中所有记录，A事务添加了一条数据，B事务查询不到修改。\n\n[数据库并发事务存在的问题](https://blog.csdn.net/starlh35/article/details/76445267)\n\n隔离级别：\n\n1. read uncommited\n   含义：读未提交\n   产生的问题：脏读、不可重复读、幻读\n2. read commited（Oracle中默认隔离级别）\n   含义：读已提交\n   产生的问题：不可重复读、幻读\n3. repeatable read（MySQL中默认隔离级别）\n   含义：可重复读\n   产生问题：幻读\n4. serializable\n   含义：串行化（相当于把表锁上，A事物不提交，B事物是没法查询得到的）\n   可以解决任何问题\n\n> 注意：\n>\n> 隔离级别从小到大，安全性越来越高，但是效率越来越低。我们要选择合适级别，既保证相对比较安全，又能保证效率较高\n\n修改数据库的默认隔离级别：\n\n1. 查询隔离级别：\n   mysql5.6-5.7：select @@tx_isolation;\n   mysql8.0+：select @@transaction_isolation;\n2. 设置隔离级别：set global transaction isolation level 级别字符串;\n\n[MySQL8.0+系统变量文档](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html)\n\n[MySQL5.6系统变量文档](https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html)\n\n> 修改隔离级别之后，查询，如果没有改变。需要断开连接，重新连接之后，才会查出来。\n\n# 八、触发器\n\n本篇内容是做课程设计时，需要用触发器，由此就来总结一下。[参考文章](https://www.cnblogs.com/phpper/p/7587031.html)\n\n## 8.1 概念\n\n定义：触发器是与表有关的数据库对象，在满足定义条件时触发，并执行触发器中定义的语句集合。\n\n作用：协助应用在数据库端确保数据的完整性。\n\n举例，比如我现在有两个表，unit和person表，person与unit通过unitid进行外键约束。当创建person就需要在其对应的unit表中更新总人数字段，我们可以通过编写程序语言逻辑来实现，如果通过触发器，会自动更新字段，更容易了。\n\n触发器的类型\n\n1. INSERT型触发器：在执行insert、load data、replace语句时触发\n2. UPDATE型触发器：在执行update语句时触发\n3. DELETE型触发器：在执行delete、replace时触发\n\n> load data语句是将文件的内容插入到表中，相当于是insert语句\n>\n> replace语句在一般的情况下和insert差不多，但是如果表中存在primary或者unique索引的时候，如果插入的数据和原来的primary key或者unique相同的时候，会删除原来的数据，然后再增加一条新的护具。\n>\n> 可以理解成，replace在没有重复的时候，相当于insert；若有重复，则会删除原来的，再执行insert\n\n## 8.2 语法\n\n要素\n\n1. 触发器名称\n2. 触发时机\n   * BEFORE：之前\n   * AFTER：之后\n3. 触发事件\n   * INSERT\n   * UPDATE\n   * DELETE\n4. 表名：需要建立触发器的表名\n5. 执行语句\n   * 一条SQL语句\n   * 多条SQL语句，通过begin和and包含起来\n\n### 创建触发器\n\n```sql\n-- 一条执行语句\nCREATE TRIGGER 触发器名称 触发时机 触发事件 ON 表名 FOR EACH ROW 执行语句 \n\n-- 多条执行语句\nCREATE TRIGGER 触发器名称 触发时机 触发事件 ON 表名 FOR EACH ROW\nBEGIN\n\t执行语句列表 \nEND\n```\n\n{% asset_img 17.png %}\n\n以上图为例，创建触发器，来实现person的数据发生变化时，修改unit表的总人数\n\n```sql\nCREATE TRIGGER insert_trigger AFTER INSERT ON person FOR EACH ROW\nUPDATE unit AS a\nJOIN ( SELECT count(*) sum, unitid FROM person GROUP BY unitid ) AS b ON a.unitid = b.unitid \nSET a.sum = b.sum;\n\nCREATE TRIGGER delete_trigger AFTER DELETE ON person FOR EACH ROW\nUPDATE unit AS a\nJOIN ( SELECT count(*) sum, unitid FROM person GROUP BY unitid ) AS b ON a.unitid = b.unitid \nSET a.sum = b.sum;\n```\n\n在执行多条语句的时候，触发器中间的sql语句分支是用`;`来分割的。如果有多个触发器的话，最后也是需要加一个结束符号。而MySQL默认是以`;`作为结束执行语句，为避免与触发器的内部分支起冲突，我们可以通过使用`DELIMITER $`来将结束符号修改为`$`\n\n> 一般用在命令行的时候会这样，直接使用可视化工具，可以不用写\n\n```sql\nDELIMITER $\n\nCREATE TRIGGER insert_trigger AFTER INSERT ON tb003 FOR EACH ROW\nBEGIN\n\t\tUPDATE tb002 AS a\n\t\tJOIN ( SELECT unitaccnum, sum( basenumber ) sum FROM tb003 WHERE peraccstate = 0 GROUP BY unitaccnum ) AS b ON a.unitaccnum = b.unitaccnum \n\t\tSET a.basenumber = b.sum;\n\tUPDATE tb002 AS a\n\tJOIN ( SELECT unitaccnum, sum( unitmonpaysum ) AS sum FROM tb003 WHERE peraccstate = 0 GROUP BY unitaccnum ) AS b ON a.unitaccnum = b.unitaccnum \n\tSET a.unitpaysum = b.sum;\n\tUPDATE tb002 AS a\n\tJOIN ( SELECT unitaccnum, sum( permonpaysum ) AS sum FROM tb003 WHERE peraccstate = 0 GROUP BY unitaccnum ) AS b ON a.unitaccnum = b.unitaccnum \n\tSET a.perpaysum = b.sum;\n\tUPDATE tb002 AS a\n\tJOIN ( SELECT unitaccnum, count( accnum ) AS sum FROM tb003 WHERE peraccstate = 0 GROUP BY unitaccnum ) AS b ON a.unitaccnum = b.unitaccnum \n\tSET a.persnum = b.sum;\nEND $\n\nCREATE TRIGGER delete_trigger AFTER DELETE ON tb003 FOR EACH ROW\nBEGIN\n\t\tUPDATE tb002 AS a\n\t\tJOIN ( SELECT unitaccnum, sum( basenumber ) sum FROM tb003 WHERE peraccstate = 0 GROUP BY unitaccnum ) AS b ON a.unitaccnum = b.unitaccnum \n\t\tSET a.basenumber = b.sum;\n\tUPDATE tb002 AS a\n\tJOIN ( SELECT unitaccnum, sum( unitmonpaysum ) AS sum FROM tb003 WHERE peraccstate = 0 GROUP BY unitaccnum ) AS b ON a.unitaccnum = b.unitaccnum \n\tSET a.unitpaysum = b.sum;\n\tUPDATE tb002 AS a\n\tJOIN ( SELECT unitaccnum, sum( permonpaysum ) AS sum FROM tb003 WHERE peraccstate = 0 GROUP BY unitaccnum ) AS b ON a.unitaccnum = b.unitaccnum \n\tSET a.perpaysum = b.sum;\n\tUPDATE tb002 AS a\n\tJOIN ( SELECT unitaccnum, count( accnum ) AS sum FROM tb003 WHERE peraccstate = 0 GROUP BY unitaccnum ) AS b ON a.unitaccnum = b.unitaccnum \n\tSET a.persnum = b.sum;\nEND $\n\nDELIMITER ;\n```\n\n可以通过导出sql文件，来进行查看。\n\n{% asset_img 18.png %}\n\n### 删除触发器\n\n```sql\n-- 删除触发器\nDROP TRIGGER 触发器名称\n```\n\n### 定义变量\n\n在begin...end中可以自定义变量，但是只能在begin...end中使用\n\n语法\n\n```sql\n-- 在begin...and中定义变量\nDECLARE\n\t变量名 变量类型 [默认值] \n\tSET 变量名 =值\n```\n\n### New&Old\n\nNEW和OLD使用\n\n1. NEW：表示将要或者已经增加（或修改或删除）的数据，用于INSERT、UPDATE型触发器\n2. OLD：表示将要或者已经被删除的数据，用于UPDATE、DELETE型触发器\n\n语法\n\n```sql\n-- 新增或修改行的某列数据\nNEW.列名 \n\n-- 删除或修改行的某列数据\nOLD.列名\n```\n\n## 8.3 案例\n\n### 需求\n\n当在users中插入一条数据`江厌离`，就会在logs中生成一条日志信息`江厌离 is created`。\n\n创建users表\n\n```sql\nDROP TABLE IF EXISTS `users`;\nCREATE TABLE `users`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `add_time` int(11) NULL DEFAULT NULL,\n  PRIMARY KEY (`id`) USING BTREE,\n  INDEX `name`(`name`(250)) USING BTREE\n) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;\n```\n\n创建logs表\n\n```sql\nDROP TABLE IF EXISTS `logs`;\nCREATE TABLE `logs`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `log` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '日志说明',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '日志表' ROW_FORMAT = Dynamic;\n```\n\n### 实现\n\n```sql\nDROP TRIGGER IF EXISTS `user_log`;\ndelimiter ;;\nCREATE TRIGGER `user_log` AFTER INSERT ON `users` FOR EACH ROW begin\ndeclare s1 varchar(40);\ndeclare s2 varchar(40);\nset s2=' is created';\nset s1=concat(new.name,s2);\ninsert into logs(log) values(s1);\nend\n;;\ndelimiter ;\n```\n\n> 所有的触发器都存在information_schema数据库下的triggers表中\n\n# 九、存储过程\n\n## 9.1 概念\n\n理论概念，看看就行\n\n{% asset_img 21.png %}\n\n存储过程：类似于java代码中的方法，可以直接调用，来实现某些功能逻辑。有参数跟返回值\n\n> Navicat中描述的就挺合理，一个函数代替了，哈哈\n>\n> 本质不就是个可调用的方法嘛\n\n优点：\n\n1. 代码可复用\n2. 代码精简一致\n3. 可维护性高\n\n缺点：\n\n1. 可移植性差\n2. 使用于模块较小的功能：跟代码一样，每个方法功能尽量小，这样既易维护，又方便使用\n\n## 9.2 快速入门\n\n直接上sql语句\n\n```sql\n-- 删除存储过程\nDROP PROCEDURE IF EXISTS getUsers;\n\n-- 创建存储过程\nCREATE PROCEDURE getUsers () \nBEGIN\n\tSELECT * FROM users;\nEND;\n\n-- 调用存储过程\nCALL getUsers ();\n```\n\n参数类型\n\n1. IN：传递给存储过程\n2. OUT：从存储过程传出\n3. INOUT：对存储过程传入和传出\n\nOUT\n\n```sql\nDROP PROCEDURE IF EXISTS getGrades;\n\n-- 创建触发器，返回三个变量的值\nDELIMITER ;;\nCREATE PROCEDURE getGrades(\nOUT minGrade DECIMAL(8,2),\nOUT avgGrade DECIMAL(8,2),\nOUT maxGrade DECIMAL(8,2)\n)\nBEGIN\nSELECT MIN(grade) INTO minGrade FROM memeber;\nSELECT AVG(grade) INTO avgGrade FROM memeber;\nSELECT MAX(grade) INTO maxGrade FROM memeber;\nEND ;;\nDELIMITER ;\n\n-- 用三个变量a,b,c接收值\nCALL getGrades (@a, @b, @c) ;\n\n\n-- 查询三个变量的值\nSELECT @a,@b,@c\n```\n\n> 在测试的过程中，发现\n>\n> select name into username from memeber;\n>\n> 和\n>\n> select name from memeber into username;\n>\n> 最后的效果是一样的，所以，这两条语句是等价的\n\nIN\n\n```sql\ndrop procedure if exists getNameById;\n\nDelimiter ;;\ncreate procedure getNameById(\nin userId int,\nout userName varchar(200)\n)\nbegin\nselect name from memeber where id=userId INTO userName;\nend;;\nDelimiter ;\n\n-- 传入id为7，然后用name接收结果\nCall getNameById(7,@name);\n\n-- 查询结果\nselect @name;\n```\n\n用sqlyog运行的时候，把字符串所占的字节也输出了，我就特意百度了一下，字节为啥有的2两个，有的占3个\n\n原因是字符集的原因，gbk中，英文占1字节（Byte，简记为B）,汉字占2字节；utf-8，英文占1个字节，汉字占3个字节。可以参考[这篇文章](https://meethigher.top/blog/2020/bytes-of-characters/)\n\n","tags":["sql"]},{"title":"各种技巧整合","url":"/blog/2020/tips/","content":"\n记录些生活中用到的小技巧\n\n<!--more-->\n\n# 一、QQ/微信防撤回\n\n[QQ端QNotified](https://github.com/cinit/QNotified)\n\n[微信端WXposed](https://repo.xposed.info/module/com.fkzhang.wechatxposed)\n\n[电脑端Q微信防撤回](https://github.com/huiyadanli/RevokeMsgPatcher)\n\n# 二、电脑定时关机\n\n[参照](http://xinzhi.wenda.so.com/a/1509015643200392)\n\n指定时间后自动关机\n\n```powershell\nshutdown -s -t 3600 #1小时候自动关机\n```\n\n自动关机\n\n```powershell\nshutdown -s #弹出消息框自动关机，30s后\n```\n\n定点关机\n\n```powershell\nat 04:00 shutdown -s #凌晨四点自动关机\n```\n\n> 指定时间关机需要用schtasks，命令太麻烦了，不如直接打开计划任务来手动添加\n\n# 三、网页视频去除logo\n\n[参照](https://www.bilibili.com/video/BV1tz411i7AG)\n\nf12搜索、删除\n\n腾讯视频\n\n```powershell\ntxp-ui-watermark-mod\n```\n\n爱奇艺\n\n```powershell\niqp-logo-top logoShowAnimation\n```\n\n优酷\n\n```\nyouku-layer-logo\n```\n\n# 四、网页内容可编辑\n\nconsole中输入\n\n```js\ndocument.body.contentEditable=true\n```\n\n# 五、百度网盘\n\n1. 速盘（付费）\n2. [亿寻（免费）](https://yixun.writeas.com/yi-xun)\n\n# 六、定位\n\n[Fake Location](https://github.com/Lerist/FakeLocation/releases/tag/1.2.0.6)\n\n可以修改定位，甚至可以以指定的速度移动，很强大。\n\n# 七、MIUI刷机包&&IOS刷机包\n\n[MIUI历史版本](https://miuiver.com/)\n\n{% asset_img 1.png %}\n\n[MIUI线刷升级](http://www.miui.com/shuaji-393.html)\n\n{% asset_img 2.png %}\n\n[IOS尝鲜派](https://ibeta.me/)\n\n{% asset_img 3.png %}\n\n# 八、创建右键cmd打开\n\n桌面新建一个cmd.reg\n\n```powershell\nWindows Registry Editor Version 5.00\n[HKEY_CLASSES_ROOT\\Directory\\shell\\runas]\n@=\"Open cmd here as Admin\"\n\"HasLUAShield\"=\"\"\n[HKEY_CLASSES_ROOT\\Directory\\shell\\runas\\command]\n@=\"cmd.exe /s /k pushd \\\"%V\\\"\"\n[-HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas]\n[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas]\n@=\"Open cmd here as Admin\"\n\"HasLUAShield\"=\"\"\n[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\runas\\command]\n@=\"cmd.exe /s /k pushd \\\"%V\\\"\"\n[-HKEY_CLASSES_ROOT\\Drive\\shell\\runas]\n[HKEY_CLASSES_ROOT\\Drive\\shell\\runas]\n@=\"Open cmd here as Admin\"\n\"HasLUAShield\"=\"\"\n[HKEY_CLASSES_ROOT\\Drive\\shell\\runas\\command]\n```\n\n双击运行即可\n\n# 九、防火墙应用阻止程序\n\n[下载地址](https://www.sordum.org/8125/firewall-app-blocker-fab-v1-7/)\n\n在Windows中，您可以使用Windows防火墙来阻止或取消阻止某些应用程序，但是它的高级功能没有提供易于使用的界面。如果您想阻止应用程序访问互联网， 您必须执行以下步骤：\n\n1. 单击Windows“开始”菜单并打开“控制面板”\n2. 选择“系统和安全性”\n3. 然后在“防火墙”部分中，选择“允许程序通过Windows防火墙”\n4. 如果您要阻止或取消阻止的程序不是列出，您必须单击“允许另一个程序”将其添加。在列表中选择应用程序，然后选择“添加”。否则，您必须浏览硬盘驱动器以找到它，依此类推。对于普通用户来说，这似乎很复杂。\n\n防火墙应用阻止程序使该过程非常容易！只需将要阻止的应用程序拖放到FAB窗口中，或浏览硬盘以找到它即可。\n\n> 这个可以指定某个应用禁止联网，当然，是需要开启防火墙功能的，像我，一般不用防火墙，都是关闭状态。\n>\n> 所以，我也使用腾讯电脑管家和火绒来管理网络，比如某些app后台跑流量，腾讯或者火绒监测出来，就可以直接禁网，比方说禁用搜狗输入法的广告，直接禁用广告的程序，舒服的一批。\n>\n> 腾讯竟然支持禁用自己本身的网络，这点是360所没有的，这是我选择腾讯的原因。\n>\n> 火绒可以禁用windows系统进程的网络，比如svchost\n\n# 十、win10虚拟屏幕\n\nwin+tab键，即可打开面板，新建桌面\n\nwin+ctrl+左，切换左侧桌面（右同理）\n\nwin+ctrl+D，切换到一个新创建的桌面\n\nwin+ctrl+f4，删除当前桌面\n\n> 其实本身并没有啥区别，还是相当于在一个屏幕上。\n>\n> 比如在a桌面打开一个文件，在b桌面在去打开时，会自动跳到a桌面\n\n# 十一、如何让win10系统变得好看\n\n直接上链接吧，\n\n[如何让Windows 10系统桌面变得更好看？ - 辜月二七的回答 - 知乎 ](https://www.zhihu.com/question/45120814/answer/1007955630)\n\n> 花了一个多小时整了整\n>\n> TB这个软件，还行，可以让任务栏透明、高斯模糊等等\n>\n> Trays这个软件，简直就是一个大型流氓，改了任务栏之后无法恢复到默认，我特么把软件卸载之后，换了个主题才恢复原样，直接改了系统配置，强买强卖嘛？\n\n总结一下，就是不实用，还是我自己这个实用一点。\n\n{% asset_img 4.png %}\n\n直接用电脑管家里的小火箭、桌面管理、经典开始菜单，总得来说，电脑管家还是比较方便的。\n\n# 十二、windows快捷键\n\n说一下我自己比较常用的吧。可以用来快速切换\n\n1. win+数字键，可以快速切换任务栏内容，这可比什么quicker舒服多了\n2. win+D，返回桌面\n3. win+R，打开运行窗口\n4. win+L，锁定计算机\n5. win+tab，任务视图\n\n# 十三、windows设置自启动\n\n## 关闭自启动\n\n可以使用第三方软件，比方说电脑管家。也可以通过任务管理器-启动来关闭。\n\n如果是win10的话，还可以在所有设置-应用-启动中进行关闭\n\n## 设置自启动\n\nwin+R打开运行窗口，然后复制以下内容，回车\n\n```powershell\n%USERPROFILE%\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup \n```\n\n当然也可以在自己的电脑里一层一层的按这个路径找。\n\n将要自启动的软件的快捷方式放到该文件夹即可。\n\n{% asset_img 5.png %}\n\n# 十四、QQ卡片消息\n\n[XposedInstaller下载链接](http://cdn.meethigher.top/media/Xposed%20Installer_3.1.5.apk)\n\n[QNotified下载链接](http://cdn.meethigher.top/media/QNotified_0.8.0.apk)\n\n具体的使用教程，我在B站发了视频，[链接](https://www.bilibili.com/video/BV1La4y1E7DK/)\n\n今天早上在某个群，看到一个红包，我就点了，点击去发现是一个购物群。然后我直接把群退了，然后把源代码给他复制了下来。\n\n现在整理一下\n\n> 以下部分内容，像图片链接、跟文字内容都是空的，自己自行往里面加入即可。\n>\n> 有点链接，不带cdn.vip.qq.com是打不开的，有兴趣自行研究吧。\n>\n> 以下代码放心使用，内部无推广链接、加群邀请等。\n\n回执消息s\n\n```xml\n<?xml version='1.0' encoding='UTF-8' standalone='yes' ?><msg serviceID=\"107\" templateID=\"1\" action=\"viewReceiptMessage\" brief=\"\" m_resid=\"\" m_fileName=\"6862690782327914927\" sourceMsgId=\"0\" url=\"\" flag=\"3\" adverSign=\"0\" multiMsgFlag=\"0\"><item layout=\"29\" advertiser_id=\"0\" aid=\"0\"><type>1</type></item><source name=\"\" icon=\"\" action=\"\" appid=\"-1\" /></msg>\n```\n\n王者荣耀点券\n\n```json\n{\"app\":\"com.tencent.gamecenter.wzryRedpack\",\"desc\":\"\",\"view\":\"indexView\",\"ver\":\"1.0.0.1\",\"prompt\":\"[王者荣耀]点券\",\"appID\":\"\",\"sourceName\":\"\",\"actionData\":\"\",\"actionData_A\":\"\",\"sourceUrl\":\"\",\"meta\":{\"shareData\":{\"appid\":\"1104466820\",\"bgUrl\":\"http://imgcache.gtimg.cn/ark_msg/202001101435_1dianquan.png?ts=1578638150326\",\"buttons\":[{\"bgUrl\":\"http:\\/\\/imgcache.gtimg.cn\\/ark_msg\\/202001101436_anniu.png?ts=1578638168399\",\"jumpUrl\":\"https:\\/\\/cdn.vip.qq.com\\/club\\/themes\\/mobile\\/middle_page\\/index.html?url=https://meethigher.top/\"}],\"gamedata\":\"RedEnvelopeMsg_1_932630632774173750\",\"jumpUrl\":\"https:\\/\\/cdn.vip.qq.com\\/club\\/themes\\/mobile\\/middle_page\\/index.html?url=https://meethigher.top/\"}},\"config\":{\"config\":{\"type\":\"normal\"},\"ctime\":1587447079,\"token\":\"5050ace6eed03ce46e86314d846f3ed0\"},\"text\":\"\",\"extraApps\":[],\"sourceAd\":\"\",\"extra\":\"\"}\n```\n\n王者荣耀皮肤碎片\n\n```json\n{\"app\":\"com.tencent.gamecenter.wzryRedpack\",\"desc\":\"\",\"view\":\"indexView\",\"ver\":\"1.0.0.1\",\"prompt\":\"[王者荣耀]皮肤碎片\",\"appID\":\"\",\"sourceName\":\"\",\"actionData\":\"\",\"actionData_A\":\"\",\"sourceUrl\":\"\",\"meta\":{\"shareData\":{\"appid\":\"1104466820\",\"bgUrl\":\"http://imgcache.gtimg.cn/ark_msg/202001101442_6pifusuipian.png?ts=1578638530997\",\"buttons\":[{\"bgUrl\":\"http:\\/\\/imgcache.gtimg.cn\\/ark_msg\\/202001101442_anniu.png?ts=1578638541669\",\"jumpUrl\":\"http:\\/\\/h5.vip.qq.com\\/p\\/cgireport\\/cgi-bin\\/handle?dc=10535&adId=81046&posId=85&classId=36&url=\"}],\"gamedata\":\"RedEnvelopeMsg_1_17568364407905649653\",\"jumpUrl\":\"app\",\"scene\":\"MSG_WZZD_PFSP_ARK\"}},\"config\":{\"config\":{\"type\":\"normal\"},\"ctime\":1582893526,\"token\":\"a50cac990543523e54f06efcab1801f3\"},\"text\":\"\",\"extraApps\":[],\"sourceAd\":\"\",\"extra\":\"\"}\n```\n\n匿名聊天加入\n\n```json\n{\"app\":\"com.tencent.mobileqq.reading\",\"desc\":\"\",\"view\":\"singleImg\",\"ver\":\"1.0.0.70\",\"prompt\":\"匿名聊天 \",\"appID\":\"\",\"sourceName\":\"\",\"actionData\":\"\",\"actionData_A\":\"\",\"sourceUrl\":\"\",\"meta\":{\"singleImg\":{\"mainImage\":\"http://shp.qpic.cn/collector/2891404183/fe660152-4179-4669-bd8f-690289d389c2/0\",\"mainUrl\":\"mqqapi%3A%2F%2Fforward%2Furl%3Furl_prefix%3Dhttps://meethigher.top/\"}},\"text\":\"\",\"sourceAd\":\"\"}\n```\n\n周年福利，人人可领\n\n```json\n{\"app\":\"com.tencent.qqVipGame_v2\",\"desc\":\"\",\"view\":\"template\",\"ver\":\"1.0.0.8\",\"prompt\":\"周年福利人人可领\",\"appID\":\"\",\"sourceName\":\"\",\"actionData\":\"\",\"actionData_A\":\"\",\"sourceUrl\":\"\",\"meta\":{\"template\":{\"DATA10\":\"\",\"DATA11\":\"\",\"DATA12\":\"\",\"DATA13\":\"\",\"DATA14\":\"http:\\/\\/h5.vip.qq.com\\/p\\/cgireport\\/cgi-bin\\/handle?dc=10535&adId=81046&posId=85&classId=36&url=https://meethigher.top\",\"DATA15\":\"\",\"DATA16\":\"\",\"DATA7\":\"https:\\/\\/tianshu.gtimg.cn\\/tianshu\\/1597632725271.png\",\"DATA8\":\"\",\"DATA9\":\"\",\"time\":\"\"}},\"text\":\"\",\"extraApps\":[],\"sourceAd\":\"\"}\n```\n\n视频跳转卡片\n\n```json\n{\"app\":\"com.tencent.gamecenter.gameshare\",\"desc\":\"\",\"view\":\"noDataView\",\"ver\":\"0.0.0.1\",\"prompt\":\"大话西游\",\"appID\":\"\",\"sourceName\":\"\",\"actionData\":\"\",\"actionData_A\":\"\",\"sourceUrl\":\"\",\"meta\":{\"shareData\":{\"height\":360,\"scene\":\"SCENE_SHARE_VIDEO\",\"buttons\":[{\"url\":\"http:\\/\\/h5.vip.qq.com\\/p\\/cgireport\\/cgi-bin\\/handle?dc=10535&adId=81046&posId=85&classId=36&url=\",\"text\":\"点就恶搞你\"}],\"jumpUrl\":\"https:\\/\\/game.gtimg.cn\\/images\\/cfm\\/act\\/a20190620act\\/index.mp4\",\"width\":640,\"type\":\"video\",\"cover\":\"\",\"appid\":\"1104466820cfm\",\"url\":\"https://game.gtimg.cn/images/yxzj/cp/a20190125dhxy/header_reload.mp4\"}},\"text\":\"\",\"sourceAd\":\"\",\"config\":{\"forward\":1,\"showSender\":1},\"config\":{\"forward\":1,\"showSender\":1}}\n```\n\n每日风景\n\n```json\n{\"app\":\"com.tencent.mobileqq.reading\",\"desc\":\"\",\"view\":\"singleImg\",\"ver\":\"1.0.0.70\",\"prompt\":\"随机风景照\",\"appID\":\"\",\"sourceName\":\"\",\"actionData\":\"\",\"actionData_A\":\"\",\"sourceUrl\":\"\",\"meta\":{\"singleImg\":{\"mainImage\":\"https:\\/\\/uploadbeta.com\\/api\\/pictures\\/random\\/?key=BingEverydayWallpaperPicture\",\"mainUrl\":\"https://cdn.vip.qq.com/club/client/read/common/transfer.html?_wv=16778247&url=%68%74%74%70%3a%2f%2f%68%35%2e%76%69%70%2e%71%71%2e%63%6f%6d%2f%70%2f%63%67%69%72%65%70%6f%72%74%2f%63%67%69%2d%62%69%6e%2f%68%61%6e%64%6c%65%3f%64%63%3d%31%30%35%33%35%26%61%64%49%64%3d%38%31%30%34%36%26%70%6f%73%49%64%3d%38%35%26%63%6c%61%73%73%49%64%3d%33%36%26%75%72%6c%3d\"}},\"text\":\"这里无需填写\",\"sourceAd\":\"\"}\n```\n\n每日美女\n\n```json\n{\"app\":\"com.tencent.mobileqq.reading\",\"desc\":\"\",\"view\":\"singleImg\",\"ver\":\"1.0.0.70\",\"prompt\":\"随机美女\",\"appID\":\"\",\"sourceName\":\"\",\"actionData\":\"\",\"actionData_A\":\"\",\"sourceUrl\":\"\",\"meta\":{\"singleImg\":{\"mainImage\":\"https:\\/\\/uploadbeta.com\\/api\\/pictures\\/random\\/?key=%E6%8E%A8%E5%A5%B3%E9%83%8E\",\"mainUrl\":\"https://cdn.vip.qq.com/club/client/read/common/transfer.html?_wv=16778247&url=%68%74%74%70%3a%2f%2f%68%35%2e%76%69%70%2e%71%71%2e%63%6f%6d%2f%70%2f%63%67%69%72%65%70%6f%72%74%2f%63%67%69%2d%62%69%6e%2f%68%61%6e%64%6c%65%3f%64%63%3d%31%30%35%33%35%26%61%64%49%64%3d%38%31%30%34%36%26%70%6f%73%49%64%3d%38%35%26%63%6c%61%73%73%49%64%3d%33%36%26%75%72%6c%3d\"}},\"text\":\"\",\"sourceAd\":\"\"}\n```\n\n爱他就要告诉他\n\n```json\n{\"app\":\"com.tencent.mobileqq.reading\",\"desc\":\"\",\"view\":\"singleImg\",\"ver\":\"1.0.0.70\",\"prompt\":\"爱Ta就写信告诉Ta\",\"appID\":\"\",\"sourceName\":\"\",\"actionData\":\"\",\"actionData_A\":\"\",\"sourceUrl\":\"\",\"meta\":{\"singleImg\":{\"mainImage\":\"http:\\/\\/tianshu.gtimg.cn\\/tianshu\\/1598010537642.png\",\"mainUrl\":\"https://cdn.vip.qq.com/club/client/read/common/transfer.html?_wv=16778247&url=%68%74%74%70%3a%2f%2f%68%35%2e%76%69%70%2e%71%71%2e%63%6f%6d%2f%70%2f%63%67%69%72%65%70%6f%72%74%2f%63%67%69%2d%62%69%6e%2f%68%61%6e%64%6c%65%3f%64%63%3d%31%30%35%33%35%26%61%64%49%64%3d%38%31%30%34%36%26%70%6f%73%49%64%3d%38%35%26%63%6c%61%73%73%49%64%3d%33%36%26%75%72%6c%3d\"}},\"text\":\"\",\"sourceAd\":\"\"}\n```\n\n二次元动漫\n\n```json\n{\"app\":\"com.tencent.mobileqq.reading\",\"desc\":\"\",\"view\":\"singleImg\",\"ver\":\"1.0.0.70\",\"prompt\":\"二次元动漫\",\"appID\":\"\",\"sourceName\":\"\",\"actionData\":\"\",\"actionData_A\":\"\",\"sourceUrl\":\"\",\"meta\":{\"singleImg\":{\"mainImage\":\"http:\\/\\/xialinzhijia.club\\/wp-img.php\",\"mainUrl\":\"https://cdn.vip.qq.com/club/client/read/common/transfer.html?_wv=16778247&url=%68%74%74%70%3a%2f%2f%68%35%2e%76%69%70%2e%71%71%2e%63%6f%6d%2f%70%2f%63%67%69%72%65%70%6f%72%74%2f%63%67%69%2d%62%69%6e%2f%68%61%6e%64%6c%65%3f%64%63%3d%31%30%35%33%35%26%61%64%49%64%3d%38%31%30%34%36%26%70%6f%73%49%64%3d%38%35%26%63%6c%61%73%73%49%64%3d%33%36%26%75%72%6c%3d\"}},\"text\":\"\",\"sourceAd\":\"\"}\n```\n\n最新公告\n\n```json\n{\"app\":\"com.tencent.mannounce\",\"desc\":\"群公告\",\"view\":\"main\",\"ver\":\"1.0.0.43\",\"prompt\":\"[群公告]测试测试\",\"appID\":\"\",\"sourceName\":\"\",\"actionData\":\"\",\"actionData_A\":\"\",\"sourceUrl\":\"\",\"meta\":{\"mannounce\":{\"cr\":0,\"encode\":1,\"fid\":\"fb40082100000000cfa6495f004f0c00\",\"gc\":\"554189051\",\"sign\":\"1cd3b58df1e8222b7a1dcb44d6b2b8c9\",\"text\":\"5rWL6K+V5rWL6K+V\",\"title\":\"576k5YWs5ZGK\",\"tw\":1,\"uin\":\"5201314\"}},\"config\":{\"ctime\":1598662148,\"forward\":0,\"token\":\"2f4b34dc143c29f9eb6d4f5c057a2e41\"},\"text\":\"\",\"sourceAd\":\"\"}\n```\n\n网页分享\n\n```xml\n{\"app\":\"com.tencent.structmsg\",\"desc\":\"\",\"view\":\"news\",\"ver\":\"0.0.0.1\",\"prompt\":\"[分享]言成的个人博客，记录生活\",\"appID\":\"\",\"sourceName\":\"\",\"actionData\":\"\",\"actionData_A\":\"\",\"sourceUrl\":\"\",\"meta\":{\"news\":{\"action\":\"\",\"android_pkg_name\":\"\",\"app_type\":1,\"appid\":100951776,\"desc\":\"\",\"jumpUrl\":\"https://meethigher.top\",\"preview\":\"https://meethigher.top/images/kitchen.jpg\",\"source_icon\":\"\",\"source_url\":\"\",\"tag\":\"博客\",\"title\":\"言成的个人博客，记录生活...\"}},\"text\":\"\",\"extraApps\":[],\"sourceAd\":\"\"}\n```\n\nQQ红包\n\n```json\n{\"app\":\"com.tencent.mobileqq.reading\",\"desc\":\"\",\"view\":\"singleImg\",\"ver\":\"1.0.0.70\",\"prompt\":\"[QQ红包]恭喜发财！\",\"appID\":\"\",\"sourceName\":\"\",\"actionData\":\"\",\"actionData_A\":\"\",\"sourceUrl\":\"\",\"meta\":{\"singleImg\":{\"mainImage\":\"http:\\/\\/shp.qpic.cn\\/collector\\/2891404183\\/5fa972cf-6144-460c-b433-d2448cd71968\\/0\",\"mainUrl\":\"mqqapi%3A%2F%2Fforward%2Furl%3Furl_prefix%3D\"}},\"text\":\"\",\"sourceAd\":\"\"}\n```\n\nQQ会员专属礼物\n\n```json\n{\"app\":\"com.tencent.qqVipGame_v2\",\"desc\":\"\",\"view\":\"template\",\"ver\":\"1.0.0.8\",\"prompt\":\"[QQ会员]专属礼物🎁\",\"appID\":\"\",\"sourceName\":\"\",\"actionData\":\"\",\"actionData_A\":\"\",\"sourceUrl\":\"\",\"meta\":{\"template\":{\"DATA10\":\"\",\"DATA11\":\"\",\"DATA12\":\"\",\"DATA13\":\"\",\"DATA14\":\"http:\\/\\/h5.vip.qq.com\\/p\\/cgireport\\/cgi-bin\\/handle?dc=10535&adId=81046&posId=85&classId=36&url=\",\"DATA15\":\"\",\"DATA16\":\"\",\"DATA7\":\"https:\\/\\/tianshu.gtimg.cn\\/tianshu\\/1595813105678.png\",\"DATA8\":\"\",\"DATA9\":\"\",\"time\":\"\"}},\"text\":\"\",\"extraApps\":[],\"sourceAd\":\"\"}\n```\n\n欢迎新人\n\n```json\n<?xml version='1.0' encoding='UTF-8' standalone='yes' ?><msg serviceID=\"104\" templateID=\"1\" action=\"\" brief=\"新人入群！点击欢迎\" sourceMsgId=\"0\" url=\"\" flag=\"0\" adverSign=\"0\" multiMsgFlag=\"0\"><item layout=\"2\" advertiser_id=\"0\" aid=\"0\"><picture cover=\"\" w=\"0\" h=\"0\" /><title>新人入群</title></item><source name=\"\" icon=\"\" action=\"\" appid=\"0\" /></msg>\n```\n\n创建群聊\n\n```json\n{\"app\":\"com.tencent.creategroupmsg\",\"desc\":\"建群消息\",\"view\":\"main\",\"ver\":\"0.0.0.1\",\"prompt\":\"建群成功\",\"appID\":\"\",\"sourceName\":\"\",\"actionData\":\"\",\"actionData_A\":\"\",\"sourceUrl\":\"\",\"meta\":{\"groupinfo\":{\"cateid\":31,\"desc\":\"群聊创建成功！\\n完善资料，让更多人发现你的群！\",\"status\":0,\"subid\":10048,\"troopnum\":\"5201314\"}},\"config\":{\"autosize\":true,\"ctime\":1598667529,\"forward\":true,\"token\":\"0caafb70a5ee9a5e7c8250d85092cb83\",\"type\":\"normal\"},\"text\":\"\",\"extraApps\":[],\"sourceAd\":\"\"}\n\n```\n\n自动发消息\n\n```json\n{\"app\":\"com.tencent.autoreply\",\"desc\":\"\",\"view\":\"autoreply\",\"ver\":\"0.0.0.1\",\"prompt\":\"[动画表情]\",\"appID\":\"\",\"sourceName\":\"\",\"actionData\":\"\",\"actionData_A\":\"\",\"sourceUrl\":\"\",\"meta\":{\"metadata\":{\"title\":\"点下面按钮送妹子\",\"buttons\":[{\"slot\":1,\"action_data\":\"成功激活妹子大礼包*1，获得妹子*99个\",\"name\":\"我要妹子\",\"action\":\"notify\"}],\"type\":\"guest\",\"token\":\"LAcV49xqyE57S17B8ZT6FU7odBveNMYJzux288tBD3c=\"}},\"config\":{\"forward\":1,\"showSender\":1},\"text\":\"\",\"sourceAd\":\"\"}\n```\n\n游戏战绩分享\n\n```json\n{\"app\":\"com.tencent.gamecenter.gameshare_sgame\",\"desc\":\"游戏分享\",\"view\":\"commonView\",\"ver\":\"0.0.0.1\",\"prompt\":\"[应用]游戏分享\",\"appID\":\"\",\"sourceName\":\"\",\"actionData\":\"\",\"actionData_A\":\"\",\"sourceUrl\":\"\",\"meta\":{\"shareData\":{\"appid\":\"1104466820\",\"cardUrl\":\"http:\\/\\/image.smoba.qq.com\\/Banner\\/img\\/QQArk\\/shareskin\\/15004.jpg\",\"extData\":{\"gameSeq\":\"1600505319\",\"gameSvrEntity\":\"641806\",\"heroid\":\"108\",\"openId\":\"9AAA6C7F357E7EC9B3650B6AC09869EA\",\"playerNum\":\"10\",\"relaySvrEntity\":\"320340481\"},\"openId\":\"9AAA6C7F357E7EC9B3650B6AC09869EA\",\"roleInfo\":{\"avatar\":\"http:\\/\\/image.smoba.qq.com\\/Banner\\/img\\/QQArk\\/heroicon\\/108.png\",\"partition\":\"0杀\\/2助攻\\/15死亡\",\"roleName\":\"王者荣耀(5v5排位)\"},\"scene\":\"33\",\"textBoxData\":{\"desc\":\"0杀\\/2助攻\\/15死亡\",\"pic\":\"\",\"tips\":\"\",\"title\":\"超鬼打野\"},\"textGameData\":{\"data\":[{\"num\":\"0\",\"text\":\"击杀数\"},{\"num\":\"15\",\"text\":\"死亡数\"},{\"num\":\"2\",\"text\":\"助攻数\"}],\"title\":\"我的战绩\"},\"url\":\"http:\\/\\/imgcache.gtimg.cn\\/vipstyle\\/game\\/act\\/north\\/ark_gc843\\/wzry_game_share\\/bg.png\",\"wzryRecordInfo\":{\"isWin\":1,\"loseNum\":25,\"score\":12.7,\"scoreImg\":\"http:\\/\\/imgcache.gtimg.cn\\/vipstyle\\/game\\/act\\/north\\/ark_gc843\\/wzry_game_share\\/MVP.png\",\"winNum\":51}}},\"config\":{\"ctime\":1600506601,\"forward\":1,\"token\":\"b4ac273b4b4b8df42e89969c24b9a1e5\",\"type\":\"normal\"},\"text\":\"\",\"sourceAd\":\"\"}\n```\n\n英雄id\n\n```html\n　　105廉颇\n\n　　106小乔\n\n　　107赵云\n\n　　108墨子\n\n　　109妲己\n\n　　110嬴政\n\n　　111孙尚香\n\n　　112鲁班七号\n\n　　113庄周\n\n　　114刘禅\n\n　　115高渐离\n\n　　116阿轲\n\n　　117钟无艳\n\n　　118孙膑\n\n　　119扁鹊\n\n　　120白起\n\n　　121芈月\n\n　　123吕布\n\n　　124周瑜\n\n　　125庞统\n\n　　126夏侯惇\n\n　　127甄姬\n\n　　128曹操\n\n　　129典韦\n\n　　130宫本武藏\n\n　　131李白\n\n　　132马可波罗\n\n　　133狄仁杰\n\n　　134达摩\n\n　　135项羽\n\n　　136武则天\n\n　　137司马懿\n\n　　139老夫子\n\n　　140关羽\n\n　　141貂蝉\n\n　　142安琪拉\n\n　　144程咬金\n\n　　146露娜\n\n　　148姜子牙\n\n　　149刘邦\n\n　　150韩信\n\n　　152王昭君\n\n　　153兰陵王\n\n　　154花木兰\n\n　　155艾琳\n\n　　157不知火舞\n\n　　158八神庵\n\n　　162娜可露露\n\n　　163橘右京\n\n　　166亚瑟\n\n　　169后羿\n\n　　170刘备\n\n　　171张飞\n\n　　173李元芳\n\n　　174虞姬\n\n　　175钟馗\n\n　　176杨玉环\n\n　　177成吉思汗\n\n　　178杨戬\n\n　　179女娲\n\n　　180哪吒\n\n　　183雅典娜\n\n　　184蔡文姬\n\n　　186太乙真人\n\n　　187东皇太一\n\n　　189鬼谷子\n\n　　190诸葛亮\n\n　　191大乔\n\n　　192黄忠\n\n　　193铠\n\n　　194苏烈\n\n　　195百里玄策\n\n　　196百里守约\n\n　　197弈星\n\n　　198梦奇\n\n　　199公孙离\n\n　　225庞统/元歌\n\n　　237司马懿\n\n　　312沈梦溪\n\n　　382干将莫邪\n\n　　501明世隐\n\n　　502裴擒虎\n\n　　503狂铁\n\n　　504米莱狄\n\n　　505瑶\n\n　　506云中君\n\n　　507李信\n\n　　508伽罗\n\n　　509盾山\n\n　　510孙策\n\n　　511猪八戒\n\n　　513上官婉儿\n\n　　515嫦娥\n\n　　518马超\n\n　　522曜\n\n　　523西施\n\n　　524蒙犽\n\n　　525鲁班大师\n\n　　529盘古\n```\n\n> 部分参考资料自[xml-json.tk](http://xml-json.tk)\n\n用来恶搞人真好玩，哈哈\n\n{% asset_img 6.png %}\n\n# 十五、ps去掉字幕、水印\n\n示例一\n\n{% asset_img 7.png %}\n\n选区-选择-色彩范围（用吸管吸色-选择合适的容差）\n\n{% asset_img 8.png %}\n\n选择-修改-扩展（扩展合适的像素）\n\n{% asset_img 9.png %}\n\n按下快捷键shift+F5，选择内容识别，即可去掉字幕\n\n{% asset_img 10.png %}\n\n示例二\n\n{% asset_img 11.png %}\n\n选区-通道-双击红色-ctrl+l调整色阶（最右侧的是控制亮色，最左侧的是控制暗色）\n\n{% asset_img 12.png %}\n\n具体看这个\n\n{% asset_img 13.png %}","tags":["life"]},{"title":"测试","url":"/blog/2019/test/","content":"\n测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测\n\n<!--more-->\n\n# 测试标题1\n\n## 测试标题2\n\n### 测试标题3\n\n#### 测试标题4\n\n##### 测试标题5\n\n###### 测试标题6\n\n\n\n<u>测试下划线</u>\n\n\n\nfafaf**测试加粗**fafaffaf\n\nfafa*测试倾斜*fafafa\n\n* 测试无序1\n* 测试无序2\n* 测试无序3\n\n1. 测试有序1\n2. 测试有序2\n3. 测试有序3\n\n> 测试引用\n\n\n\n[<u>测试链接</u>](https://meethigher.top/)\n\n```java\n//测试代码块\npublic Person {\n    private String name;\n    public String getName(){\n        return this.name;\n    }\n    public void setName(String name){\n        this.name=name;\n    }\n}\n```\n\n\n\n| 测试表格 | 测试表格 | 测试表格 |\n| :------: | :------: | :------: |\n| 测试表格 | 测试表格 | 测试表格 |\n| 测试表格 | 测试表格 | 测试表格 |\n| 测试表格 | 测试表格 | 测试表格 |\n\n`测试关键字`\n\n==测试高亮==\n\n测试图片![]( https://meethigher.top/media/壁纸6.jpg )\n\n测试普通\n\n```java\nfljaljfalfj\n    jljlj\n```\n\n","tags":["hexo"]},{"title":"线程","url":"/blog/2019/thread/","content":"\n有关线程的一系列知识点\n\n<!--more-->\n\n#  第一章 多线程\n\n我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？\n\n要解决上述问题,咱们得使用多进程或者多线程来解决.\n\n## 1.1 并发与并行\n\n* **并发**：指两个或多个事件在**同一个时间段内**发生。交替执行，就相当于一个人吃俩馒头，这个吃一口，那个吃一口，效率低。\n* **并行**：指两个或多个事件在**同一时刻**发生。同时执行，两个人吃两个馒头，效率高。\n\n{% asset_img 并行与并发.png 并行与并发 %}\n\n在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。\n\n而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核 越多，并行处理的程序越多，能大大的提高电脑运行的效率。\n\n> 注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。\n\n## 1.2 线程与进程\n\n介绍进程与线程之前，先来介绍一下cpu。\n\ncpu：中央处理器，对数据进行计算，指挥电脑中的软件和硬件干活\n\ncpu分类：\n\n* AMD\n* Intel：见博客intel命名规则\n\n进程与线程：\n\n* **进程**：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。\n\n* **线程**：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 \n\n  简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 \n\n我们可以再电脑底部任务栏，右键----->打开任务管理器,可以查看当前任务的进程：\n\n**进程**\n\n{% asset_img 进程概念.png 进程概念 %}\n\n**线程**\n\n{% asset_img 线程概念.png 线程概念 %}\n\n**线程调度:**\n\n- 分时调度\n\n  所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。\n\n- 抢占式调度\n\n  优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，**Java使用的为抢占式调度。**\n\n  - 设置线程的优先级\n    {% asset_img 设置线程优先级.png 设置线程优先级 %}\n\n  - 抢占式调度详解\n\n    大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。\n\n    实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。\n    其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。\n\n    {% asset_img 抢占式调度.png 抢占式调度 %}\n\n## 1.3 利用Thread类的子类创建线程\n\nJava使用`java.lang.Thread`类代表**线程**，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来**创建**并**启动多线程**的步骤如下：\n\n1. 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。\n2. 创建Thread子类的实例，即创建了线程对象\n3. 调用线程对象的start()方法来启动该线程\n\n多线程原理-随机打印结果\n\n{% asset_img 多线程原理.png 多线程原理 %}\n\n程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用mt的对象的start方法，另外一个新的线程也就启动了，这样，整个线程就在多线程下运行。\n\n通过这张图我们可以很清晰的看到多线程的执行流程，那么为什么可以完成并发执行（多核下可以并行执行，单核只能并发执行）呢？\n\n多线程执行是，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。\n\n多线程原理-内存图解\n\n{% asset_img 栈内存原理图.png 栈内存原理图 %}\n\n当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么线程也就结束了。\n\n代码如下：\n\n测试类：\n\n~~~java\npublic class Demo01 {\n\tpublic static void main(String[] args) {\n\t\t//创建自定义线程对象\n\t\tMyThread mt = new MyThread(\"新的线程！\");\n\t\t//开启新线程\n\t\tmt.start();\n\t\t//在主方法中执行for循环\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tSystem.out.println(\"main线程！\"+i);\n\t\t}\n\t}\n}\n~~~\n\n自定义线程类：\n\n~~~java\npublic class MyThread extends Thread {\n\t//定义指定线程名称的构造方法\n\tpublic MyThread(String name) {\n\t\t//调用父类的String参数的构造方法，指定线程的名称\n\t\tsuper(name);\n\t}\n\t/**\n\t * 重写run方法，完成该线程执行的逻辑\n\t */\n\t@Override\n\tpublic void run() {\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tSystem.out.println(getName()+\"：正在执行！\"+i);\n\t\t}\n\t}\n}\n~~~\n\n## 1.4 利用Runnable接口对象创建线程\n\n**实现步骤：**\n\n1. 创建一个Runnable接口的子类\n2. 在实现类中重写Runnable接口的run方法\n3. 创建Runnable实现类的对象\n4. 创建Thread类的对象，构造方法中传递Runnable实现类的对象\n5. 调用Thread类中的start方法，开启新的线程\n\n**代码实现：**\n\n```java\nclass RunnableImpl implements Runnable {\n\n\t@Override\n\tpublic void run() {\n\t\tfor(int i=0;i<20;i++) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"-->\"+i);\n\t\t}\n\t}\n\t\n}\nclass RunnableImpl1 implements Runnable{\n\n\t@Override\n\tpublic void run() {\n\t\tfor(int i=0;i<20;i++) {\n\t\t\tSystem.out.println(\"hello world\");\n\t\t}\n\t}\n\t\n}\npublic class Demo02Runnable {\n\tpublic static void main(String[] args) {\n\t\tRunnableImpl impl=new RunnableImpl();\n//\t\tThread t=new Thread(impl);//输出结果中打印线程名称\n\t\t\n\t\tThread t=new Thread(new RunnableImpl1());//输出结果打印helloworld \n\t\t\n\t\t\n\t\tt.start();\n\t\tfor(int i=0;i<20;i++) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"-->\"+i);\n\t\t}\n\t\t//两个线程会抢夺资源，顺序不一定\n\t}\n}\n\n```\n\n\n\n## 1.5 Thread和Runnable的区别\n\n如果一个类继承Thread，则不适合资源共享。但是如果实现了Runnable接口的话，则很容易的实现资源共享。\n\n实现Runnable接口创建多线程的好处\n\n1. 避免了单继承的局限性\n   一个类只能继承一个类（一个儿子只能有一个亲爹），类继承了Thread接口就不能继承其他的类。\n   实现了Runnable接口，还能继承其他的类，实现其他的接口\n\n2. 增强了程序的可扩展性，降低了程序的耦合性（也叫解耦）\n\n   实现Runnable接口的方式，把设置线程任务和开启新线程进行了分离，即解耦。\n\n   实现类中，重写run方法：用来设置线程任务。\n\n   创建Thread类对象，调用start方法：用来开启新线程\n\n> 补充：在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个jvm，每一个jvm其实就是在操作系统中启动了一个进程。\n\n## 1.6 匿名内部类方式实现线程的创建\n\n匿名：没有名字\n\n内部类：写在其他类内部的类\n\n匿名内部类的作用：简化代码\n\n1. 把子类继承父类，重写父类的方法；创建子类对象，合成一步完成。\n2. 把实现类实现接口，重写接口中的方法；创建实现类对象，合成一步完成。\n\n匿名内部类最终产物：\n\n子类/实现类对象。而这个类他没有名字，所以叫匿名内部类\n\n格式：\n\n```java\nnew 父类/接口 （）{\n    括号中重写父类/接口中的方法\n}\n```\n\n代码演示：\n\n```java\npublic class Demo04InnerClassThread {\n\tpublic static void main(String[] args) {\n\t\t// 线程的父类是Thread\n\t\tnew Thread() {\n\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\tfor (int i = 0; i < 20; i++) {\n\t\t\t\t\tSystem.out.println(Thread.currentThread().getName() + \"Thread\" + i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}.start();\n\t\t// 实现接口\n\t\t//使用多态\n//\t\tRunnable r=new Runnable() {\n//\n//\t\t\t@Override\n//\t\t\tpublic void run() {\n//\t\t\t\t// TODO Auto-generated method stub\n//\t\t\t\t\n//\t\t\t}\n//\t\t\t\n//\t\t};\n//\t\t//上面那个相当于Runnable r=new RunnableImpl();\n\t\tnew Thread(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tfor (int i = 0; i < 20; i++) {\n\t\t\t\t\tSystem.out.println(Thread.currentThread().getName() + \"Runnable\" + i);\n\t\t\t\t}\n\t\t\t}\n\t\t}).start();\n\t}\n}\n\n```\n\n\n\n# 第二章 线程安全\n\n## 2.1 线程安全\n\n就比方说，电影院卖票。\n\n一共100张票，如果一个窗口（单线程）卖的话，不会出现问题。单线程程序是不会出现线程安全问题的。\n\n如果多线程，一号窗口卖票1-33，二号窗口卖票34-66，三号卖票67-100，也不会出现问题。多线程程序，如果没有访问共享数据，也不会产生问题。\n\n如果多线程，都是卖1-100号票。如果三个窗口卖的是同一张票，就会出现**线程安全问题**——多线程访问了共享的数据，会产生线程安全问题。\n\n下面来模拟电影院售票\n\n```java\npackage demo28;\n\n//实现卖票案例\nclass RunnableImpl implements Runnable {\n\n\t// 定义一个多线程共享的票源\n\tprivate int ticket = 5;\n\n\t// 设置线程任务：卖票\n\t@Override\n\tpublic void run() {\n\t\t// 使用死循环让卖票操作重复执行\n\t\twhile (true) {\n\t\t\t// 先判断票是否存在\n\t\t\tif (ticket > 0) {\n\t\t\t\t// 提高安全问题出现的概率，让程序睡眠\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(10);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\t// 票存在，卖票，票--\n\t\t\t\tSystem.out.println(Thread.currentThread().getName() + \"-->\" + (ticket--) + \"张票\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"票已经卖完了！\");\n\t\t\t\tbreak;\n\n\t\t\t}\n\t\t}\n\t}\n\n}\n\npublic class Demo01 {\n\tpublic static void main(String[] args) {\n\t\t// 模拟卖票，创建3个线程，同时开启，对共享的票进行出售\n\n\t\t// 创建Runnable接口的实现类对象\n\t\tRunnableImpl r = new RunnableImpl();\n\t\t// 创建Thread方法，构造方法中传递RunnableImpl\n\t\tThread t0 = new Thread(r);\n\t\tThread t1 = new Thread(r);\n\t\tThread t2 = new Thread(r);\n\t\t// 调用start方法开启多线程\n\t\tt0.start();\n\t\tt1.start();\n\t\tt2.start();\n\t\t// 三个线程用了同一个Runnable实现类，所以不会出现线程安全问题\n\n\t}\n}\n\n```\n\n出现了线程安全问题——出现了重复的票，和不存在的票。\n\n那么，是怎么产生的呢？\n\n**出现不存在的票的**\n\n开启了三个线程，三个线程 t0,t1,t2 一起抢夺cpu的执行权，谁抢到谁执行。\n\nt0线程抢到了cpu的执行权，进入到run方法中执行；执行到if语句，sleep，就失去了cpu的执行权。\n\nt2线程也抢到了cpu的执行权，进入到run方法中执行；执行到if语句，sleep，就是去了cpu的执行权。\n\nt1线程也抢到了cpu的执行权，进入到run方法中执行；执行到if语句，sleep，就是去了cpu的执行权\n\nt2睡眠结束，抢到了cpu的执行权，继续执行卖票。正在卖第1张电影票，此时执行--运算。那么ticket就成了0。继续判断0>0，不满足，然后终止执行。\n\nt1睡眠结束，抢到了cpu的执行权，继续执行卖票。正在卖第0张电影票，此时执行--运算。那么ticket就成了-1。继续判断，不满足，然后终止执行。\n\nt0睡眠结束，抢到了cpu的执行权，继续执行卖票。正在卖第-1张电影票，此时执行--运算。那么ticket就成了-2。继续判断，不满足，然后终止执行。\n\n**出现重复的票**\n\nt0,t1,t2同时在执行，正在卖ticket张票，假设此时ticket=100。但是此时，ticket都还没有执行--操作，所以就会出现了重复的票。\n\n> 注意：这种线程安全是不能产生的。我们可以让一个线程在访问共享数据的时候，无论是否失去了cpu的执行权，其他线程只能等待。等待当前线程卖票结束，其他线程再进行卖票，就ok了。\n\n## 2.2 线程同步\n\n出现了线程安全问题，那么，如何解决呢？\n\n为了保证每个线程都能正常执行原子操作，java引入了线程同步机制。\n\n那么怎么去使用呢？有三种方式完成同步操作：\n\n1. 同步代码块\n2. 同步方法\n3. 锁机制\n\n## 2.3 解决方法一：同步代码块\n\n解决线程安全问题的第一种方式：同步代码块\n\n卖票案例出现了线程安全问题，出现了重复的票和不存在的票。\n\n可以通过同步代码块解决这个问题。\n\n格式：\n\n```java\nsysnchronized(锁对象){\n    //会出现线程安全问题的代码（访问了共享数据的代码）\n}\n```\n\n> 格式：1. 同步代码块中的锁对象，可以使任意的对象。2.必须保证多个线程使用的锁对象是同一个。3.锁对象的作用：把同步代码块锁住，只让一个线程在同步代码块中执行。\n\n代码演示：\n\n```java\nclass RunnableImpl1 implements Runnable {\n\n\t// 定义一个多线程共享的票源\n\tprivate int ticket = 5;\n\n\t// 创建一个锁对象。要放在外面，如果放在run方法内，每次执行run方法，都会创建一个锁对象，就不能保证唯一了。\n\tObject obj = new Object();\n\n\t// 设置线程任务：卖票\n\t@Override\n\tpublic void run() {\n\t\t// 使用死循环让卖票操作重复执行\n\t\twhile (true) {\n\t\t\t// 同步代码块，保证只让一个线程在代码块中执行\n\t\t\tsynchronized (obj) {\n\t\t\t\t// 先判断票是否存在\n\t\t\t\tif (ticket > 0) {\n\t\t\t\t\t// 提高安全问题出现的概率，让程序睡眠\n\t\t\t\t\ttry {\n\t\t\t\t\t\tThread.sleep(10);\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t\t// 票存在，卖票，票--\n\t\t\t\t\tSystem.out.println(Thread.currentThread().getName() + \"-->\" + (ticket--) + \"张票\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"票已经卖完了！\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\npublic class Demo02Synchronized {\n\tpublic static void main(String[] args) {\n\t\t// 模拟卖票，创建3个线程，同时开启，对共享的票进行出售\n\n\t\t// 创建Runnable接口的实现类对象\n\t\tRunnableImpl1 r = new RunnableImpl1();\n\t\t// 创建Thread方法，构造方法中传递RunnableImpl\n\t\tThread t0 = new Thread(r);\n\t\tThread t1 = new Thread(r);\n\t\tThread t2 = new Thread(r);\n\t\t// 调用start方法开启多线程\n\t\tt0.start();\n\t\tt1.start();\n\t\tt2.start();\n\t\t// 三个线程用了同一个Runnable实现类，所以不会出现线程安全问题\n\t}\n}\n```\n\n同步技术的原理：\n\n使用了一个锁对象，这个锁对象叫做同步锁，也叫**对象锁**，也叫**对象监视器**。\n\n3个线程一起抢夺cpu的执行权。\n\nt0抢到了cpu的执行权，执行run方法。会遇到synchronized同步代码块，这是t0会检查同步代码块是否有锁对象。发现有，就会获取到锁对象，进入到同步中执行 。\n\nt1抢到了cpu的执行权，执行run方法。会遇到synchronized同步代码块，这是t1会检查同步代码块是否有锁对象。发现没有，t1就会进入到阻塞状态，一直等待t0线程归还锁对象，一直到t0线程执行完同步中的代码，会把锁对象归还给同步代码块，t1才能获取到锁对象，进入到同步中执行。\n\n> 总结：同步中的线程，没有执行完毕，不会释放锁。同步外的线程，没有锁进不去同步。\n\n同步保证了只能有一个线程在同步中执行共享数据。\n\n保证了安全。\n\n程序的频繁的判断锁，获取锁，释放锁，程序的效率会降低。\n\n## 2.4 解决方法二：同步方法\n\n解决线程安全问题的第二种方式：同步方法\n\n使用步骤：\n\n1. 把访问了共享数据的代码抽取出来，放到一个方法中。\n2. 在方法上添加synchronzed修饰符\n\n格式：\n\n```java\n修饰符 synchronized 返回值类型 方法名（参数列表）{\n    //可能会出现线程安全问题的代码（访问了共享数据的代码）\n}\n```\n\n定义一个同步方法\n\n同步方法也会把方法内部的代码锁住\n\n只让一个线程执行\n\n那么，同步方法的锁对象是谁？\n\n就是实现类对象new RunnableImpl2，也就是this\n\n下面代码演示一下：\n\n```java\nclass RunnableImpl2 implements Runnable {\n\tprivate int ticket = 5;\n\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(this);\n\t\twhile(true) {\n\t\t\tpayTicket();\n\t\t}\n\t}\n\tpublic synchronized void payTicket() {\n\t\tif(ticket>0) {\n\t\t\tSystem.out.println(Thread.currentThread().getName() + \"-->\" + (ticket--) + \"张票\");\n\t\t}else {\n\t\t\tSystem.exit(0);\n\t\t}\n\t}\n\t\n}\n\npublic class Demo03SynchronizedMethod {\n\tpublic static void main(String[] args) {\n\t\tRunnableImpl2 r = new RunnableImpl2();\n\t\tSystem.out.println(\"main-->\"+r);\n\t\tThread t0 = new Thread(r);\n\t\tThread t1 = new Thread(r);\n\t\tThread t2 = new Thread(r);\n\t\n\t\tt0.start();\n\t\tt1.start();\n\t\tt2.start();\n\t}\n}\n\n```\n\n输出的结果：\n\n```java\nmain-->demo28.RunnableImpl2@68de145\ndemo28.RunnableImpl2@68de145\nThread-0-->5张票\ndemo28.RunnableImpl2@68de145\nThread-2-->4张票\nThread-2-->3张票\nThread-2-->2张票\nThread-2-->1张票\n```\n\n验证一下，直接将同步代码块中传入this对象\n\n```java\nclass RunnableImpl2 implements Runnable {\n\tprivate int ticket = 5;\n\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(this);\n\t\twhile(true) {\n\t\t\tpayTicket();\n\t\t}\n\t}\n\tpublic void payTicket() {\n\t\tsynchronized (this) {\n\t\t\tSystem.out.println(this);\n\t\t\tif(ticket>0) {\n\t\t\t\tSystem.out.println(Thread.currentThread().getName() + \"-->\" + (ticket--) + \"张票\");\n\t\t\t}else {\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\npublic class Demo03SynchronizedMethod {\n\tpublic static void main(String[] args) {\n\t\tRunnableImpl2 r = new RunnableImpl2();\n\t\tSystem.out.println(\"main-->\"+r);\n\t\tThread t0 = new Thread(r);\n\t\tThread t1 = new Thread(r);\n\t\tThread t2 = new Thread(r);\n\t\n\t\tt0.start();\n\t\tt1.start();\n\t\tt2.start();\n\t}\n}\n```\n\n同样也能保证线程安全。\n\n> 如果把同步方法改成静态同步方法，那么相应的变量也要改成静态变量。\n>\n> 静态的锁对象，不能是this，this是创建对象之后产生的，静态方法优先于对象。\n>\n> 静态方法的锁对象是本类的class属性---->class文件对象（反射中会提到）\n>\n> 解决方法：将锁对象改为RunnableImpl.class即可\n\n下面给出例子\n\n```java\n...\n\tpublic static void payTicket() {\n\t\tsynchronized (RunnableImpl3.class) {//静态方法中用this就会报错了\n\t\t\tif(ticket>0) {\n\t\t\t\tSystem.out.println(Thread.currentThread().getName() + \"-->\" + (ticket--) + \"张票\");\n\t\t\t}else {\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t}\n\t}\n...\n```\n\n## 2.5 解决方法三：Lock锁\n\n解决线程安全问题的第三种方式：Lock锁\n\njava.util.concurrent.locks \n接口 Lock\n\n`Lock` 实现提供了比使用 `synchronized`  方法和语句可获得的更广泛的锁定操作。此实现允许更灵活的结构，可以具有差别很大的属性，可以支持多个相关的 `Condition` 对象。\n\nLock接口中的方法，lock和unlock，一个用来获取锁，一个用来释放锁\n\nLock接口的实现类：ReentrantLock\n\n使用步骤：\n\n1. 在成员位置创建一个ReentrantLock对象\n2. 在可能出现线程安全问题的代码前，调用Lock接口中的lock方法，让他获取锁。\n3. 在可能出现线程安全问题的代码后，调用Lock接口中的unlock方法，让他释放锁。\n\n```java\n@Override\n\tpublic void run() {\n\t\twhile(true) {\n\t\t\tl.lock();\n\t\t\tif(ticket>0) {\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(10);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tSystem.out.println(Thread.currentThread().getName()+\"正在卖出第\"+ticket--+\"张票\");\n\t\t\t}else {\n\t\t\t\tSystem.out.println(\"票卖完了\");\n\t\t\t\tSystem.exit(0);\n\t\t\t} \n\t\t\tl.unlock();\n\t\t}\n\t\t\n\t}\n```\n\n养成个好点的习惯\n\n```java\nl.lock();\ntry{\n    //todo\n}catch(){\n    //todo\n}finally{\n   l.unlock();//无论程序是否异常，都会释放锁对象，这样可以提高程序的效率 \n}\n```\n\n\n\n# 第三章 线程状态\n\n## 3.1 线程状态概述\n\n线程状态，线程可以处于下列状态之一：\n\n`NEW`:至今尚未启动的线程处于这种状态。\n\n`RUNNABLE`:正在java虚拟机中执行的线程处于这种状态\n\n`BLOCKED`:受阻塞并等待某个监视器锁的线程处于这种状态。\n\n`WAITING`:无限期地等待另一个线程来执行某一特定操作的线程处于这种状态。\n\n`TIMED_WAITING`:等待另一个线程来执行取决于指定等待时间的操作的线程处于这种状态。\n\n`TERMINATED`:已退出的线程处于这种状态。\n\n## 3.2 Timed Waiting（计时等待）\n\n{% asset_img 计时等待.png 计时等待 %}\n\n代码演示：\n\n```java\npublic class MyThread extends Thread {\n    public void run(){\n        for(int i=0;i<100;i++){\n            System.out.println(\"-----------\"+i);\n            try{\n                Thread.sleep(1000);\n                System.out.println(\"线程睡眠1秒\");\n            }catch(Exception e){\n                e.printStackTrace();\n            }\n        }\n    }\n    public static void main(String[] args){\n        new MyThread().start();\n    }\n}\n```\n\n通过案例可以发现，sleep方法的使用比较简单，但是还有几个注意点：\n\n1. 进入`TIMED_WAITING`状态的一种常见情形调用的sleep方法，单独的线程也可以调用，不一定非要有协作关系。\n2. 为了让其他线程有机会执行，可以将Thread.sleep()的调用放线程run()之内。这样才能保证该线程执行过程中会睡眠。\n3. sleep与锁无关，线程睡眠到期自动苏醒，并返回到Runnable（可运行）状态。\n\n> sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始立刻执行。\n\n## 3.3 BLOCKED（锁阻塞）\n\n受阻塞并且正在等待监视器锁的某一线程的线程状态。处于受阻塞状态的某一线程正在等待监视器锁，以便进入一个同步的块/方法，或者在调用 Object.wait 之后再次进入同步的块/方法。 \n\n{% asset_img 锁阻塞.png 锁阻塞 %}\n\n## 3.4 Waiting（无限等待）\n\n某一等待线程的线程状态。某一线程因为调用下列方法之一而处于等待状态： \n\n* 不带超时值的 Object.wait \n\n* 不带超时值的 Thread.join \n\n* LockSupport.park \n\n处于等待状态的线程正等待另一个线程，以执行特定操作。 例如，已经在某一对象上调用了 Object.wait() 的线程正等待另一个线程，以便在该对象上调用 Object.notify() 或 Object.notifyAll()。已经调用了 Thread.join() 的线程正在等待指定线程终止。 \n\n进入到TimedWaiting（计时等待）有两种方式\n\n1. 使用sleep(Long millis)方法，在毫秒值结束之后，线程睡醒，进入到Runnable/Blocked状态。\n2. 使用wait(Long m)方法，wait方法如果在毫秒值结束之后，还没有被notify，就会自动唤醒。\n\n{% asset_img 无限等待.png 无限等待 %}\n\n## 3.5 案例\n\n等待唤醒案例：线程之间的通信\n\n创建一个顾客线程（消费者）：告知老板要的包子的种类和数量，调用wait方法，放弃cpu的执行，进入到waiting状态（无限等待状态）\n\n创建一个老板线程（生产者）：花了5秒做包子，做好包子之后，调用notify方法，唤醒顾客吃包子。\n\n注意事项：\n\n1. 顾客和老板线程，必须使用同步代码块包裹起来。保证等待和唤醒只能有一个在执行。\n2. 同步使用的锁对象，必须保证是唯一的。只有锁对象才能调用wait和notify方法一个\n\n一个顾客一个老板：\n\n\n```java\npublic class Demo01WaitAndNotify {\n\tpublic static void main(String[] args) {\n\t\t//创建锁对象，保证锁对象唯一\n\t\tObject obj=new Object();\n\t\t//创建一个顾客线程（消费者）\n\t\tnew Thread() {\n\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\twhile(true) {\n\t\t\t\t\t//保证等待和唤醒的线程只能有一个执行，需要使用同步技术\n\t\t\t\t\tsynchronized(obj) {\n\t\t\t\t\t\tSystem.out.println(\"告知老板要的包子的种类和数量\");\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tobj.wait();\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//唤醒之后执行的代码\n\t\t\t\t\t\tSystem.out.println(\"包子已经做好了，开吃！\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}.start();\n\t\t//创建一个老板线程（生产者）\n\t\tnew Thread() {\n\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\twhile(true) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tThread.sleep(2000);\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t\tsynchronized(obj) {\n\t\t\t\t\t\tSystem.out.println(\"老板花5s时间做包子\");\n\t\t\t\t\t\tobj.notify();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}.start();\n\t}\n}\n\n```\n\n多个顾客，一个老板：\n\n```java\npublic class Demo02WaitAndNotify {\n\tpublic static void main(String[] args) {\n\t\t// 创建锁对象，保证锁对象唯一\n\t\tObject obj = new Object();\n\t\t// 创建一个顾客线程（消费者）\n\t\tnew Thread() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\twhile (true) {\n\t\t\t\t\t// 保证等待和唤醒的线程只能有一个执行，需要使用同步技术\n\t\t\t\t\tsynchronized (obj) {\n\t\t\t\t\t\tSystem.out.println(\"顾客1告知老板要的包子的种类和数量\");\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tobj.wait();\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 唤醒之后执行的代码\n\t\t\t\t\t\tSystem.out.println(\"顾客1的包子已经做好了，顾客1开吃！\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}.start();\n\t\tnew Thread() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\twhile (true) {\n\t\t\t\t\t// 保证等待和唤醒的线程只能有一个执行，需要使用同步技术\n\t\t\t\t\tsynchronized (obj) {\n\t\t\t\t\t\tSystem.out.println(\"顾客2告知老板要的包子的种类和数量\");\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tobj.wait();\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 唤醒之后执行的代码\n\t\t\t\t\t\tSystem.out.println(\"顾客2包子已经做好了，顾客2开吃！\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}.start();\n\t\tnew Thread() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\twhile (true) {\n\t\t\t\t\t// 保证等待和唤醒的线程只能有一个执行，需要使用同步技术\n\t\t\t\t\t//制作包子需要2s\n\t\t\t\t\ttry {\n\t\t\t\t\t\tThread.sleep(2000);\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t\tsynchronized (obj) {\n\t\t\t\t\t\tSystem.out.println(\"包子已经做好了\");\n//\t\t\t\t\t\tobj.notify();//一次只能唤醒一个进程，如果有多个等待进程，随机唤醒一个\n\t\t\t\t\t\tobj.notifyAll();//一次唤醒多个进程\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}.start();\n\t}\n}\n\n```\n\n\n\n## 3.6 补充知识点\n\n{% asset_img 线程状态图.png 线程状态图 %}\n\n>  一条有意思的tips: 我们在翻阅API的时候会发现Timed Waiting（计时等待） 与 Waiting（无限等待） 状态联系还是很紧密的， 比如Waiting（无限等待） 状态中wait方法是空参的，而timed waiting（计时等待） 中wait方法是带参的。 这种带参的方法，其实是一种倒计时操作，相当于我们生活中的小闹钟，我们设定好时间，到时通知，可是 如果提前得到（唤醒）通知，那么设定好时间在通知也就显得多此一举了，那么这种设计方案其实是一举两 得。如果没有得到（唤醒）通知，那么线程就处于Timed Waiting状态,直到倒计时完毕自动醒来；如果在倒 计时期间得到（唤醒）通知，那么线程从Timed Waiting状态立刻唤醒。 \n\n# 第四章 等待唤醒机制\n\n## 4.1 线程间通信\n\n**概念：**多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。\n\n比如：线程A用来生成包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，那么线程A与线程B之间就存在线程通信问题。\n\n{% asset_img 线程间通信.png 线程间通信 %}\n\n**为什么要处理线程间通信：**\n\n多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。\n\n**如何保证线程间通信有效利用资源：**\n\n多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即—— **等待唤醒机制。**\n\n## 4.2 等待唤醒机制\n\n**什么是等待唤醒机制**\n\n这是多个线程间的一种**协作**机制。谈到线程我们经常想到的是线程间的**竞争（race）**，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就好比在公司里你和你的同事们，你们可能存在在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。\n\n就是在一个线程进行了规定操作后，就进入等待状态（**wait()**）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（**notify()**）;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。\n\nwait/notify 就是线程间的一种协作机制。\n\n**等待唤醒中的方法**\n\n等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下：\n\n1. wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个**特别的动作**，也即是“**通知（notify）**”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中\n2. notify：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。\n3. notifyAll：则释放所通知对象的 wait set 上的全部线程。\n\n>注意：\n>\n>哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。\n>\n>总结如下：\n>\n>- 如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态；\n>- 否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态\n\n**调用wait和notify方法需要注意的细节**\n\n1. wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。\n2. wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。\n3. wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。\n\n## 4.3 生产者与消费者问题\n\n等待唤醒机制其实就是经典的“生产者与消费者”的问题。\n\n就拿生产包子消费包子来说等待唤醒机制如何有效利用资源：\n\n~~~java\n包子铺线程生产包子，吃货线程消费包子。当包子没有时（包子状态为false），吃货线程等待，包子铺线程生产包子（即包子状态为true），并通知吃货线程（解除吃货的等待状态）,因为已经有包子了，那么包子铺线程进入等待状态。接下来，吃货线程能否进一步执行则取决于锁的获取情况。如果吃货获取到锁，那么就执行吃包子动作，包子吃完（包子状态为false），并通知包子铺线程（解除包子铺的等待状态）,吃货线程进入等待。包子铺线程能否进一步执行则取决于锁的获取情况。\n~~~\n\n### 案例\n\n#### 资源类\n\n包子类\n\n设置包子的属性：皮、馅、包子的状态（有true，无false）\n\n```java\npublic class BaoZi {\n\tString pi;\n\tString xian;\n\tboolean flag=false;\n}\n```\n\n\n\n#### 生产者类\n\n包子铺类（是一个线程类，可以继承Thread）\n\n设置线程任务（run）:生产包子\n\n对包子的状态进行判断\n\n* true为有包子，包子铺调用wait方法进入等待状态\n* false是没有包子，包子铺生产包子，修改包子的状态为true，唤醒吃货线程吃包子\n\n```java\npublic class BaoZiPu extends Thread {\n\tprivate BaoZi bz;\n\n\tpublic BaoZiPu(BaoZi bz) {\n\t\tthis.bz = bz;\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\tint count = 0;\n\t\twhile (true) {\n\t\t\tsynchronized (bz) {\n\t\t\t\tif (bz.flag) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tbz.wait();\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// 线程被唤醒之后，生产包子\n\t\t\t\tif (count % 2 == 0) {\n\t\t\t\t\tbz.pi = \"薄皮\";\n\t\t\t\t\tbz.xian = \"人肉馅\";\n\t\t\t\t} else {\n\t\t\t\t\tbz.pi = \"冰皮\";\n\t\t\t\t\tbz.xian = \"狗肉馅\";\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t\tSystem.out.println(\"包子铺正在生产\" + bz.pi + bz.xian + \"的包子\");\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tbz.flag = true;\n\t\t\t\tbz.notify();\n\t\t\t\tSystem.out.println(bz.pi + bz.xian + \"的包子生产好了\");\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n```\n\n\n\n#### 消费者类\n\n吃货类，是一个线程类，可以继承Thread\n\n设置线程任务（run）:吃包子\n\n对包子的状态进行判断\n\n* false没有包子，吃货线程调用wait方法进入等待状态\n* true有包子，吃货吃包子，吃货吃完包子，修改包子的状态为false\n\n```java\npublic class ChiHuo extends Thread {\n\tprivate BaoZi bz;\n\n\tpublic ChiHuo(BaoZi bz) {\n\t\tsuper();\n\t\tthis.bz = bz;\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\twhile(true) {\n\t\t\tsynchronized(bz) {\n\t\t\t\tif(!bz.flag) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tbz.wait();\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}//线程被唤醒之后，吃包子\n\t\t\t\tSystem.out.println(\"吃货正在吃\"+bz.pi+bz.xian+\"的包子\");\n\t\t\t\tbz.flag=false;\n\t\t\t\tbz.notify();\n\t\t\t\tSystem.out.println(bz.pi+bz.xian+\"包子已经吃完了，包子铺赶紧生产包子\");\n\t\t\t\tSystem.out.println(\"-------------------------------------\");\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n```\n\n\n\n#### 测试类\n\n包含main方法，程序执行的入口，启动程序。\n\n创建包子对象\n\n创建包子铺线程，开启\n\n创建吃货线程，开启\n\n```java\npublic class Demo01Practice {\n\tpublic static void main(String[] args) {\n\t\t BaoZi bz=new BaoZi();\n\t\t new BaoZiPu(bz).start();\n\t\t new ChiHuo(bz).start();\n\t}\n}\n```\n\n#### 运行结果\n\n```java\n包子铺正在生产薄皮人肉馅的包子\n薄皮人肉馅的包子生产好了\n吃货正在吃薄皮人肉馅的包子\n薄皮人肉馅包子已经吃完了，包子铺赶紧生产包子\n-------------------------------------\n包子铺正在生产冰皮狗肉馅的包子\n冰皮狗肉馅的包子生产好了\n吃货正在吃冰皮狗肉馅的包子\n冰皮狗肉馅包子已经吃完了，包子铺赶紧生产包子\n-------------------------------------\n包子铺正在生产薄皮人肉馅的包子\n薄皮人肉馅的包子生产好了\n吃货正在吃薄皮人肉馅的包子\n薄皮人肉馅包子已经吃完了，包子铺赶紧生产包子\n-------------------------------------\n包子铺正在生产冰皮狗肉馅的包子\n冰皮狗肉馅的包子生产好了\n吃货正在吃冰皮狗肉馅的包子\n冰皮狗肉馅包子已经吃完了，包子铺赶紧生产包子\n-------------------------------------\n包子铺正在生产薄皮人肉馅的包子\n薄皮人肉馅的包子生产好了\n吃货正在吃薄皮人肉馅的包子\n薄皮人肉馅包子已经吃完了，包子铺赶紧生产包子\n-------------------------------------\n包子铺正在生产冰皮狗肉馅的包子\n冰皮狗肉馅的包子生产好了\n吃货正在吃冰皮狗肉馅的包子\n冰皮狗肉馅包子已经吃完了，包子铺赶紧生产包子\n-------------------------------------\n包子铺正在生产薄皮人肉馅的包子\n薄皮人肉馅的包子生产好了\n吃货正在吃薄皮人肉馅的包子\n薄皮人肉馅包子已经吃完了，包子铺赶紧生产包子\n-------------------------------------\n包子铺正在生产冰皮狗肉馅的包子\n冰皮狗肉馅的包子生产好了\n吃货正在吃冰皮狗肉馅的包子\n冰皮狗肉馅包子已经吃完了，包子铺赶紧生产包子\n-------------------------------------\n包子铺正在生产薄皮人肉馅的包子\n薄皮人肉馅的包子生产好了\n吃货正在吃薄皮人肉馅的包子\n薄皮人肉馅包子已经吃完了，包子铺赶紧生产包子\n-------------------------------------\n包子铺正在生产冰皮狗肉馅的包子\n冰皮狗肉馅的包子生产好了\n吃货正在吃冰皮狗肉馅的包子\n冰皮狗肉馅包子已经吃完了，包子铺赶紧生产包子\n-------------------------------------\n包子铺正在生产薄皮人肉馅的包子\n薄皮人肉馅的包子生产好了\n吃货正在吃薄皮人肉馅的包子\n薄皮人肉馅包子已经吃完了，包子铺赶紧生产包子\n-------------------------------------\n包子铺正在生产冰皮狗肉馅的包子\n\n```\n\n\n\n# 第五章 线程池\n\n## 5.1 线程池思想概述\n\n{% asset_img 游泳池.jpg 游泳池 %}\n\n我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：\n\n如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。\n\n那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？\n\n在Java中可以通过线程池来达到这样的效果。今天我们就来详细讲解一下Java的线程池。\n\n## 5.2 线程池概念\n\n* **线程池：**其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。\n\n由于线程池中有很多操作都是与优化资源相关的，我们在这里就不多赘述。我们通过一张图来了解线程池的工作原理：\n\n{% asset_img 线程池原理.png 线程池原理 %}\n\n合理利用线程池能够带来三个好处：\n\n1. 降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。\n2. 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。\n3. 提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。\n\n## 5.3 线程池的使用\n\nJava里面线程池的顶级接口是`java.util.concurrent.Executor`，但是严格意义上讲`Executor`并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是`java.util.concurrent.ExecutorService`。\n\n要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在`java.util.concurrent.Executors`线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors工程类来创建线程池对象。\n\nExecutors类中有个创建线程池的方法如下：\n\n* `public static ExecutorService newFixedThreadPool(int nThreads)`：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量)\n\n获取到了一个线程池ExecutorService 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下：\n\n* `public Future<?> submit(Runnable task)`:获取线程池中的某一个线程对象，并执行\n\n  > Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。\n\n使用线程池中线程对象的步骤：\n\n1. 创建线程池对象。\n2. 创建Runnable接口子类对象。(task)\n3. 提交Runnable接口子类对象。(take task)\n4. 关闭线程池(一般不做)。  \n\nRunnable实现类代码：\n\n~~~java\npublic class MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"我要一个教练\");\n        try {\n            Thread.sleep(2000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"教练来了： \" + Thread.currentThread().getName());\n        System.out.println(\"教我游泳,交完后，教练回到了游泳池\");\n    }\n}\n~~~\n\n线程池测试类：\n\n~~~java\npublic class ThreadPoolDemo {\n    public static void main(String[] args) {\n        // 创建线程池对象\n        ExecutorService service = Executors.newFixedThreadPool(2);//包含2个线程对象\n        // 创建Runnable实例对象\n        MyRunnable r = new MyRunnable();\n\n        //自己创建线程对象的方式\n        // Thread t = new Thread(r);\n        // t.start(); ---> 调用MyRunnable中的run()\n\n        // 从线程池中获取线程对象,然后调用MyRunnable中的run()\n        service.submit(r);\n        // 再获取个线程对象，调用MyRunnable中的run()\n        service.submit(r);\n        service.submit(r);\n        // 注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。\n        // 将使用完的线程又归还到了线程池中\n        // 关闭线程池\n        //service.shutdown();\n    }\n}\n~~~\n\n\n\n# 第六章 Lambda表达式\n\n## 6.1 函数式编程思想概述\n\n{% asset_img 03-Overview.png Overview %}\n\n在数学中，**函数**就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——**强调做什么，而不是以什么形式做**。\n\n**面向对象的思想:**\n\n​\t**做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.**\n\n**函数式编程思想:**\n\n​\t**只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程**\n\n## 6.2 冗余的Runnable代码\n\n### 传统写法\n\n当需要启动一个线程去完成任务时，通常会通过`java.lang.Runnable`接口来定义任务内容，并使用`java.lang.Thread`类来启动该线程。代码如下：\n\n```java\npublic class Demo01Runnable {\n\tpublic static void main(String[] args) {\n    \t// 匿名内部类\n\t\tRunnable task = new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() { // 覆盖重写抽象方法\n\t\t\t\tSystem.out.println(\"多线程任务执行！\");\n\t\t\t}\n\t\t};\n\t\tnew Thread(task).start(); // 启动线程\n\t}\n}\n```\n\n本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个`Runnable`接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。\n\n### 代码分析\n\n对于`Runnable`的匿名内部类用法，可以分析出几点内容：\n\n- `Thread`类需要`Runnable`接口作为参数，其中的抽象`run`方法是用来指定线程任务内容的核心；\n- 为了指定`run`的方法体，**不得不**需要`Runnable`接口的实现类；\n- 为了省去定义一个`RunnableImpl`实现类的麻烦，**不得不**使用匿名内部类；\n- 必须覆盖重写抽象`run`方法，所以方法名称、方法参数、方法返回值**不得不**再写一遍，且不能写错；\n- 而实际上，**似乎只有方法体才是关键所在**。\n\n## 6.3 编程思想转换\n\n### 做什么，而不是怎么做\n\n我们真的希望创建一个匿名内部类对象吗？不。我们只是为了做这件事情而**不得不**创建一个对象。我们真正希望做的事情是：将`run`方法体内的代码传递给`Thread`类知晓。\n\n**传递一段代码**——这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。那，有没有更加简单的办法？如果我们将关注点从“怎么做”回归到“做什么”的本质上，就会发现只要能够更好地达到目的，过程与形式其实并不重要。\n\n### 生活举例\n\n{% asset_img 01-交通方式.png 交通方式 %}\n\n当我们需要从北京到上海时，可以选择高铁、汽车、骑行或是徒步。我们的真正目的是到达上海，而如何才能到达上海的形式并不重要，所以我们一直在探索有没有比高铁更好的方式——搭乘飞机。\n\n{% asset_img 02-Lambda.png Lambda %}\n\n而现在这种飞机（甚至是飞船）已经诞生：2014年3月Oracle所发布的Java 8（JDK 1.8）中，加入了**Lambda表达式**的重量级新特性，为我们打开了新世界的大门。\n\n## 6.4 体验Lambda的更优写法\n\n借助Java 8的全新语法，上述`Runnable`接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效：\n\n```java\npublic class Demo02LambdaRunnable {\n\tpublic static void main(String[] args) {\n\t\tnew Thread(() -> System.out.println(\"多线程任务执行！\")).start(); // 启动线程\n\t}\n}\n```\n\n这段代码和刚才的执行效果是完全一样的，可以在1.8或更高的编译级别下通过。从代码的语义中可以看出：我们启动了一个线程，而线程任务的内容以一种更加简洁的形式被指定。\n\n不再有“不得不创建接口对象”的束缚，不再有“抽象方法覆盖重写”的负担，就是这么简单！\n\n## 6.5 回顾匿名内部类\n\nLambda是怎样击败面向对象的？在上例中，核心代码其实只是如下所示的内容：\n\n```java\n() -> System.out.println(\"多线程任务执行！\")\n```\n\n为了理解Lambda的语义，我们需要从传统的代码起步。\n\n### 使用实现类\n\n要启动一个线程，需要创建一个`Thread`类的对象并调用`start`方法。而为了指定线程执行的内容，需要调用`Thread`类的构造方法：\n\n* `public Thread(Runnable target)`\n\n为了获取`Runnable`接口的实现对象，可以为该接口定义一个实现类`RunnableImpl`：\n\n```java\npublic class RunnableImpl implements Runnable {\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(\"多线程任务执行！\");\n\t}\n}\n```\n\n然后创建该实现类的对象作为`Thread`类的构造参数：\n\n```java\npublic class Demo03ThreadInitParam {\n\tpublic static void main(String[] args) {\n\t\tRunnable task = new RunnableImpl();\n\t\tnew Thread(task).start();\n\t}\n}\n```\n\n### 使用匿名内部类\n\n这个`RunnableImpl`类只是为了实现`Runnable`接口而存在的，而且仅被使用了唯一一次，所以使用匿名内部类的语法即可省去该类的单独定义，即匿名内部类：\n\n```java\npublic class Demo04ThreadNameless {\n\tpublic static void main(String[] args) {\n\t\tnew Thread(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tSystem.out.println(\"多线程任务执行！\");\n\t\t\t}\n\t\t}).start();\n\t}\n}\n```\n\n### 匿名内部类的好处与弊端\n\n一方面，匿名内部类可以帮我们**省去实现类的定义**；另一方面，匿名内部类的语法——**确实太复杂了！**\n\n### 语义分析\n\n仔细分析该代码中的语义，`Runnable`接口只有一个`run`方法的定义：\n\n* `public abstract void run();`\n\n即制定了一种做事情的方案（其实就是一个函数）：\n\n* **无参数**：不需要任何条件即可执行该方案。\n* **无返回值**：该方案不产生任何结果。\n* **代码块**（方法体）：该方案的具体执行步骤。\n\n同样的语义体现在`Lambda`语法中，要更加简单：\n\n```java\n() -> System.out.println(\"多线程任务执行！\")\n```\n\n* 前面的一对小括号即`run`方法的参数（无），代表不需要任何条件；\n* 中间的一个箭头代表将前面的参数传递给后面的代码；\n* 后面的输出语句即业务逻辑代码。\n\n## 6.6 Lambda标准格式\n\nLambda省去面向对象的条条框框，格式由**3个部分**组成：\n\n* 一些参数\n* 一个箭头\n* 一段代码\n\nLambda表达式的**标准格式**为：\n\n```\n(参数类型 参数名称) -> { 代码语句 }\n```\n\n格式说明：\n\n* 小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。\n* `->`是新引入的语法格式，代表指向动作。\n* 大括号内的语法与传统方法体要求基本一致。\n\n## 6.7 练习：使用Lambda标准格式（无参无返回）\n\n### 题目\n\n给定一个厨子`Cook`接口，内含唯一的抽象方法`makeFood`，且无参数、无返回值。如下：\n\n```java\npublic interface Cook {\n    void makeFood();\n}\n```\n\n在下面的代码中，请使用Lambda的**标准格式**调用`invokeCook`方法，打印输出“吃饭啦！”字样：\n\n```java\npublic class Demo05InvokeCook {\n    public static void main(String[] args) {\n        // TODO 请在此使用Lambda【标准格式】调用invokeCook方法\n    }\n\n    private static void invokeCook(Cook cook) {\n        cook.makeFood();\n    }\n}\n```\n\n### 解答\n\n```java\npublic static void main(String[] args) {\n    invokeCook(() -> {\n      \tSystem.out.println(\"吃饭啦！\");\n    });\n}\n```\n\n> 备注：小括号代表`Cook`接口`makeFood`抽象方法的参数为空，大括号代表`makeFood`的方法体。\n\n## 6.8 Lambda的参数和返回值\n\n```\n需求:\n    使用数组存储多个Person对象\n    对数组中的Person对象使用Arrays的sort方法通过年龄进行升序排序\n```\n\n下面举例演示`java.util.Comparator<T>`接口的使用场景代码，其中的抽象方法定义为：\n\n* `public abstract int compare(T o1, T o2);`\n\n当需要对一个对象数组进行排序时，`Arrays.sort`方法需要一个`Comparator`接口实例来指定排序的规则。假设有一个`Person`类，含有`String name`和`int age`两个成员变量：\n\n```java\npublic class Person { \n    private String name;\n    private int age;\n    \n    // 省略构造器、toString方法与Getter Setter \n}\n```\n\n### 传统写法\n\n如果使用传统的代码对`Person[]`数组进行排序，写法如下：\n\n```java\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class Demo06Comparator {\n    public static void main(String[] args) {\n      \t// 本来年龄乱序的对象数组\n        Person[] array = {\n        \tnew Person(\"古力娜扎\", 19),\n        \tnew Person(\"迪丽热巴\", 18),\n       \t\tnew Person(\"马尔扎哈\", 20) };\n\n      \t// 匿名内部类\n        Comparator<Person> comp = new Comparator<Person>() {\n            @Override\n            public int compare(Person o1, Person o2) {\n                return o1.getAge() - o2.getAge();\n            }\n        };\n        Arrays.sort(array, comp); // 第二个参数为排序规则，即Comparator接口实例\n\n        for (Person person : array) {\n            System.out.println(person);\n        }\n    }\n}\n```\n\n这种做法在面向对象的思想中，似乎也是“理所当然”的。其中`Comparator`接口的实例（使用了匿名内部类）代表了“按照年龄从小到大”的排序规则。\n\n### 代码分析\n\n下面我们来搞清楚上述代码真正要做什么事情。\n\n- 为了排序，`Arrays.sort`方法需要排序规则，即`Comparator`接口的实例，抽象方法`compare`是关键；\n- 为了指定`compare`的方法体，**不得不**需要`Comparator`接口的实现类；\n- 为了省去定义一个`ComparatorImpl`实现类的麻烦，**不得不**使用匿名内部类；\n- 必须覆盖重写抽象`compare`方法，所以方法名称、方法参数、方法返回值**不得不**再写一遍，且不能写错；\n- 实际上，**只有参数和方法体才是关键**。\n\n### Lambda写法\n\n```java\nimport java.util.Arrays;\n\npublic class Demo07ComparatorLambda {\n    public static void main(String[] args) {\n        Person[] array = {\n          \tnew Person(\"古力娜扎\", 19),\n          \tnew Person(\"迪丽热巴\", 18),\n          \tnew Person(\"马尔扎哈\", 20) };\n\n        Arrays.sort(array, (Person a, Person b) -> {\n          \treturn a.getAge() - b.getAge();\n        });\n\n        for (Person person : array) {\n            System.out.println(person);\n        }\n    }\n}\n```\n\n## 6.9 练习：使用Lambda标准格式（有参有返回）\n\n### 题目\n\n给定一个计算器`Calculator`接口，内含抽象方法`calc`可以将两个int数字相加得到和值：\n\n```java\npublic interface Calculator {\n    int calc(int a, int b);\n}\n```\n\n在下面的代码中，请使用Lambda的**标准格式**调用`invokeCalc`方法，完成120和130的相加计算：\n\n```java\npublic class Demo08InvokeCalc {\n    public static void main(String[] args) {\n        // TODO 请在此使用Lambda【标准格式】调用invokeCalc方法来计算120+130的结果ß\n    }\n\n    private static void invokeCalc(int a, int b, Calculator calculator) {\n        int result = calculator.calc(a, b);\n        System.out.println(\"结果是：\" + result);\n    }\n}\n```\n\n### 解答\n\n```java\npublic static void main(String[] args) {\n    invokeCalc(120, 130, (int a, int b) -> {\n      \treturn a + b;\n    });\n}\n```\n\n> 备注：小括号代表`Calculator`接口`calc`抽象方法的参数，大括号代表`calc`的方法体。\n\n## 6.10 Lambda省略格式\n\n### 可推导即可省略\n\nLambda强调的是“做什么”而不是“怎么做”，所以凡是可以根据上下文推导得知的信息，都可以省略。例如上例还可以使用Lambda的省略写法：\n\n```java\npublic static void main(String[] args) {\n  \tinvokeCalc(120, 130, (a, b) -> a + b);\n}\n```\n\n### 省略规则\n\n在Lambda标准格式的基础上，使用省略写法的规则为：\n\n1. 小括号内参数的类型可以省略；\n2. 如果小括号内**有且仅有一个参**，则小括号可以省略；\n3. 如果大括号内**有且仅有一个语句**，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。\n\n> 备注：掌握这些省略规则后，请对应地回顾本章开头的多线程案例。\n\n## 6.11 练习：使用Lambda省略格式\n\n### 题目\n\n仍然使用前文含有唯一`makeFood`抽象方法的厨子`Cook`接口，在下面的代码中，请使用Lambda的**省略格式**调用`invokeCook`方法，打印输出“吃饭啦！”字样：\n\n```java\npublic class Demo09InvokeCook {\n    public static void main(String[] args) {\n        // TODO 请在此使用Lambda【省略格式】调用invokeCook方法\n    }\n\n    private static void invokeCook(Cook cook) {\n        cook.makeFood();\n    }\n}\n```\n\n### 解答\n\n```java\npublic static void main(String[] args) {\n  \tinvokeCook(() -> System.out.println(\"吃饭啦！\"));\n}\n```\n\n## 6.12 Lambda的使用前提\n\n\n\nLambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：\n\n1. 使用Lambda必须具有接口，且要求**接口中有且仅有一个抽象方法**。\n   无论是JDK内置的`Runnable`、`Comparator`接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。\n2. 使用Lambda必须具有**上下文推断**。\n   也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。\n\n> 备注：有且仅有一个抽象方法的接口，称为“**函数式接口**”。\n\n","tags":["java"]},{"title":"腾讯课堂以及各种文库下载实现自动化","url":"/blog/2020/txkt-automation/","content":"\n今天上线代课，老师抽查了一次签到，我没签上，应该按旷课处理了。\n\n并不是我上课态度不端正，实在是这老师就是个混子，混吃等死那种。听他课还不如自己看书刷题。\n\n<!--more-->\n\n本着开源分享的精神，我把代码发到了b站上和博客上。\n\n这个解决问题的想法并非我原创，网上有好多教程，比我早。而且这个一开始也是跟我自己的思路有点出入的。只能算是我对其的一个扩展。供大家学习使用。\n\n# 腾讯课堂\n\n[腾讯课堂实现自动化](https://b23.tv/BV1Lz41187RR\n)\n\n打开`chrome`浏览器（其他的也可以，chrome最好啦）。\n\n打开`开发者工具`，直接将代码复制到`console`栏，按`enter`键即可。如果还不会用，就点击上面的那个链接。\n\n> 注意\n>\n> * 后台运行。有的小伙伴不太会用，解释一下。代码复制到console栏之后，自己就可以做别的事去了，哪怕你把浏览器最小化都行。只要不关闭页面，代码就会一直运行。\n> * 怎么知道有没有签到成功？签到的话，会在console栏里面输出“xxx时间完成签到”、“xxx时间完成确定”字样。输出信息，那就是在你这里已经签上了，老师那边如果没数据，就是老师的事，要不就是网络的事。我前几天碰到过，三次签到都没记录，我跟老师说我全签了，然后他重新下载记录，就有了。下课之后可以看console。如果太多信息，覆盖了结果，可以参照我下图的设置。用完了再还原Default就行\n\n{% asset_img 5.png 设置 %}\n\n## 1 开启自动任务\n\n### 自动送花\n\n开启一个`3秒`送花的定时器：\n\n```javascript\nlet flower=setInterval(function (){\n    document.getElementsByClassName(\"toolbar-icon\")[2].click();\n    console.log(\"送花\");\n},3000);\n```\n\n### 自动签到\n\n开启一个每隔`10秒`检测一次是否有签到按钮的定时器，有的话就点击：\n\n```javascript\nlet btns;\nlet attend=setInterval(function (){\n    btns=document.getElementsByClassName(\"s-btn s-btn--primary s-btn--m\");\n    if(btns.length>0){\n        console.log(new Date().toLocaleTimeString()+\"--完成-->\"+btns[0].innerText);\n        btns[0].click();\n    }\n},10000);\n```\n\n### 自动签到升级版\n\n如果不是刚需的话，这个版本，我不推荐用的。里面有很多bug。只是实现功能的话，很简单，代码也不多，但是如果要把代码完善起来，就要很多代码了，目前我还没那么多时间整这个。所以，将就着用吧，代码的话，还是最初实现的版本，我没深入去优化了。\n\n{% asset_img 6.png 建议 %}\n\n也是有小伙伴要的功能，仔细一想，好像我也会用到。\n\n环境：\n\n* 浏览器：[Google Chrome](https://www.google.cn/chrome/)\n* Chrome扩展：[TamperMonkey](https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?hl=zh-CN)\n\n具体安装过程：\n\n1. 挂梯子，翻墙（免费的话，推荐蓝灯->下载地址[android](https://raw.githubusercontent.com/getlantern/lantern-binaries/master/lantern-installer.apk)，[windows](https://raw.githubusercontent.com/getlantern/lantern-binaries/master/lantern-installer.exe)，[mac](https://raw.githubusercontent.com/getlantern/lantern-binaries/master/lantern-installer.dmg)）\n2. 打开上面Chrome扩展后面的链接，点击安装\n3. 安装之后，右上角会出来个猴子的标志，没有的话，点击管理扩展程序，启用即可\n4. 点击猴子，点击添加新脚本，保存即可\n\n{% asset_img 7.png %}\n\n{% asset_img 8.png %}\n\n{% asset_img 9.png %}\n\n具体的代码\n\n```javascript\n// ==UserScript==\n// @name         txkt-automation\n// @namespace    http://meethigher.top/blog/2020/txkt-automation/\n// @version      1.0\n// @description  有小伙伴提到这个功能，正好我自己也会用到，就整了。用于腾讯课堂的自动签到\n// @author       Kit Chen\n// @match        https://ke.qq.com/webcourse/index.html\n// @grant        none\n// @提示          如果使用过程中出现问题，清除一下cookie就行，不用清除浏览器的所有数据，清除cookie就行\n// ==/UserScript==\n(function() {\n    'use strict';\n    function autoAttend() {\n        let btns;\n        let attend = setInterval(function() {\n            btns = document.getElementsByClassName(\"s-btn s-btn--primary s-btn--m\");\n            if (btns.length > 0) {\n                console.log(new Date().toLocaleTimeString() + \"--完成-->\" + btns[0].innerText);\n                btns[0].click();\n            }\n        }, 10000);\n    }\n    function showBtn() {\n        let $switch = document.createElement(\"span\");\n        let $body = document.querySelector(\".web\");\n        let show = true;\n        $switch.innerText = \"显示/隐藏\";\n        $switch.style = \"position:absolute;top:21px;right:520px;color:#AAAAAA;border-radius:10px;cursor:pointer;z-index:3000\";\n        $switch.onclick = function() {\n            if (show) {\n                document.querySelector(\".study-body.mr\").style = \"right:0;z-index:999\";\n                show = false;\n            } else {\n                document.querySelector(\".study-body.mr\").style = \"right:300px;z-index:0\";\n                show = true;\n            }\n        }\n        $body.appendChild($switch);\n    }\n    function clearRefresh() {\n        window.localStorage.removeItem(\"refresh\");\n    }\n    function autoRefresh() {\n        window.localStorage.setItem(\"refresh\", \"no\");\n        let response = prompt(\"请输入上课时间的前2分钟，并点击确定按钮开始执行自动刷新！\", \"13:28\");\n        if (response !== null) {\n            let arr = response.trim().split(\":\");\n            let date;\n            let timid = setInterval(function() {\n                date = new Date();\n                if (date.getHours() == parseInt(arr[0]) && date.getMinutes() == parseInt(arr[1])) {\n                    window.location.reload();\n                }\n            }, 1000);\n        } else {\n            clearRefresh();\n        }\n    }\n    function isRefresh() {\n        let isRefresh = window.localStorage.getItem(\"refresh\") || \"yes\";\n        console.log(isRefresh);\n        if (isRefresh == \"yes\") {\n            autoRefresh();\n        } else {\n            clearRefresh();\n        }\n    }\n    isRefresh();\n    autoAttend();\n    showBtn();\n})();\n```\n\n\n### 自动刷屏\n\n每隔`3秒`发送`886`\n\n```javascript\nlet say = setInterval(function() {\n    document.getElementsByClassName(\"ql-editor\")[0].firstElementChild.innerText = \"886\";\n}, 3000);\nlet say2 = setInterval(function() {\n    document.getElementsByClassName(\"text-editor-btn\")[0].click();\n}, 3000)\n```\n\n### 下课自动发886\n\n设置好下课的时间，比如我的线代下课时间是`16:50`，自动发送`886`。\n\n这个执行了之后会自动关闭，如果在执行之前想关闭，请跳转到[这里关闭下课提示](#关闭下课提示)\n\n```javascript\nlet targetHour = \"16\";\nlet targetMin = \"50\";\nlet date;\nlet inputed = false;\nlet timing = setInterval(function() {\n    date = new Date();\n    if (date.getHours() == parseInt(targetHour) && date.getMinutes() == parseInt(targetMin)) {\n        if (!inputed) {\n            document.getElementsByClassName(\"ql-editor\")[0].firstElementChild.innerText = \"886\"\n            inputed = true;\n        } else {\n            document.getElementsByClassName(\"text-editor-btn\")[0].click();\n            window.clearInterval(timing);\n            console.log(\"下课咯！\");\n        }\n    }\n}, 1000);\n```\n\n### 显示/隐藏对话框\n\n有小伙伴要这个功能，然后就加了一下\n\n```javascript\nlet $switch = document.createElement(\"span\");\nlet $body = document.querySelector(\".web\");\nlet show = true;\n$switch.innerText = \"显示/隐藏\";\n$switch.style = \"position:absolute;top:21px;right:520px;color:#AAAAAA;border-radius:10px;cursor:pointer;z-index:3000\";\n$switch.onclick = function() {\n    if (show) {\n        document.querySelector(\".study-body.mr\").style = \"right:0;z-index:999\";\n        show = false;\n    } else {\n        document.querySelector(\".study-body.mr\").style = \"right:300px;z-index:0\";\n        show = true;\n    }\n}\n$body.appendChild($switch);\n```\n\n效果如图：\n\n{% asset_img 4.png 显示/隐藏 %}\n\n## 2 关闭自动任务\n\n### 关闭送花\n\n```javascript\nif(flower){\n    window.clearInterval(flower);\n    console.log(\"已关闭送花\");\n}\n```\n\n### 关闭签到\n\n```javascript\nif(attend){\n    window.clearInterval(attend);\n    console.log(\"已关闭签到\");\n}\n```\n\n### 关闭刷屏\n\n```javascript\nif(say){\n    window.clearInterval(say);\n    window.clearInterval(say2);\n    console.log(\"已关闭刷屏\");\n}\n```\n\n### 关闭下课提示\n\n```javascript\nif(timing){\n    window.clearInterval(timing);\n    console.log(\"提前关闭下课提示\");\n}\n```\n\n## 3 今天上课的小插曲\n\n一开始刚测试送花的时候，我开的是1秒送一个，估计是太活跃了，直接让马原老师，叫起来提问问题了。\n\n我一脸懵逼啊，还好有大佬江湖救急。\n\n{% asset_img 1.png 插曲 %}\n\n还有一个小插曲，就是马原老师问了一个问题，“越南是什么党派？”。\n\n然后，下面一堆回复共产党。老师说，他直接被腾讯警告了。\n\n哈哈，太难了也！\n\n# 文库下载\n\n[超简单！学生如何免费下载文档，一看就会](https://www.bilibili.com/video/BV1gV411Z7YS/)\n\n刚才在做英语练习题的时候，做完了，想对一下答案，就百度了搜了一下，进去一个文库。\n\n下载文档要12块钱，我就看了一下，上面预览的都是图片，所以就想着，js批量把图片下载下来，然后合成pdf，就正常看了，关键是没花钱啊，要不用浪费多长时间。\n\n具体的使用我放到youtube的[文库免费下载小技巧](https://youtu.be/UXI-_SBcw7o)，本来想往b站传的，但是被驳回锁定了。下面放上代码吧。\n\n{% asset_img 3.png 只不过是程序代替了手动 %}\n\n## 1 示例淘豆网\n\n淘豆网就是直接把图片放出来了，咱们直接下手就行。\n\n```javascript\nfunction download(url, fileName) {\n    let xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);//true表示异步\n    xhr.responseType = 'blob';\n    xhr.onload = () => {\n        if (xhr.status === 200) {\n           downloadByA(xhr.response,fileName);\n        }\n    };\n    xhr.send();\n}\nfunction downloadByA(data,fileName){\n\tlet urlObject = window.URL || window.webkitURL || window;\n\tlet export_blob=new Blob([data]);\n\tlet a=document.createElement(\"a\");\n\ta.href=urlObject.createObjectURL(export_blob);\n\ta.download=fileName;\n\ta.click();\n}\n//下面这块代码需要按自己需求，进行稍微地修改，上面两块代码可以不用动\ndocument.querySelectorAll(\".pageBox img\").forEach(function(ele, i) {\n    download(ele.src,i+\".jpg\");\n});\n```\n\n然后将下载出的图片合成pdf，就ok了\n\n点击进入[淘豆网示例网址](https://www.taodocs.com/p-134597690.html)\n\n## 2 示例道客巴巴\n\n道客巴巴就有点小心眼了，他把所有的预览图片，都转成了canvas形式的，那也没事，咱们同样用代码给他转回来。\n\n```javascript\nfunction download(url, fileName) {\n    let xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);//true表示异步\n    xhr.responseType = 'blob';\n    xhr.onload = () => {\n        if (xhr.status === 200) {\n           downloadByA(xhr.response,fileName);\n        }\n    };\n    xhr.send();\n}\nfunction downloadByA(data,fileName){\n\tlet urlObject = window.URL || window.webkitURL || window;\n\tlet export_blob=new Blob([data]);\n\tlet a=document.createElement(\"a\");\n\ta.href=urlObject.createObjectURL(export_blob);\n\ta.download=fileName;\n\ta.click();\n}\n//下面这块代码需要按自己需求，进行稍微地修改，上面两块代码可以不用动\ndocument.querySelectorAll(\".outer_page .inner_page\").forEach(function(ele, i) {\n    download(ele.toDataURL(\"image/jpeg\"),i+\".jpg\");\n});\n```\n\n点击进入[道客巴巴示例网址](https://www.doc88.com/p-7337496651450.html)\n\n## 3 示例百度文库\n\n百度文库有文字显示的，也有图片显示的，这里主要针对图片显示的，文字的我也看了太麻烦了。\n\n但是在处理图片的过程中也出了问题，涉及到跨域的问题\n\n{% asset_img 2.png 百度文库 %}\n\n```javascript\ndocument.querySelectorAll(\".mod.reader-page.complex.hidden-doc-banner .inner .bd .reader-pic-item\").forEach(function(ele, i) {\n    download(ele.style.backgroundImage.match(/[^url(\"].*[^\")]/)[0],i+\".jpg\");\n});\n```\n\n点击进入[百度文库示例网址](https://wenku.baidu.com/view/3dce4d3e02d8ce2f0066f5335a8102d276a261d2)，网址放到这里，留着以后有时间再研究。准备上数学课了。\n\n## 4 关于合成pdf\n\n现在工具很多，有免费在线版，也有免费的客户端，给大家推荐两款吧。\n\n1. [免费在线转pdf](https://smallpdf.com/)\n2. [adobe acrobat](https://acrobat.adobe.com/cn/zh-Hans/acrobat.html)\n\n我是用的acrobat这个软件，这个比较好用，还可以去水印之类的。在我之前去水印的文章里，有提到过。","tags":["open","acrobat","javascript"]},{"title":"java使用Junit单元测试","url":"/blog/2020/unit-test/","content":"\n上学期，软件工程老师上课顺带讲了单元测试，虽然只是一笔带过。但我感觉就很有用，后来事也很多，忙过头了，一直没抽出时间研究一下。\n\n今天就来整一下。加油，奥利给！\n\n<!--more-->\n\n# 一、测试分类\n\n1. 黑盒测试：不需要写入代码，给输入值，看程序是否能够输出期望的值。\n2. 白盒测试：需要写代码。关注程序的具体执行过程。像`Junit`就是白盒测试的一种。\n\n{% asset_img 1.png 测试分类 %}\n\n黑盒测试比较简单，一般现在市面上很多的测试，都是黑盒测试。\n\n当然，如果选择做测试之类的工作的话，我还是希望做白盒测试了。多写代码，对身体有益，奥利给！\n\n# 二、Junit使用：白盒测试\n\n## 背景\n\n如果想要测试一下计算器的运算结果对不对，以往，我会这样写，先定义一个`Calculator`类：\n\n```java\n/*\n * 计算器类\n */\npublic class Calculator {\n\t/**\n\t * 加法\n\t * @param a\n\t * @param b\n\t * @return\n\t */\n\tpublic int add(int a,int b) {\n\t\treturn a+b;\n\t}\n\t/**\n\t * 减法\n\t * @param a\n\t * @param b\n\t * @return\n\t */\n\tpublic int sub(int a,int b) {\n\t\treturn a-b;\n\t}\n\t\n}\n```\n\n再定义一个测试类：\n\n```java\npublic class CalculatorTest {\n\tpublic static void main(String[] args) {\n\t\t//创建对象\n\t\tCalculator c=new Calculator();\n\t\t//调用\n//\t\tint result=c.add(1,2);\n//\t\tSystem.out.println(result);\n\t\t//如果我现在又想测试减法，那还得再写一个\n\t\tint result=c.sub(1, 2);\n\t\tSystem.out.println(result);\n\t\t\n\t}\n}\n```\n\n看上面代码就知道了，我测试完了加法，又想测试减法，只能重新再写一次，很麻烦。\n\n所以我们可以通过`Junit`进行单元测试，免除这些复杂的步骤。\n\n## 使用Junit\n\n步骤：\n\n1. 定义一个测试类（测试用例）\n   测试类名：被测试的类名Test，如`CalculatorTest`\n   包名：xxx.xxx.xxx.test，如`top.meethigher.test`\n2. 定义测试方法：可以独立运行\n   方法名：test测试的方法名，如`testAdd()`\n   返回值：void\n   参数列表：空参\n3. 给方法加注解`@Test`\n4. 导入`Junit`的依赖环境\n\n[Junit 5跟Junit 4的比较](https://blog.csdn.net/u010675669/article/details/86574956)\n\n判定结果：\n\n* 红色代表失败\n* 绿色代表成功\n* 一般我们使用`断言`操作来处理结果，`Assert.assertEquals(expected,actuals)`\n\n> 补充：\n>\n> @BeforeEach：修饰的方法，会在测试方法执行之前执行\n>\n> @AfterEach：修饰的方法，会在测试方法执行之后执行\n\n```java\npublic class CalculatorTest {\n\t/**\n\t * 初始化方法\n\t * 用于资源的申请，所有的测试方法都会执行该方法\n\t */\n\t@BeforeEach\n\tpublic void init() {\n\t\tSystem.out.println(\"init...\");\n\t}\n\t/*\n\t * 释放资源方法\n\t * 在所有测试方法执行完后，都会自动执行该方法\n\t */\n\t@AfterEach\n\tpublic void close() {\n\t\tSystem.out.println(\"close...\");\n\t}\n\t/**\n\t * 测试add方法\n\t */\n\t@Test\n\tpublic void testAdd() {\n\t\t//1.创建计算器对象\n\t\tCalculator c=new Calculator();\n\t\t//2.调用add方法\n\t\tint result=c.add(1, 2);\n//\t\tSystem.out.println(result);\n\t\t//3.断言，我断言这个结果是3，如果是一样的就是绿色，如果不一样就是红色\n\t\tAssert.assertEquals(3, result);\n\t\tSystem.out.println(\"加法测试\");\n\t}\n\t/**\n\t * 测试sub方法\n\t */\n\t@Test\n\tpublic void testSub() {\n\t\tCalculator c=new Calculator();\n\t\tint result=c.sub(2, 2);\n\t\tAssert.assertEquals(0, result);\n\t\tSystem.out.println(\"减法测试\");\n\t}\n}\n```\n\n{% asset_img 2.png Junit使用 %}\n\n\n\n","tags":["java"]},{"title":"tomcat服务器","url":"/blog/2020/tomcat/","content":"\n\ntomcat服务器？汤姆猫服务器！\n\n<!--more-->\n\n# 一、web相关概念\n\n软件架构\n\n1. C/S：客户端/服务器端\n2. B/S：浏览器/服务器端\n\n资源分类\n\n1. 静态资源：所有用户访问后，得到的结果都是一样的资源。比方说html,css,js\n2. 动态资源：每个用户访问相同结果后，得到的结果可能不一样。比方说servlet/jsp,php,asp\n\n> 用户访问时，\n>\n> 静态资源是直接返回的，浏览器内部有静态资源解析引擎，意味着浏览器可以直接解析静态资源。\n>\n> 动态资源先转换成静态资源，然后再返回。\n\n网络通信三要素\n\n1. ip：电子设备（计算机）在网络中的唯一标识\n2. 端口：应用程序在计算机中的唯一标识。0-65536\n3. 传输协议：规定了数据传输的规则\n\n基础传输协议\n\n1. tcp：安全协议，三次握手。速度慢\n2. udp：不安全的协议，传输过程数据可能会丢失。速度快\n\n服务器：安装了服务器软件的计算机\n\n服务器软件：接收用户的请求，处理请求，作出响应\n\nweb服务器软件：接收用户的请求，处理请求，作出响应。在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目\n\n常见的java相关的web服务器软件\n\n1. webLogic：Oracle公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的\n2. webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的\n3. JBoss：JBoss公司，大型的JavaEE服务器，支持所有的JavaEE规范，使用是免费的，但是一些服务是收费的\n4. Tomcat：apache基金组织，开源的免费的。中小型JavaEE服务器，仅仅支持少量的JavaEE规范（Servelet/jsp）。开源的，免费的。\n\n> JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了十三项大的规范。\n\n# 二、Tomcat服务器\n\n[Tomcat官网](http://tomcat.apache.org/)，简记为汤姆猫\n\n{% asset_img 1.png 汤姆猫目录结构 %}\n\n> bin：存放可执行文件\n>\n> conf：configuration的简写，配置文件\n>\n> lib：依赖的jar包\n>\n> logs：日志文件\n>\n> temp：临时文件\n>\n> webapps：存放web项目\n>\n> work：存放运行时数据\n\n## 2.1 配置问题\n\n[tomcat9与jdk12配置问题](https://blog.csdn.net/qq_35909589/article/details/102904557)\n\n[tomcat9&jdk11配置手记](https://blog.csdn.net/my547552596/article/details/83507803)\n\n之前上课的时候，我的jre采用的是jre8，后来为了让jdk跟jre保持一致（新版的jdk中，自带jre，不过需要命令来生成），我就升级成了新版。\n\n在配置的过程中，就出问题了。我的JAVA_HOME配置C:\\Program Files\\Java\\jdk-12.0.2，JRE_HOME配置C:\\Program Files\\Java\\jdk-12.0.2\\bin\\jre（我把生成的jre放到了bin目录下）。\n\n运行，发现报错了。\n\n{% asset_img 2.png sbtomcat %}\n\n又大概花了一个小时，各种折腾，期间还换了jre的版本，换成了jre8，发现又是完美运行了。\n\n到了最后，发现，新版jdk不用单独配置jre，jre的路径直接使用jdk的路径就可以了。\n\n{% asset_img 3.png sbtomcat %}\n\n来回折腾花了2个多小时，艹尼玛的汤姆猫，气死我了。\n\n控制台如果乱码，那是因为系统的编码是gbk，而控制台输出的日志是以utf-8输出的。只需要修改conf/logging.properties即可\n\n[查看windows系统的默认编码](https://blog.csdn.net/zp357252539/article/details/79084480)\n\n[修改windows系统默认编码](https://blog.csdn.net/lee_ham/article/details/82634411)\n\n```properties\n# java.util.logging.ConsoleHandler.encoding = UTF-8\n# 解决windows乱码问题\njava.util.logging.ConsoleHandler.encoding = GBK\n```\n\n## 2.2 使用\n\n双击startup.bat或者命令行里输入startup.bat可以直接运行。当然，也可以安装服务到电脑，具体可以百度，这个我并不常用，就没整。\n\n卸载的话，直接删除整个文件夹即可。\n\n如果遇到端口占用问题，可以关闭占用的进程\n\n```cmd\nnetstat -ano\n```\n\n找到占用端口号的pid，然后关闭进程，-f表示强制的意思\n\n```cmd\ntaskkill /pid 进程号 -f\n```\n\n如果要修改运行的端口号，则需要修改conf/server.xml\n\n关闭的话，双击shutdown.bat或者按ctrl+c，直接按命令行的x属于强制关闭\n\n## 2.3 部署项目\n\n三种方式\n\n1. 直接将项目放到webapps目录下。或者将项目压缩成war包，然后放入webapps。tomcat会自动解压，如果删除war包，tomcat会自动删除项目\n2. 配置conf/server.xml文件。在`<Host>`标签下配置`<Context docBase=\"D:\\Develop\" path=\"/www\" />`\n   * docBase：项目存放的路径\n   * path：虚拟目录\n3. 在conf\\Catalina\\localhost创建任意名称的xml文件，在文件中编写`<Context docBase=\"D:\\Develop\" />`此时的虚拟目录就是xml的名称。这种部署叫做热部署，这种方式是比较推荐的。\n\n## 2.4 静态项目和动态项目\n\njava动态项目的目录结构(以下表示的是目录结构)\n\n* 项目的根目录\n  * WEB-INF目录\n    * web.xml：web项目的核心配置文件\n    * classes目录：放置字节码文件的目录\n    * lib目录：放置依赖jar包\n\n## 2.5 Tomcat集成到Eclipse或Idea\n\n百度！\n\n","tags":["web"]},{"title":"XML可扩展标记语言","url":"/blog/2020/xml/","content":"\n\n简单了解一下xml\n\n<!--more-->\n\n# 一、了解XML\n\n## 1.1 概念\n\n概念：Extensible Markup Language 可扩展标记语言\n\n可扩展：标签都是自定义的，只要符合命名规则\n\n**功能：存储数据**\n\n* 配置文件\n* 在网络上中传输数据。纯文本，跨平台。\n\n**XML与HTML区别**\n\n1. XML标签是自定义；HTML标签是预定义\n2. XML语法严格；HTML语法松散\n3. XML存储数据；HTML展示数据\n\n> W3C(World Wide Web Consortium)：万维网联盟\n>\n> 由于各种浏览器的恶性竞争，有的浏览器不用写属性的引号，有的浏览器甚至不用写html根标签。这样的竞争导致HTML不够规范，W3C为此出了严格规范的XML，打算代替HTML。事实却不是这样。因为太过规范，开发人员并不接受。\n>\n> 由此，XML改变了方向，向存储数据的方向发展。\n>\n> properties只能存储简单的数据；复杂的数据，还需要用XML\n\n{% asset_img 1.png 万维网联盟 %}\n\n## 1.2 语法\n\n**快速入门**\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<users>\n    <user>\n        <name>邪月</name>\n        <age>23</age>\n        <gender>男</gender>\n    </user>\n    <user>\n        <name>胡列娜</name>\n        <age>22</age>\n        <gender>女</gender>\n    </user>\n</users>\n```\n\n**基本语法**\n\n1. 文档的后缀名.xml\n2. xml第一行必须为文档声明\n3. xml有且仅有一个根标签\n4. 属性值必须使用引号，单双都可\n5. 标签必须正确关闭，必须有结束标签。自闭合标签也可\n6. 标签区分大小写\n\n**组成部分**\n\n1. 文档声明\n2. 指令\n3. 标签\n4. 属性\n5. 文本内容\n\n**文档声明**\n\n```xml\n<?xml 属性列表 ?>\n```\n\n属性列表\n\n1. version：版本号，必须的属性。版本还有个1.1，但是还有很多问题。所以1.0依然是最常用的xml版本\n2. encoding：编码方式。告知解析引擎，当前的文档使用的字符集，默认值iso-8859-1\n3. standalone：是否独立，不依赖与其他文件。yes或者no\n\n**指令**\n\n可以结合css修改样式\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<?xml-stylesheet type=\"text/css\" href=\"a.css\"?>\n<users>\n    <user>\n        <name>邪月</name>\n        <age>23</age>\n        <gender>男</gender>\n    </user>\n    <user>\n        <name>胡列娜</name>\n        <age>22</age>\n        <gender>女</gender>\n    </user>\n</users>\n```\n\n**标签**\n\nxml元素必须包含以下命名规则：\n\n- 名称可以包含字母、数字以及其他的字符\n- 名称不能以数字或者标点符号开始\n- 名称不能以字母 xml（或者 XML、Xml 等等）开始\n- 名称不能包含空格\n\n**属性**：id属性值唯一\n\n**文本内容**\n\n* 直接写数据，会涉及到特殊字符的转义。[HTML转义字符对照表](https://tool.oschina.net/commons?type=2)\n\n* CDATA区：数据原样展示\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!-- <?xml-stylesheet type=\"text/css\" href=\"a.css\"?> -->\n<users>\n    <user>\n        <name>邪月</name>\n        <age>23</age>\n        <gender>男</gender>\n    </user>\n    <user>\n        <name>胡列娜</name>\n        <age>22</age>\n        <gender>女</gender>\n        <code1>if(a&lt;b&amp;&amp;b&gt;c){}</code1>\n        <code2><![CDATA[\n            if(a<b&&b>c){}\n            ]]></code2>\n    </user>\n</users>\n```\n\n# 二、XML约束\n\n## 2.1 概念\n\n软件使用者**编写**XML\n\n软件框架**解析**XML\n\n其中，规定XML文档的书写规则的叫做说明文档，也叫约束文档。由框架开发人员开发约束文档。软件使用者阅读约束文档\n\n**约束**：规定XML文档的书写规则。\n\n对框架使用者的要求：\n\n1. 能够在XML中引入约束文档\n2. 能够读懂约束文档\n\n## 2.2 分类\n\n1. DTD：一种简单的约束技术\n2. Schema：一种复杂的约束技术\n\n### DTD\n\n引入dtd文档到xml文档中\n\n* 内部dtd：将约束规则在xml文档中\n* 外部dtd：将约束规则定义在外部的dtd文件中\n  1. 本地dtd\n  2. 网络dtd\n\n#### 内部dtd\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE students [\n\t\t<!ELEMENT students (student+) >\n\t\t<!ELEMENT student (name,age,sex)>\n\t\t<!ELEMENT name (#PCDATA)>\n\t\t<!ELEMENT age (#PCDATA)>\n\t\t<!ELEMENT sex (#PCDATA)>\n\t\t<!ATTLIST student number ID #REQUIRED>\n\t\t]>\n<students>\n\t<student number=\"s001\">\n\t\t<name>胡列娜</name>\n\t\t<age>22</age>\n\t\t<sex>女</sex>\n\t</student>\n\t<student number=\"s002\">\n\t\t<name>水冰儿</name>\n\t\t<age>17</age>\n\t\t<sex>女</sex>\n\t</student>\n</students>\n```\n\n#### 外部dtd\n\n如果是本地dtd，这样引用\n\n```xml\n<!DOCTYPE 根标签名 SYSTEM \"dtd文件位置\">\n```\n\n如果是网络dtd，这样引用\n\n```xml\n<!DOCTYPE 根标签名 PUBLIC \"dtd文件名字\" \"dtd文件位置的完整URL\">\n```\n\nstudent.dtd\n\n```dtd\n<!ELEMENT students (student+) >\n<!ELEMENT student (name,age,sex)>\n<!ELEMENT name (#PCDATA)>\n<!ELEMENT age (#PCDATA)>\n<!ELEMENT sex (#PCDATA)>\n<!ATTLIST student number ID #REQUIRED>\n```\n\n相应的xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE students SYSTEM \"student.dtd\">\n<students>\n\t<student number=\"s001\">\n\t\t<name>胡列娜</name>\n\t\t<age>22</age>\n\t\t<sex>女</sex>\n\t</student>\n\t<student number=\"s002\">\n\t\t<name>水冰儿</name>\n\t\t<age>17</age>\n\t\t<sex>女</sex>\n\t</student>\n</students>\n```\n\n### Schema\n\nstudent.xsd\n\n```xml\n<?xml version=\"1.0\"?>\n<xsd:schema xmlns=\"http://www.itcast.cn/xml\"\n        xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\n        targetNamespace=\"http://www.itcast.cn/xml\" elementFormDefault=\"qualified\">\n    <xsd:element name=\"students\" type=\"studentsType\"/>\n    <xsd:complexType name=\"studentsType\">\n        <xsd:sequence>\n            <xsd:element name=\"student\" type=\"studentType\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n        </xsd:sequence>\n    </xsd:complexType>\n    <xsd:complexType name=\"studentType\">\n        <xsd:sequence>\n            <xsd:element name=\"name\" type=\"xsd:string\"/>\n            <xsd:element name=\"age\" type=\"ageType\" />\n            <xsd:element name=\"sex\" type=\"sexType\" />\n        </xsd:sequence>\n        <xsd:attribute name=\"number\" type=\"numberType\" use=\"required\"/>\n    </xsd:complexType>\n    <xsd:simpleType name=\"sexType\">\n        <xsd:restriction base=\"xsd:string\">\n            <xsd:enumeration value=\"male\"/>\n            <xsd:enumeration value=\"female\"/>\n        </xsd:restriction>\n    </xsd:simpleType>\n    <xsd:simpleType name=\"ageType\">\n        <xsd:restriction base=\"xsd:integer\">\n            <xsd:minInclusive value=\"0\"/>\n            <xsd:maxInclusive value=\"256\"/>\n        </xsd:restriction>\n    </xsd:simpleType>\n    <xsd:simpleType name=\"numberType\">\n        <xsd:restriction base=\"xsd:string\">\n            <xsd:pattern value=\"douluo_\\d{4}\"/>\n        </xsd:restriction>\n    </xsd:simpleType>\n</xsd:schema> \n```\n\n相应的xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!-- \n\t1.填写xml文档的根元素\n\t2.引入xsi前缀.  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\t3.引入xsd文件命名空间.  xsi:schemaLocation=\"http://www.itcast.cn/xml  student.xsd\"\n\t4.为每一个xsd约束声明一个前缀,作为标识  xmlns=\"http://www.itcast.cn/xml\" \n\t\n\t\n -->\n<students xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n          xmlns=\"http://www.itcast.cn/xml\"\n          xsi:schemaLocation=\"http://www.itcast.cn/xml  student.xsd\"\n>\n    <student number=\"douluo_0001\">\n        <name>胡列娜</name>\n        <age>22</age>\n        <sex>female</sex>\n    </student>\n    <student number=\"douluo_0002\">\n        <name>水冰儿</name>\n        <age>17</age>\n        <sex>female</sex>\n    </student>\n</students>\n```\n\n以后会碰到的高级一点的写法，先举个例子。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \n\txmlns:context=\"http://www.springframework.org/schema/context\"\n    xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context \n        http://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/mvc\n        http://www.springframework.org/schema/mvc/spring-mvc.xsd\">\n\n    \n    <context:annotation-config />\n\n   \n    <context:component-scan base-package=\"cn.cisol.mvcdemo\">\n        <context:include-filter type=\"annotation\"\n            expression=\"org.springframework.stereotype.Controller\" />\n    </context:component-scan>\n\n   \n    <mvc:annotation-driven />\n\n    \n    <mvc:resources mapping=\"/resources/**\" location=\"/resources/\" />\n\n\n    \n    <bean\n        class=\"org.springframework.web.servlet.view.ContentNegotiatingViewResolver\">\n        <property name=\"order\" value=\"1\" />\n        <property name=\"mediaTypes\">\n            <map>\n                <entry key=\"json\" value=\"application/json\" />\n                <entry key=\"xml\" value=\"application/xml\" />\n                <entry key=\"htm\" value=\"text/html\" />\n            </map>\n        </property>\n\n        <property name=\"defaultViews\">\n            <list>\n                \n                <bean\n                    class=\"org.springframework.web.servlet.view.json.MappingJackson2JsonView\">\n                </bean>\n            </list>\n        </property>\n        <property name=\"ignoreAcceptHeader\" value=\"true\" />\n    </bean>\n\n    <bean\n        class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n        <property name=\"viewClass\"\n            value=\"org.springframework.web.servlet.view.JstlView\" />\n        <property name=\"prefix\" value=\"/WEB-INF/jsps/\" />\n        <property name=\"suffix\" value=\".jsp\" />\n    </bean>\n\n\n  \n    <bean id=\"multipartResolver\"\n        class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\">\n        <property name=\"maxUploadSize\" value=\"209715200\" />\n        <property name=\"defaultEncoding\" value=\"UTF-8\" />\n        <property name=\"resolveLazily\" value=\"true\" />\n    </bean>\n\n</beans>\n```\n\n# 三、XML解析\n\n解析：操作xml文档，将文档中的数据读取到内存中\n\n操作xml文档\n\n* 解析（读取）：将文档中的数据读取到内存中\n* 写入：将内存中的数据保存到xml文档中，持久化地存储\n\n## 3.1 解析xml的思想\n\n1. DOM：将标记语言文档一次性加载进内存，在内存中形成一个DOM树\n   * 优点：操作方便，可以对文档进行CRUD的所有操作\n   * 缺点：占内存\n2. SAX：逐行读取，然后释放。基于事件驱动\n   * 优点：不占内存。像现在手机中，大多使用SAX思想\n   * 思想：只能读取，不能增删改\n\n> 在服务器端，一般使用dom思想。在移动端，一般使用sax思想\n\n## 3.2 xml的常见的解析器\n\n1. JAXP：sun公司提供的解析器，支持dom和sax两种思想。效率很低\n2. DOM4J：一款非常优秀的解析器\n3. Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。\n4. PULL：Android操作系统内置的解析器，sax思想\n\n## 3.3 Jsoup的使用\n\n步骤\n\n1. 导入jar包\n2. 获取Document对象\n3. 获取对应的标签Element对象\n4. 获取数据\n\n快速上手\n\n```java\npublic class Demo01Jsoup {\n    public static void main(String[] args) throws IOException {\n        //获取Document对象\n        //根据xml文档来获取\n        String path=Demo01Jsoup.class.getClassLoader().getResource(\"student.xml\").getPath();\n        //解析xml文档\n        Document dom=Jsoup.parse(new File(path),\"utf-8\");\n        //获取元素对象\n        Elements ele=dom.getElementsByTag(\"name\");\n        System.out.println(ele.size());\n        //获取第一个Element对象\n        Element e=ele.get(0);\n        //获取数据\n        System.out.println(e.text());\n    }\n}\n```\n\n对象的使用\n\n1. Jsoup：工具类，可以解析html和xml文档，返回document\n   * parse(File in, String charsetName)：解析xml或者html\n   * parse(String html)：解析xml或者html的字符串\n   * parse(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象\n   \n2. Document：文档对象。代表内存中的dom树\n   \n   * getElementById(String id)：根据id属性值获取唯一的Element对象\n   \n   * getElementsByTag(String  tagName)：根据标签名称获取元素对象集合\n   * getElementsByAttribute(String skey)：根据属性名称获取元素对象集合\n   * getElementsByAttributeValue(String skey,String value)：根据属性和属性值获取元素对象集合\n   \n3. Elements：元素Element对象的集合。可以当做`ArrayList<Element>`来使用\n\n4. Element：元素对象\n\n   * getElementById(String id)：根据id属性值获取唯一的Element对象\n\n   * getElementsByTag(String  tagName)：根据标签名称获取元素对象集合\n   * getElementsByAttribute(String skey)：根据属性名称获取元素对象集合\n   * getElementsByAttributeValue(String skey,String value)：根据属性和属性值获取元素对象集合\n   * attr(String skey)：根据属性名称获取属性值\n   * text()：获取文本内容\n   * html()：获取标签体的所有内容，包括字标签的字符串内容\n\n5. Node：节点对象。内容太多了，自己看文档\n\n快捷方式使用\n\n1. selector：选择器\n2. XPath：[XPath](https://www.runoob.com/xpath/xpath-tutorial.html) 是一门在 XML 文档中查找信息的语言。需要JsoupXpath.jar\n\n以上内容，下载doc.jar，都能找到详细使用说明，不赘述。\n\n\n\n","tags":["xml"]},{"title":"关于爱情","url":"/blog/2020/what-is-love/","content":"\n爱我好不好，褪去一身骄傲\n\n<!--more-->\n\n# 一、前言\n\n- 爱我好不好 褪去一身骄傲\n- 藏不住的寂寥 等不到依靠\n- 江湖浪滔滔 风雨太飘摇\n- 贪着你的笑 忘了痛的味道\n- 像一团火在烧 怎么可以忘掉\n- 无尽的烦恼 淹没在你怀抱\n- 十指紧扣缠绕 在月光下奔跑\n- 什么都不想要 你爱我就好\n\n\n# 二、重读笑傲\n\n假期读了很多小说，读得越多，相较之下，反而越发觉得，金老爷子的文笔如此之好、眼界如此之广。\n\n趁着假期这段时间，又重读了笑傲。[金庸的《笑傲江湖》](http://www.jinyongwang.com/nxiao/)这本书，我也不知道读了有多少遍了，应该是所有金庸系列中，读得最多的了。\n\n自小就爱读书，到了初中，家人让我读四大名著，想让我感受一下名著的熏陶，结果，名著没读多少，却迷恋上了武侠。\n\n那时候，村大队里的报纸上，还在刊登着金老爷子的《碧血剑》，其实我当时不知道书名是啥，只知道里面有个主人公拿的剑叫做金蛇剑，后来百度了，才知道那本书叫做碧血剑。\n\n金庸也算是我对江湖的启蒙老师吧。\n\n金庸老爷子的书里面，我最喜欢读的，莫过于《笑傲江湖》，很多人说这本书，过于理想化，我并不这么觉得。\n\n初中读笑傲，羡慕令狐冲的际遇，有风清扬为师，以绝顶剑术傍身，可以算是江湖上的佼佼者，威风八面。而且还有那么多可以交心的朋友，像莫大、向问天，以及那些敢当着任我行的面，向令狐冲敬酒的群豪。\n\n高中读笑傲，可怜令狐冲的遭遇，被冤枉偷盗秘籍，又被驱逐出门，最爱的小师妹也嫁与他人，又数次被师父利用。很惨，普通人的话，肯定忍受不了的。假如我是令狐冲，我可能已经疯了，甚至死了。\n\n大学读笑傲，庆幸令狐冲的运气，终有佳偶作伴。\n\n人生得一知己足矣，那么如果是两个，三个，多个呢？令狐冲实在让我羡慕。\n\n当令狐冲犹豫无法护送恒山弟子时，莫大拉起胡琴，你尽管去；当令狐冲拒绝任我行的邀请时，向问天从中为之开脱。\n\n他们懂他，多么可贵的忘年之交。\n\n华山绝顶，当令狐冲驳了任我行面子离去之时，群豪又陆续出来敬酒，要知道，他们可都是服了三尸脑神丹的，他们这是拿自己的性命开玩笑。\n\n这又是多么珍贵的友谊。\n\n友谊可贵，爱情亦可贵。\n\n不知道从什么时候，感觉爱情这种东西，慢慢地变得很虚无缥缈，摸不清，看不透。见证了好多朋友的爱情历程，由相恋到分手。有的仅仅一两年，有的却长途跋涉七八年（从初中到大学），结果还是分开了。\n\n令狐冲却又占尽了天大的好处，终有一人伴他到老。更重要的是，这个人懂他。\n\n重读笑傲，我就想为什么令狐冲有这么好的运气呢？\n\n令狐冲第一次打动任盈盈，是在不知对方真实身份的情况下，像长辈吐露自己对小师妹的思念之情。他对小师妹感情的执着与专一，深深地打动了任盈盈。\n\n由此，就有了五霸岗群豪聚会，大家都来结交令狐冲，争先恐后为他治疗内伤。\n\n这期间，大部分都是为了拍圣姑的马屁，其实并无真实友情，但令狐冲不以自己名门正派的身份自居，与他们畅快饮酒，这样的胸襟气度，也实在让他们心里钦佩。\n\n再到后来与群豪在少林中计，危机之中，计无施劝令狐冲独自下山而不得，也只能长叹，更是让群豪看清了眼前这个浪子虽浮滑无形，却也是重情重义。\n\n以至到了后来群豪不顾性命向令狐冲敬酒，那已经与圣姑的面子无关了，实实在在是令狐冲自己的付出、自己的情义，打动了他们。\n\n令狐冲的一生可以说是大起大落，最后笑傲江湖。\n\n与其说，令狐冲运气好，倒不如说，这个人的品质难得。岳不群待他那样，直到死也不愿想师父的坏处。\n\n现在重读笑傲，教会了我很多为人处世的道理。做人，气量不妨大一些，不要把东西看得太重。\n\n金庸逝世那天，18年10月30号，我还在图书馆学习。金庸的书，从初中一直读到大学，一直想见老爷子一面，终是遗憾。老爷子，一路走好！\n\n等我30多岁，40多岁，等我到老，我还会再来拜读金老爷子的[《笑傲江湖》](http://www.jinyongwang.com/nxiao/)，也许会有了不同的感悟。\n\n# 三、关于爱情\n\n其实我今天本无意写这篇文章。\n\n只是听到了我同学跟她女朋友分开的消息，感慨颇多。\n\n高中的时候，那时候当班长，就有女生隔三差五往我桌洞里塞吃的；甚至有一个女生，在高中毕业当夜，给我打电话，向我表白，当时我让室友接的电话，我对室友说，你跟她说我睡觉了，后来也就，不了了之。\n\n在这之前我是没有感情经历的，其实，我是很怕感情这东西的。因为我知道，即使我喜欢一个人，我是照顾不好她的。我不是很懂得照顾人。\n\n一些家庭的原因，导致了我的性格，尽管我曾努力尝试改过。\n\n刚上大一的时候，我通过刀画社团认识了后来的女朋友，也是我的初恋。\n\n当时也是巧合，她电脑坏了，自己又不会弄，找人弄，而我恰好专业对口。于是就在学长介绍下认识了。\n\n那时，是她追的我，一开始我还是比较抵触的，但是时间久了，抵不过软磨硬泡，只能说她还是有点手段的。接近两个月，我们才确立了男女朋友关系，结果到了最后，是我在众人面前表白的，现在想想就很神奇。\n\n当时我俩算是异地，不在一个学校，相隔28.3公里。也曾逃课只为见一面，也曾因不舍得打车在网吧睡一晚上。\n\n正式成为男女朋友的第一次晚上，她就把自己交给我了，我也初尝了禁果，爽的同时并且心里默默想着，以后一定好好照顾她。\n\n我俩当时一起弄了一个公众号，在上面发一些情话以及小故事，公众号就叫meet_higher（寓意让我们相逢在更高处）。\n\n这也是我这个网站，为什么取名meethigher.top，其实也是相逢在高处的意思。\n\n那段日子，其实是很辛苦的，至少在我大学生活来看，那是过得很苦的一段日子。\n\n那时，家里还是给我一个月1000的生活费。\n\n没有女朋友之前，这些钱，对我自己来说是够花的，生活费600左右，每个月还能省下300多。自己买些新奇玩意，比方说淘点二手东西啊，生活还是很富足的。\n\n有了女朋友，出去开房啊，旅游啊，包括周末去跟女朋友见面啊，给她买零食啊，钱慢慢地就不够花了，后来又用花呗，顶多还是透支下个月生活费。\n\n慢慢地，跟家里要的月生活费从1000到了1500，慢慢地又因为花呗透支的原因，还得跟家里要钱。一个月的生活费，后来算了一下，平均一个月3000左右（确实有点多了，钱就是用来买零食、开房、偶尔的旅游，我俩在一块的消费90%都是我出的，而买的零食，我也基本不舍得吃）。\n\n我妈没多说什么，我爸隔三差五就给我打电话说，那小妮儿骗你钱，谈对象哪有花钱的，我结婚都没花钱（PS:我父母的结合是农村包办婚姻，俩人是没有感情的，但确实是没花钱）。\n\n其实，当时也没怎么乱花钱，至少，跟其他的男朋友相比，我算是比较抠门的了。\n\n父母埋怨我乱花钱，女朋友嫌我抠门，其实我夹在两者之间，是很难受的。\n\n后来，又趁着周末做点兼职，一天80，两天能挣160，好点能挣200冒头，其实还是远远不够的。\n\n一年后的寒假某天，她想出去吃火锅，暗示我该给个红包，其实我当时确实没钱了，我寒假在家，又不干活，总不能还跟家里要钱吧，就没给发红包。\n\n2018年的情人节跟除夕还有春节，是连在一块的，对我来说可以算是个三连击，我终于还是没发红包。\n\n她就说我抠，说别人家的男朋友都给买化妆品，我啥都不给买，抠。\n\n扪心自问，我确实从恋爱开始，都没给她买过化妆品。花出去的钱，也只是吃喝玩乐（但是哪怕吃喝，我买的东西都不舍得吃，都给她吃了，难道她不理解吗？我在学校吃食堂，只点半份菜，让她她能受得了吗？不理解我，反而骂我抠）。\n\n但是我省政府奖学金下来的时候，我立马给她转了一半，这些心意她也不懂，我是真的抠吗？\n\n后来就分手了，分手是我提的，因为我实在受不了了。她甚至还骂了我一句穷逼，很伤。但我穷，确实是事实了。那也是没办法。\n\n> 其实在这之前，也有个导火线。\n>\n> 那是在某次开房的晚上，当时前戏正在兴头上，她就开始说结婚彩礼的事，我顿时没了兴致。\n>\n> 彩礼要40万，我说有点多吧，然后她说，湖南就是这个钱，40万还是少了，然后我没说话。\n>\n> 她又继续自言自语。\n>\n> 结婚之后，她不生娃，生娃遭罪。\n>\n> 结婚之后，她的钱自己花，我得养她，然后我的工资都得上交，因为男的有钱就变坏。\n>\n> 结婚之后，我要买房买车，房不是在北京，就得在湖南，不能跟我父母一起住，可以跟她父母一起住，而且房贷要我自己还。\n>\n> 我当时听了这些火气很大，就是40万彩礼，也得挖干我父母一辈子的积蓄了。还不生娃，不生娃结婚干啥？我妈一直想抱个孙子孙女，不生娃，那结婚的意义不大；说白了，交女朋友的意义，也就只是打炮了；花了那么多钱，就为了打个炮，其实更没有意义了；不处也罢！\n>\n> 反正那天之后，我对她的感情，就有了微妙的变化。\n>\n> 在以前，我可以自己苦点，尽自己最大能力养她；在之后，我一点都不想为了她难为自己和自己家庭。\n>\n> ......\n>\n> 我不去混淆黑白，只讲了一些从我的角度所感所想。\n>\n> 两个人之间还有好多好多的事，说是说不完的，谁对谁错，也搞不明白。\n\n之后，我就把心思全部收到学习上来了，也在图书馆认识了我的同学。从他那里，我学到了很多。\n\n我学习JavaScript的时候，也是他给了我指点，也让我体会到了代码是一种艺术。\n\n每天图书馆我早六点到，他八点到，就坐我对面，然后俩人码一天代码，晚上九点半回去，他就跟我说一些开发中用到的最新技术，推荐我学习的方向。\n\n当时我也是刚分手，就说到了感情上的事，他就说他跟他女朋友感情如何如何好，以及高考毕业那年，他为他女朋友改了志愿，去到了同一个城市。\n\n我都很感动的，扪心自问，我是没那么大魄力去为了一个人，改变自己的意愿。我向来不喜欢受到别人的约束。\n\n他们的爱情，让我羡慕，当然，他们爱情之所以牢固，也是基于彼此的付出。\n\n有一起努力的方向，有彼此互通的心意，我把他俩当做是爱情世界里的榜样，\n\n但是今天，我知道他俩分开了。那么多年的感情（初中到大学），我曾奉为榜样的爱情，突然之间就崩塌了。\n\n俩人处了这么久的感情，到头来，徒增一段伤感回忆罢了。\n\n爱情这东西，原来如此的脆弱，它抵不过金钱的考验，亦抵不过岁月的摧残。\n\n有点伤感，却又很幸运。幸好让我提前知道了这些道理。\n\n# 四、结语\n\n刚才下载资料的时候，无意间找到了一个压缩包，里面放着我跟她的照片，1000张左右吧。\n\n照片里的我们都那么开心，但是，我真的开心了吗？\n\n那，什么又是爱呢，我很迷惑。\n\n单身的我，可以毫不犹豫地一口气租三年阿里云服务器、游戏皮肤想买就买、随时更新换代自己的电子产品，当然，小黄片也是想看就看。单身，多么舒服。\n\n现在是2020-03-18 02:53，陪我的只剩一只猫，它饿了。\n\n{% asset_img 只剩一只猫.jpg 只剩一只猫 %}","tags":["life","reading"]},{"title":"webpack从入门到茎痛","url":"/blog/2020/webpack/","content":"\n\n我要爆肝九个小时，记录学习笔记！\n\n终于肝完了，此时并没有肝到精通，而是肝得蛋疼~\n\n<!--more-->\n\n[webpack官网](https://webpack.js.org/)\n\npowershell[使用教程](https://www.cnblogs.com/lsdb/p/9531338.html)\n\n在cmd中输入powershell即可直接进入，或者通过vscode进入。\n\n发现一个网页的小技巧，即可修改内容\n\n```js\ndocument.body.contentEditable=true\n```\n\n关于js的加载顺序理解，[script脚本async和defer的区别](https://www.cnblogs.com/echolun/p/12614056.html)\n\n今天看[极限挑战](https://v.qq.com/x/cover/mzc00200gacissy/h0032em4q2k.html)，慢步人生路，太有感触了。\n\n严敏一句话，“我们少年时期呢，兜里没有很多钱，但是，另一半的生活很精彩”，很真实了。\n\n我大致在知乎上看了一眼极限挑战的[前世今生](https://zhuanlan.zhihu.com/p/68668726)，文章一看就是个写热文蹭流量那种，不过事实也八九不离十。不仅有很多感慨，或许这就是现实吧。\n\n比方说我现在周末想看个电影，一般都是追忆老电影了，像李连杰、吴京、周星驰系列，漫威系列，以及其他一些老电影，现在新出的电影基本不看，电视剧更不看了。现在整个影视行业的流向就是只要能吸引来流量，干啥都行，无底线。\n\n比方说之前翻拍动漫的魔道祖师、斗破苍穹，以及现在正在拍的斗罗大陆，我看了几眼，说实话，真的恶心。但是网上还有大片大片的狂热女粉，或许她们眼里只要人长得好看，拍得烂不烂都无所谓了。\n\n资本决定了影视行业的流向，资本同样影响了大部分人的价值观，在这个纷扰的社会里，做真自己，太难了。\n\n# 一、webpack初体验\n\nnpm i 跟 npm install 类似又不类似，百度即可\n\n```powershell\nnpm install webpack webpack-cli #普通安装webpack跟webpack-cli\nnpm install webpack webpack-cli -g #全局安装\nnpm install webpack webpack-cli -D #安装并添加到开发依赖 --save-dev 写入devDependencies\nnpm install webpack webpack-cli -S #安装并添加到生产依赖 --save 写入dependencies\n```\n\n> 卸载的话，只需要将install换成uninstall即可，用法如上\n\n开发环境命令：\n\n```powershell\nwebpack ./src/index.js -o ./build/build.js --mode=development\n```\n\nwebpack会以.src/index.js 为入口文件开始打包，打包后输出到./build/build.js\n整体打包环境，是开发环境\n\n生产环境命令：\n\n```powershell\nwebpack ./src/index.js -o ./build/build.js --mode=production\n```\n\nwebpack会以.src/index.js 为入口文件开始打包，打包后输出到./build/build.js\n整体打包环境，是生产环境\n\n结论\n 1. webpack能处理js/json，不能处理css/img等资源\n 2. 生产环境和开发环境将es6模块化编译成浏览器能识别的模块化\n 3. 生产环境比开发环境多一个压缩js代码\n\n# 二、webpack开发环境\n\n## 2.1 打包样式资源\n\n下载需要用到的包\n\n* css-loader\n* style-loader\n* less-loader\n* less\n\nwebpack.config.js\n\n```js\n/*\n webpack.config.js webpack的配置文件\n    作用：指示webpack工作（当运行webpack指令时，会加载里面的配置）\n    所有构建工具都是基于nodejs平台运行的，src下源码采用es6，而模块化（比如webpack.config.js）默认采用commonjs\n*/\n\n// resolve用来拼接路径的方法\nconst { resolve } = require(\"path\");\nmodule.exports = {\n    //webpack配置\n\n    //入口起点\n    entry: \"./src/index.js\",\n    //输出\n    output: {\n        // 输出文件名\n        filename: \"built.js\",\n        // 输出路径 _dirname是nodejs的变量，代表当前文件的目录绝对路径\n        path: resolve(__dirname, \"build\")\n    },\n    // loader的配置\n    module: {\n        rules: [\n\n            // 详细的loader配置\n            // 不同文件必须配置不同loader处理\n            // 配置css\n            {\n                // 正则匹配文件\n                test:/\\.css$/,\n                // 使用哪些loader进行处理\n                use:[\n                    // use数组中loader执行顺序：从右到左，从下到上，依次执行\n                    // 创建style标签，将js中的css样式资源插入进去，添加到head中生效\n                    \"style-loader\",\n                    // 将css文件变成一个commonjs的模块加载到js中，里面的内容是样式的字符串\n                    \"css-loader\"\n                ]\n\n            },\n            // 配置less\n            {\n                test:/\\.less$/,\n                use:[\n                    \"style-loader\",\n                    \"css-loader\",\n                    // 将less文件编译为css文件\n                    \"less-loader\"\n                ]\n            }\n        ]\n\n    },\n    // plugins的配置\n    plugins: [\n        // 详细的plugins配置\n    ],\n    // 模式\n    mode: \"development\",//开发模式\n    // mode: \"production\"\n}\n```\n\n## 2.2 打包HTML资源\n\n下载需要用到的包\n\n* html-webpack-plugin\n\n```js\n/**\n * loader:1.下载 2.使用（配置loader）\n * plugins:1.下载 2.引入 3.使用\n * \n */\n\nconst {resolve}=require(\"path\");\nconst HtmlWebpackPlugin=require(\"html-webpack-plugin\");\nmodule.exports={\n    entry:\"./src/index.js\",\n    output:{\n        filename:\"built.js\",\n        path:resolve(__dirname,\"build\"),\n\n    },\n    module:{\n        rules:[\n\n        ],\n        \n    },\n    plugins:[\n        // plugins的配置\n        // html-webpack-plugin\n        // 功能：默认会创建一个Html文件，引入打包输出的所有资源（js/css）\n        // 需求：需要有结构的html文件\n        new HtmlWebpackPlugin({\n            // 复制\"./src/index.html\",并自动引入打包输出的所有资源（js/css）\n            template:\"./src/index.html\"\n        })\n    ],\n    mode:\"development\"\n}\n```\n\n## 2.3 打包图片资源\n\n下载需要用到的包\n\n* url-loader\n* file-loader\n* html-loader\n\nwebpack.config.js\n\n```js\nconst { resolve } = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\nmodule.exports = {\n    entry: \"./src/index.js\",\n    output: {\n        filename: \"built.js\",\n        path: resolve(__dirname, \"build\")\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.less$/,\n                use: [\n                    'style-loader',\n                    'css-loader',\n                    'less-loader',\n\n                ]\n            },\n            // 问题：处理不了html中的img图片\n            // 处理图片资源\n            {\n                test:/\\.(jpg|png|gif)$/,\n                // 只需使用一个loader即可\n                // 需要下载url-loader和file-loader\n                loader:\"url-loader\",\n                options:{\n                    // 当发现图片大小，小于8kb时，就会被base64处理\n                    // 优点：减少请求数量，减轻服务器压力\n                    // 缺点：图片体积会变大大（导致文件请求速度变慢，所以一般只处理小图片，8-12kb的图片），之前5kb，转换为base64，就会变成8kb，类似等等\n                    limit:8*1024,\n                    /**\n                     * 问题：因为url-loader的es6模块化，使用commonjs解析，而html-loader引入图片使用的是commonjs\n                     * 解析时会出问题：[Object Module]\n                     * 解决：关闭url-loader的es6模块化，使用commonjs解析\n                     */\n                    esModule:false,\n                    // 设置图片名字格式\n                    // hash:10 取图片哈希值前5位\n                    // ext 取文件的原扩展名\n                    // 发现重复文件的时候，不会覆盖，而会保留原文件\n                    name:\"[hash:5].[ext]\"\n                }\n            },\n            {\n                test:/\\.html$/,\n                //处理html文件的img图片（负责引入图片，从而能被url-loader处理）\n                loader:\"html-loader\"\n\n            }\n        ]\n    },\n    plugins: [\n        new HtmlWebpackPlugin({\n            template: \"./src/index.html\"\n        })\n    ],\n    mode:\"development\"\n}\n```\n\n## 2.4 打包其他资源\n\nwebpack.config.js\n\n```js\nconst { resolve } = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\nmodule.exports = {\n    entry: \"./src/index.js\",\n    output: {\n        filename: \"built.js\",\n        path: resolve(__dirname, \"build\")\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.less$/,\n                use: [\n                    \"style-loader\",\n                    \"css-loader\",\n                    \"less-loader\"\n                ]\n            },\n            // 打包其他资源(除了HTML/JS/CSS资源以外的资源)\n            {\n                // 排除css/js/html/less资源\n                exclude: /\\.(css|js|html|less)$/,\n                loader: \"file-loader\",\n                options:{\n                    name:'[hash:5].[ext]'\n                }\n            }\n        ]\n    },\n    plugins: [\n        new HtmlWebpackPlugin({\n            template: \"./src/index.html\"\n        })\n    ],\n    mode: \"development\"\n}\n```\n\n## 2.5 devServer\n\n修改配置文件\n\nwebpack.config.js\n\n```js\nconst { resolve } = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\nmodule.exports = {\n    entry: \"./src/index.js\",\n    output: {\n        filename: \"built.js\",\n        path: resolve(__dirname, \"build\")\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.less$/,\n                use: [\n                    \"style-loader\",\n                    \"css-loader\",\n                    \"less-loader\"\n                ]\n            },\n            // 打包其他资源(除了HTML/JS/CSS资源以外的资源)\n            {\n                // 排除css/js/html/less资源\n                exclude: /\\.(css|js|html|less)$/,\n                loader: \"file-loader\",\n                options: {\n                    name: '[hash:5].[ext]'\n                }\n            }\n        ]\n    },\n    plugins: [\n        new HtmlWebpackPlugin({\n            template: \"./src/index.html\"\n        })\n    ],\n    mode: \"development\",\n    // 开发服务器devServer：用来自动化（自动编译、自动打开浏览器，自动刷新浏览器）\n    // 特点：只会在内存中编译打包，不会有任何输出\n    // 启动devServer指令为：npx webpack-dev-server\n    devServer: {\n        // 跳过检查\n        // 如果是false，则只能访问localhost:3000,\n        // 如果是true，则都可以访问，比方说meethigher.com:3000\n        disableHostCheck: true,\n\n        // 默认打开本地的浏览器\n        open:true,\n        contentBase: resolve(__dirname, \"build\"),\n        // 启动gzip压缩\n        compress: true,\n        // 端口号\n        port: 8080\n    }\n}\n```\n\n运行命令，即可自动打开浏览器执行\n\n```powershell\nnpx webpack-dev-server\n```\n\n## 2.6 开发环境基本配置\n\nwebpack.config.js\n\n```js\n// 这是开发环境配置：能让代码运行起来，在内存中编译打包\n/**\n * 运行项目指令：\n * webpack 会将打包结果输出去\n * npx webpack-dev-server 只会在内存中编译打包，没有输出\n */\n\nconst { resolve } = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\nmodule.exports = {\n    entry: \"./src/js/index.js\",\n    output: {\n        filename: 'js/built.js',\n        path: resolve(__dirname, \"build\")\n    },\n    module: {\n        rules: [\n            // loader的配置\n            // 处理less资源\n            {\n                test: /\\.less$/,\n                use: [\n                    'style-loader',\n                    'css-loader',\n                    'less-loader'\n                ]\n            },\n            // 处理css资源\n            {\n                test: /\\.css$/,\n                use: [\n                    'style-loader',\n                    'css-loader'\n                ]\n            },\n            // 处理图片资源\n            {\n                test: /\\.(jpg||png||gif)$/,\n                loader: \"url-loader\",\n                options: {\n                    limit: 8 * 1024,\n                    name: \"[hash:10].[ext]\",\n                    // 设置使用commonjs，不使用es\n                    esModule: false,\n                    //将图片输出到imgs文件夹\n                    outputPath:\"imgs\"\n                }\n            },\n            // 处理html中的img资源\n            {\n                test: /\\.html$/,\n                loader: \"html-loader\",\n            },\n            // 处理其他资源\n            {\n                exclude: /\\.(html|css|js|less|jpg|png|gif)$/,\n                loader: \"file-loader\",\n                options: {\n                    name: \"[hash:10].[ext]\",\n                    // 将其他资源输出到media文件夹\n                    outputPath:\"media\"\n                }\n            }\n        ]\n    },\n    plugins: [\n        // plugins的配置\n        // 相当于是引入一个模板\n        new HtmlWebpackPlugin({\n            template: \"./src/index.html\"\n        })\n    ],\n    mode:\"development\",\n    // devServer\n    devServer: {\n        contentBase: resolve(__dirname, \"build\"),\n        compress: true,\n        port: 8080,\n        open: true\n    }\n}\n```\n\n# 三、webpack生产环境\n\n## 3.1 css提取\n\nwebpack.config.js\n\n```js\nconst {resolve}=require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\n\nconst miniCssExtractPlugin=require(\"mini-css-extract-plugin\");\nmodule.exports={\n    entry:\"./src/js/index.js\",\n    output:{\n        filename:\"./js/built.js\",\n        path:resolve(__dirname,\"build\"),\n    },\n    module:{\n        rules:[\n            {\n                test:/\\.css$/,\n                use:[\n                    // 创建style标签，将样式放入\n                    // \"style-loader\",\n                    // 这个loader取代style-loader。作用：提取css成单独文件\n                    miniCssExtractPlugin.loader,\n                    \"css-loader\"\n                ]\n            }\n        ]\n    },\n    plugins:[\n        new HtmlWebpackPlugin({\n            template:\"./src/index.html\"\n        }),\n        new miniCssExtractPlugin({\n            // 输出文件\n            filename:\"./css/built.css\"\n        })\n    ],\n    mode:\"development\"\n}\n```\n\n## 3.2 css兼容性处理\n\n需要安装的插件\n\n```powershell\nnpm install postcss-loader postcss-preset-env -D\n```\n\nwebpack.config.js\n\n```js\nconst { resolve } = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\n\n//设置nodejs的环境变量，此处是用来设置package.json中browserlist以什么模式来兼容\n// process.env.NODE_ENV=\"development\";\n\nconst miniCssExtractPlugin = require(\"mini-css-extract-plugin\");\nmodule.exports = {\n    entry: \"./src/js/index.js\",\n    output: {\n        filename: \"./js/built.js\",\n        path: resolve(__dirname, \"build\"),\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.css$/,\n                use: [\n                    // 创建style标签，将样式放入\n                    // \"style-loader\",\n                    // 这个loader取代style-loader。作用：提取css成单独文件\n                    miniCssExtractPlugin.loader,\n                    \"css-loader\",\n                    /**\n                     * css兼容性处理\n                     * 需要用到postcss，这需要两个包postcss-loader、postcss-preset-env\n                     * 帮助postcss找到package.json中browserlist里面的配置，通过配置加载指定的css兼容性样式\n                     */\n\n                    /**\n                     * 在browserslist配置下面内容，通过process.env.NODE_ENV=\"development\"，来配置browserslist的运行模式\n                     * \"browserslist\":{\n                     * \"development\":[\n                     *    \"last 1 chrome version\",\n                     *    \"last 1 firefox version\",\n                     *    \"last 1 safari version\"\n                     *  ],\n                     *  \"production\":[\n                     *    \">0.2%\",\n                     *    \"not dead\",\n                     *    \"no op_mini all\"\n                     *  ]\n                     * }\n                     */\n                    //两种写法，第一种是默认配置\n                    // \"post-loader\",\n                    //第二种修改配置\n                    {\n                        loader: \"postcss-loader\",\n                        options: {\n                            ident: \"postcss\",\n                            plugins: () => [\n                                // postcss的插件\n                                require(\"postcss-preset-env\")\n                            ]\n                        }\n                    }\n                ]\n            }\n        ]\n    },\n    plugins: [\n        new HtmlWebpackPlugin({\n            template: \"./src/index.html\"\n        }),\n        new miniCssExtractPlugin({\n            // 输出文件\n            filename: \"./css/built.css\"\n        })\n    ],\n    mode: \"development\"\n}\n```\n\n> 关于browserslist的配置，可以在github搜索获得\n\n## 3.3 压缩css\n\n安装插件\n\n```powershell\nnpm install optimize-css-assets-webpack-plugin -D\n```\n\nwebpack.config.js\n\n```js\nconst { resolve } = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\n\n//设置nodejs的环境变量，此处是用来设置package.json中browserlist以什么模式来兼容\nprocess.env.NODE_ENV=\"development\";\n\nconst optimizeCssAssetsWebpack=require(\"optimize-css-assets-webpack-plugin\");\n\nconst miniCssExtractPlugin = require(\"mini-css-extract-plugin\");\nmodule.exports = {\n    entry: \"./src/js/index.js\",\n    output: {\n        filename: \"./js/built.js\",\n        path: resolve(__dirname, \"build\"),\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.css$/,\n                use: [\n                    // 创建style标签，将样式放入\n                    // \"style-loader\",\n                    // 这个loader取代style-loader。作用：提取css成单独文件\n                    miniCssExtractPlugin.loader,\n                    \"css-loader\",\n                    /**\n                     * css兼容性处理\n                     * 需要用到postcss，这需要两个包postcss-loader、postcss-preset-env\n                     * 帮助postcss找到package.json中browserlist里面的配置，通过配置加载指定的css兼容性样式\n                     */\n\n                    /**\n                     * 在browserslist配置下面内容，通过process.env.NODE_ENV=\"development\"，来配置browserslist的运行模式\n                     * \"browserslist\":{\n                     * \"development\":[\n                     *    \"last 1 chrome version\",\n                     *    \"last 1 firefox version\",\n                     *    \"last 1 safari version\"\n                     *  ],\n                     *  \"production\":[\n                     *    \">0.2%\",\n                     *    \"not dead\",\n                     *    \"no op_mini all\"\n                     *  ]\n                     * }\n                     */\n                    //两种写法，第一种是默认配置\n                    // \"post-loader\",\n                    //第二种修改配置\n                    {\n                        loader: \"postcss-loader\",\n                        options: {\n                            ident: \"postcss\",\n                            plugins: () => [\n                                // postcss的插件\n                                require(\"postcss-preset-env\")\n                            ]\n                        }\n                    }\n                ]\n            }\n        ]\n    },\n    plugins: [\n        // 打包html\n        new HtmlWebpackPlugin({\n            template: \"./src/index.html\"\n        }),\n        //提取css\n        new miniCssExtractPlugin({\n            // 输出文件\n            filename: \"./css/built.css\"\n        }),\n        // 压缩css，直接使用默认配置即可\n        new optimizeCssAssetsWebpack()\n    ],\n    mode: \"development\"\n}\n```\n\n## 3.4 js语法检查\n\n可以参照[js规则](https://github.com/airbnb/javascript)\n\n```powershell\nnpm install eslint-config-airbnb-base eslint eslint-plugin-import eslint-loader -D\n```\n\nwebpack.config.js\n\n```js\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\nconst {resolve}=require(\"path\");\nmodule.exports={\n    entry:\"./src/js/index.js\",\n    output:{\n        filename:\"js/built.js\",\n        path:resolve(__dirname,\"build\")\n    },\n    module:{\n        rules:[\n            /**\n             * 语法检查，需要安装eslint-loader eslint\n             * 注意：只检查自己写的源代码，不检查第三方库，通过exclude排除第三方库\n             * 设置检查规则：package.json中eslintConfig中设置\n             * 推荐使用airbnb规则->eslint-config-airbnb-base eslint eslint-plugin-import\n             * 在package.json中进行配置\n             * \"eslintConfig\":{\n             *   \"extends\":\"airbnb-base\"\n             * },\n             * \n             * 如果某些js代码需要忽略检查，可以通过添加// eslint-disable-next-line，来使下一行检测失效\n             */\n            {\n                test:/\\.js$/,\n                exclude:/node-modules/,\n                loader:\"eslint-loader\",\n                options:{\n                    // 自动修复eslint的错误\n                    fix:true\n                }\n            }\n        ]\n    },\n    plugins:[\n        new HtmlWebpackPlugin({\n            template:\"./src/index.html\"\n        }),\n    ],\n    mode:\"development\"\n}\n```\n\n## 3.5 js兼容性处理\n\n兼容性处理\n\n1. 基本兼容性\n2. 全部兼容性\n3. 按需兼容性\n\n```js\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\nconst {resolve}=require(\"path\");\nmodule.exports={\n    entry:\"./src/js/index.js\",\n    output:{\n        filename:\"js/built.js\",\n        path:resolve(__dirname,\"build\")\n    },\n    module:{\n        rules:[\n            /**\n             * js基本兼容性处理：babel-loader @babel/preset-env @babel/core\n             * 问题：只能转换基本语法，如es6中promise就不能转换\n             * \n             * js全部兼容性处理：@babel/polyfill，只需要在index.js中引入即可import \"@babel/polyfill\";\n             * 问题：需求是解决部分兼容，但是所有兼容代码都被引入，体积太大\n             * \n             * js部分兼容性处理：按需加载-->core-js，不需要在index.js引入import \"@babel/polyfill\"\n             */\n            {\n                test:/\\.js$/,\n                //排除\n                exclude:/node_modules/,\n                loader:\"babel-loader\",\n                options:{\n                    //预设：指示babel做哪些兼容性处理，只有presets:[\"@babel/preset-env\"]这一个表示全部兼容性处理\n                    presets:[\n                        [\n                            \"@babel/preset-env\",\n                            // 按需加载\n                            {\n                                useBuiltIns:\"usage\",\n                                // 指定corejs版本\n                                corejs:{\n                                    version:3\n                                },\n                                // 指定兼容性做到哪个版本浏览器\n                                targets:{\n                                    chrome:\"60\",\n                                    firefox:\"50\",\n                                    ie:\"9\",\n                                    safari:\"10\",\n                                    edge:\"17\"\n                                }\n                            }\n                        ]\n                    ],\n                }\n            }\n        ]\n    },\n    plugins:[\n        new HtmlWebpackPlugin({\n            template:\"./src/index.html\"\n        }),\n    ],\n    mode:\"development\"\n}\n```\n\n## 3.6 压缩html与js\n\nwebpack.config.js\n\n```js\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\nconst {resolve}=require(\"path\");\nmodule.exports={\n    entry:\"./src/js/index.js\",\n    output:{\n        filename:\"js/built.js\",\n        path:resolve(__dirname,\"build\")\n    },\n    plugins:[\n        new HtmlWebpackPlugin({\n            template:\"./src/index.html\",\n            // 压缩html\n            minify:{\n                // 移除空格\n                collapseWhitespace:true,\n                // 移除注释\n                removeComments:true\n            }\n        }),\n    ],\n    //生产环境下自动压缩js代码\n    mode:\"production\"\n}\n```\n\n## 3.7 生产环境基本配置\n\nwebpack.config.js\n\n```js\nconst { resolve } = require(\"path\");\nconst miniCssExtractPlugin = require(\"mini-css-extract-plugin\");\nconst optimizeCssAssetsWebpackPlugin=require(\"optimize-css-assets-webpack-plugin\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\n\n//设置nodejs的环境变量，此处是用来设置package.json中browserlist以什么模式来兼容\nprocess.env.NODE_ENV = \"production\";\n\n// 复用loader\nconst commonCssLoader = [\n    miniCssExtractPlugin.loader,\n    \"css-loader\",\n    // 兼容性处理\n    {\n        // 在package.json中需要配置browserslist\n        loader: \"postcss-loader\",\n        options: {\n            ident: \"postcss\",\n            plugins: () => [\n                require(\"postcss-preset-env\")()\n            ]\n        }\n    }\n];\nmodule.exports = {\n    entry: \"./src/js/index.js\",\n    output: {\n        filename: \"js/built.js\",\n        path: resolve(__dirname, \"build\")\n    },\n    module: {\n        rules: [\n            //提取css文件\n            // 兼容性处理\n            {\n                test: /\\.css$/,\n                use: [\n                    ...commonCssLoader\n                ]\n            },\n            {\n                test: /\\.less$/,\n                use: [\n                    ...commonCssLoader,\n                    \"less-loader\"\n                ]\n            },\n            // js语法检查\n            /**\n             * 正常来讲，一个文件只能被一个loader处理\n             * 当一个文件要被多个loader处理时，那么一定要指定loader执行的先后顺序\n             * 先执行eslint，再执行babel\n             */\n            {\n                // 在package.json中需要配置eslintConfig->airbnb\n                test:/\\.js$/,\n                exclude:/node_modules/,\n                loader:\"eslint-loader\",\n                // 自动修复语法\n                options:{\n                    fix:true\n                },\n                // 优先执行\n                enforce:\"pre\"\n            },\n            // js兼容性处理\n            {\n                test:/\\.js$/,\n                exclude:/node_modules/,\n                loader:\"babel-loader\",\n                options:{\n                    presets:[\n                        [\n                            \"@babel/preset-env\",\n                            {\n                                useBuiltIns:\"usage\",\n                                corejs:{version:3},\n                                targets:{\n                                    chrome:\"60\",\n                                    firefox:\"50\",\n                                    ie:\"9\",\n                                    safari:\"10\",\n                                    edge:\"17\"\n                                }\n                            }\n                        ],\n                    ]\n                }\n            },\n            // 处理图片\n            {\n                test:/\\.(jpg|png|gif)$/,\n                loader:\"url-loader\",\n                options:{\n                    limit:8*1024,//8kb以下进行base64处理\n                    name:\"[hash:10].[ext]\",\n                    outputPath:\"imgs\",\n                    esModule:false\n                }\n            },\n            // 处理html中的图片\n            {\n                test:/\\.html$/,\n                loader:\"html-loader\", \n            },\n            // 处理其他文件\n            {\n                exclude:/\\.(js|css|less|html|jpg|png|gif)$/,\n                loader:\"file-loader\",\n                options:{\n                    outputPath:\"media\"\n                }\n            }\n\n        ]\n    },\n    plugins: [\n        new miniCssExtractPlugin({\n            filename: \"css/built.css\"\n        }),\n        //压缩css\n        new optimizeCssAssetsWebpackPlugin(),\n        new HtmlWebpackPlugin({\n            template:\"./src/index.html\",\n            // 压缩html\n            minify:{\n                collapseWhitespace:true,\n                removeComments:true\n            }\n        })\n\n    ],\n    mode: \"production\",\n    devServer: {\n        // 跳过检查\n        // 如果是false，则只能访问localhost:3000,\n        // 如果是true，则都可以访问，比方说meethigher.com:3000\n        disableHostCheck: true,\n\n        // 默认打开本地的浏览器\n        open:true,\n        contentBase: resolve(__dirname, \"build\"),\n        // 启动gzip压缩\n        compress: true,\n        // 端口号\n        port: 8080\n    }\n}\n```\n\n# 四、webpack优化配置\n\n## 4.1 HMR\n\nwebpack.config.js\n\n```js\n/**\n * 问题：只修改部分内容，结果所有内容都重新加载\n * \n * HMR:hot module replacement 热模块替换/模块热替换\n * 作用：一个模块发生变化，只会重新打包这一个模块，而不是打包所有\n * 极大地提升构建速度\n *\n * 样式文件：可以使用HMR，因为style-loader内部实现了\n * js文件：默认没HMR功能->需要修改js代码，添加支持HMR功能的代码\n *   只能处理非入口js文件\n * html文件：默认没HMR功能，同时会导致问题->html不能热更新了(因为实际使用中只有一个index.html，不像js有多个模块，所以不用做hmr功能)\n *   解决：修改entry入口，将html文件引入，但是会全部刷新\n */\n\nconst { resolve } = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\nmodule.exports = {\n    entry: [\"./src/js/index.js\",\"./src/index.html\"],\n    output: {\n        filename: 'js/built.js',\n        path: resolve(__dirname, \"build\")\n    },\n    module: {\n        rules: [\n            // loader的配置\n            // 处理less资源\n            {\n                test: /\\.less$/,\n                use: [\n                    'style-loader',\n                    'css-loader',\n                    'less-loader'\n                ]\n            },\n            // 处理css资源\n            {\n                test: /\\.css$/,\n                use: [\n                    'style-loader',\n                    'css-loader'\n                ]\n            },\n            // 处理图片资源\n            {\n                test: /\\.(jpg||png||gif)$/,\n                loader: \"url-loader\",\n                options: {\n                    limit: 8 * 1024,\n                    name: \"[hash:10].[ext]\",\n                    // 设置使用commonjs，不使用es\n                    esModule: false,\n                    //将图片输出到imgs文件夹\n                    outputPath:\"imgs\"\n                }\n            },\n            // 处理html中的img资源\n            {\n                test: /\\.html$/,\n                loader: \"html-loader\",\n            },\n            // 处理其他资源\n            {\n                exclude: /\\.(html|css|js|less|jpg|png|gif)$/,\n                loader: \"file-loader\",\n                options: {\n                    name: \"[hash:10].[ext]\",\n                    // 将其他资源输出到media文件夹\n                    outputPath:\"media\"\n                }\n            }\n        ]\n    },\n    plugins: [\n        // plugins的配置\n        // 相当于是引入一个模板\n        new HtmlWebpackPlugin({\n            template: \"./src/index.html\"\n        })\n    ],\n    mode:\"development\",\n    // devServer\n    devServer: {\n        disableHostCheck: true,\n        contentBase: resolve(__dirname, \"build\"),\n        compress: true,\n        port: 8080,\n        open: true,\n        // 开启HMR功能，并重启服务\n        hot:true\n    }\n}\n```\n\nindex.js\n\n```js\nimport \"../css/index.less\";\nimport print from \"./print.js\"\n\nconsole.log(\"index.js被加载了\"+new Date().toLocaleString());\nfunction add(x,y){\n    return x+y;\n}\nprint();\nconsole.log(add(1,2));\n\n// 全局找hot属性，一旦为true，说明开启了HMR功能，->让HMR功能生效\nif(module.hot){\n    // 如果后续还有其他模块，同样的方法\n    module.hot.accept(\"./print.js\",function (){\n        // 方法会监听 print.js文件的变化，一旦发生变化，其他模块不会重新打包构建\n        //会执行后面的回调函数\n        print();\n    })\n}\n\n```\n\n## 4.2 source-map\n\nwebpack.config.js\n\n```js\nconst { resolve } = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\nmodule.exports = {\n    entry: [\"./src/js/index.js\", \"./src/index.html\"],\n    output: {\n        filename: 'js/built.js',\n        path: resolve(__dirname, \"build\")\n    },\n    module: {\n        rules: [\n            // loader的配置\n            // 处理less资源\n            {\n                test: /\\.less$/,\n                use: [\n                    'style-loader',\n                    'css-loader',\n                    'less-loader'\n                ]\n            },\n            // 处理css资源\n            {\n                test: /\\.css$/,\n                use: [\n                    'style-loader',\n                    'css-loader'\n                ]\n            },\n            // 处理图片资源\n            {\n                test: /\\.(jpg||png||gif)$/,\n                loader: \"url-loader\",\n                options: {\n                    limit: 8 * 1024,\n                    name: \"[hash:10].[ext]\",\n                    // 设置使用commonjs，不使用es\n                    esModule: false,\n                    //将图片输出到imgs文件夹\n                    outputPath: \"imgs\"\n                }\n            },\n            // 处理html中的img资源\n            {\n                test: /\\.html$/,\n                loader: \"html-loader\",\n            },\n            // 处理其他资源\n            {\n                exclude: /\\.(html|css|js|less|jpg|png|gif)$/,\n                loader: \"file-loader\",\n                options: {\n                    name: \"[hash:10].[ext]\",\n                    // 将其他资源输出到media文件夹\n                    outputPath: \"media\"\n                }\n            }\n        ]\n    },\n    plugins: [\n        // plugins的配置\n        // 相当于是引入一个模板\n        new HtmlWebpackPlugin({\n            template: \"./src/index.html\"\n        })\n    ],\n    mode: \"development\",\n    // devServer\n    devServer: {\n        disableHostCheck: true,\n        contentBase: resolve(__dirname, \"build\"),\n        compress: true,\n        port: 8080,\n        open: true,\n        // 开启HMR功能，并重启服务\n        hot: true\n    },\n    // source-map:一种提供源代码到构建后代码映射技术（如果构建后代码出错了，通过映射关系可以追踪到源代码错误）\n    /**\n     * 参数\n     * [inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map\n     * \n     * source-map：外部\n     *   错误代码准确信息和源代码的错误位置\n     * inline-source-map：内联，只生成一个内联的source-map\n     *   错误代码准确信息和源代码的错误位置\n     * hidden-source-map：外部\n     *   错误代码错误原因，但是没有错误位置，不能追踪到源代码的错误，只能提示到构建后代码的位置\n     * eval-source-map：也是内联，每一个文件都生成一个source-map   \n     *   错误代码准确信息和源代码的错误位置，文件名后缀多了哈希值\n     * nosources-source-map：外部\n     *   错误代码准确信息，没有任何源代码信息\n     * cheap-source-map：外部\n     *   错误代码准确信息和源代码的错误位置，错误只能精确到行，不能精确到列\n     * cheap-module-source-map：外部\n     *   错误代码准确信息和源代码的错误位置，错误只能精确到行，不能精确到列\n     *   module会将loader的source-map也加进来\n     * \n     * 内联和外部：\n     * 1. 外部生成的文件，内联是没有的\n     * 2. 内联速度更快\n     * \n     * 开发环境：速度快，调试更友好\n     *   速度快：eval>inline>cheap>...\n     *     eval-cheap-source-map>eval-source-map\n     *   调试更友好：\n     *     source-map>cheap-module-source-map>cheap-source-map\n     *   一般使用eval-source-map/eval-cheap-module-source-map\n     * \n     * 生产环境：源代码要不要隐藏？调试要不要更友好？\n     *   内联会让代码体积变大，所以在生产环境不用内联\n     *   隐藏源代码↓\n     *   nosources-source-map\n     *   hidden-source-map\n     *   一般使用source-map/cheap-module-source-map\n     */\n    devtool: \"inline-source-map\"\n};\n```\n\n## 4.3 oneOf\n\nwebpack.config.js\n\n```js\nconst { resolve } = require(\"path\");\nconst miniCssExtractPlugin = require(\"mini-css-extract-plugin\");\nconst optimizeCssAssetsWebpackPlugin = require(\"optimize-css-assets-webpack-plugin\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\n\n//设置nodejs的环境变量，此处是用来设置package.json中browserlist以什么模式来兼容\nprocess.env.NODE_ENV = \"production\";\n\n// 复用loader\nconst commonCssLoader = [\n    miniCssExtractPlugin.loader,\n    \"css-loader\",\n    // 兼容性处理\n    {\n        // 在package.json中需要配置browserslist\n        loader: \"postcss-loader\",\n        options: {\n            ident: \"postcss\",\n            plugins: () => [\n                require(\"postcss-preset-env\")()\n            ]\n        }\n    }\n];\nmodule.exports = {\n    entry: \"./src/js/index.js\",\n    output: {\n        filename: \"js/built.js\",\n        path: resolve(__dirname, \"build\")\n    },\n    module: {\n        rules: [\n            // js语法检查\n            /**\n             * 正常来讲，一个文件只能被一个loader处理\n             * 当一个文件要被多个loader处理时，那么一定要指定loader执行的先后顺序\n             * 先执行eslint，再执行babel\n             */\n            {\n                // 在package.json中需要配置eslintConfig->airbnb\n                test: /\\.js$/,\n                exclude: /node_modules/,\n                loader: \"eslint-loader\",\n                // 自动修复语法\n                options: {\n                    fix: true\n                },\n                // 优先执行\n                enforce: \"pre\"\n            },\n            {\n                //以下loader只会匹配一个，用来优化打包速度\n                //注意：不能有两个配置处理同一种类型文件，所以需要将重复内容提取出来\n                oneOf: [\n                    //提取css文件\n                    // 兼容性处理\n                    {\n                        test: /\\.css$/,\n                        use: [\n                            ...commonCssLoader\n                        ]\n                    },\n                    {\n                        test: /\\.less$/,\n                        use: [\n                            ...commonCssLoader,\n                            \"less-loader\"\n                        ]\n                    },\n                    // js兼容性处理\n                    {\n                        test: /\\.js$/,\n                        exclude: /node_modules/,\n                        loader: \"babel-loader\",\n                        options: {\n                            presets: [\n                                [\n                                    \"@babel/preset-env\",\n                                    {\n                                        useBuiltIns: \"usage\",\n                                        corejs: { version: 3 },\n                                        targets: {\n                                            chrome: \"60\",\n                                            firefox: \"50\",\n                                            ie: \"9\",\n                                            safari: \"10\",\n                                            edge: \"17\"\n                                        }\n                                    }\n                                ],\n                            ]\n                        }\n                    },\n                    // 处理图片\n                    {\n                        test: /\\.(jpg|png|gif)$/,\n                        loader: \"url-loader\",\n                        options: {\n                            limit: 8 * 1024,//8kb以下进行base64处理\n                            name: \"[hash:10].[ext]\",\n                            outputPath: \"imgs\",\n                            esModule: false\n                        }\n                    },\n                    // 处理html中的图片\n                    {\n                        test: /\\.html$/,\n                        loader: \"html-loader\",\n                    },\n                    // 处理其他文件\n                    {\n                        exclude: /\\.(js|css|less|html|jpg|png|gif)$/,\n                        loader: \"file-loader\",\n                        options: {\n                            outputPath: \"media\"\n                        }\n                    }\n\n                ]\n            }\n        ]\n    },\n    plugins: [\n        new miniCssExtractPlugin({\n            filename: \"css/built.css\"\n        }),\n        //压缩css\n        new optimizeCssAssetsWebpackPlugin(),\n        new HtmlWebpackPlugin({\n            template: \"./src/index.html\",\n            // 压缩html\n            minify: {\n                collapseWhitespace: true,\n                removeComments: true\n            }\n        })\n\n    ],\n    mode: \"production\",\n    devServer: {\n        // 跳过检查\n        // 如果是false，则只能访问localhost:3000,\n        // 如果是true，则都可以访问，比方说meethigher.com:3000\n        disableHostCheck: true,\n\n        // 默认打开本地的浏览器\n        open: true,\n        contentBase: resolve(__dirname, \"build\"),\n        // 启动gzip压缩\n        compress: true,\n        // 端口号\n        port: 8080\n    }\n}\n```\n\n## 4.4 缓存\n\nserver.js\n\n```js\n/**服务器代码\n * 启动服务器指令\n * npm install nodemon -g\n * nodemon server.js\n * 或者\n * node server.js \n */\nconst express=require(\"express\");\nconst app=express();\n\napp.use(express.static(\"build\",{\n    maxAge:1000*3600\n}));\napp.listen(8080);\n```\n\nwebpack.config.js\n\n```js\n/**\n * 缓存\n *   1. babel缓存\n *     cacheDirectory:true\n *     -->让第二次打包构建速度更快\n *   2. 文件资源缓存，文件名添加哈希值\n *     hash\n *     问题：因为js和css同时使用一个哈希值，如果重新打包，会导致所有缓存失效（可能只改动了一个文件）\n * \n *     chunkhash：根据chunk生成的hash，如果打包来源于同一个chunk，那么hash就一样\n *     问题：js和css的hash还是一样的\n *         因为css是在js中被引入的，同属于一个chunk\n * \n *     contenthash：根据文件内容生成hash。不同文件hash一定不一样\n *     -->让代码上线运行缓存更好使用\n */\n\nconst { resolve } = require(\"path\");\nconst miniCssExtractPlugin = require(\"mini-css-extract-plugin\");\nconst optimizeCssAssetsWebpackPlugin = require(\"optimize-css-assets-webpack-plugin\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\n\n//设置nodejs的环境变量，此处是用来设置package.json中browserlist以什么模式来兼容\nprocess.env.NODE_ENV = \"production\";\n\n// 复用loader\nconst commonCssLoader = [\n    miniCssExtractPlugin.loader,\n    \"css-loader\",\n    // 兼容性处理\n    {\n        // 在package.json中需要配置browserslist\n        loader: \"postcss-loader\",\n        options: {\n            ident: \"postcss\",\n            plugins: () => [\n                require(\"postcss-preset-env\")()\n            ]\n        }\n    }\n];\n\nmodule.exports = {\n    entry: [\"./src/js/index.js\", \"./src/index.html\"],\n    output: {\n        filename: 'js/built.[contenthash:10].js',\n        path: resolve(__dirname, \"build\")\n    },\n    module: {\n        rules: [\n            // js语法检查\n            /**\n             * 正常来讲，一个文件只能被一个loader处理\n             * 当一个文件要被多个loader处理时，那么一定要指定loader执行的先后顺序\n             * 先执行eslint，再执行babel\n             */\n            {\n                // 在package.json中需要配置eslintConfig->airbnb\n                test: /\\.js$/,\n                exclude: /node_modules/,\n                loader: \"eslint-loader\",\n                // 自动修复语法\n                options: {\n                    fix: true\n                },\n                // 优先执行\n                enforce: \"pre\"\n            },\n            {\n                //以下loader只会匹配一个，用来优化打包速度\n                //注意：不能有两个配置处理同一种类型文件，所以需要将重复内容提取出来\n                oneOf: [\n                    //提取css文件\n                    // 兼容性处理\n                    {\n                        test: /\\.css$/,\n                        use: [\n                            ...commonCssLoader\n                        ]\n                    },\n                    {\n                        test: /\\.less$/,\n                        use: [\n                            ...commonCssLoader,\n                            \"less-loader\"\n                        ]\n                    },\n                    // js兼容性处理\n                    {\n                        test: /\\.js$/,\n                        exclude: /node_modules/,\n                        loader: \"babel-loader\",\n                        options: {\n                            presets: [\n                                [\n                                    \"@babel/preset-env\",\n                                    {\n                                        useBuiltIns: \"usage\",\n                                        corejs: { version: 3 },\n                                        targets: {\n                                            chrome: \"60\",\n                                            firefox: \"50\",\n                                            ie: \"9\",\n                                            safari: \"10\",\n                                            edge: \"17\"\n                                        }\n                                    }\n                                ],\n                            ],\n                            // 开启babel缓存\n                            cacheDirectory:true\n                        }\n                    },\n                    // 处理图片\n                    {\n                        test: /\\.(jpg|png|gif)$/,\n                        loader: \"url-loader\",\n                        options: {\n                            limit: 8 * 1024,//8kb以下进行base64处理\n                            name: \"[hash:10].[ext]\",\n                            outputPath: \"/imgs\",\n                            esModule: false\n                        }\n                    },\n                    // 处理html中的图片\n                    {\n                        test: /\\.html$/,\n                        loader: \"html-loader\",\n                    },\n                    // 处理其他文件\n                    {\n                        exclude: /\\.(js|css|less|html|jpg|png|gif)$/,\n                        loader: \"file-loader\",\n                        options: {\n                            outputPath: \"/media\"\n                        }\n                    }\n\n                ]\n            }\n        ]\n    },\n    plugins: [\n        new miniCssExtractPlugin({\n            filename: \"css/built.[contenthash:10].css\"\n        }),\n        //压缩css\n        new optimizeCssAssetsWebpackPlugin(),\n        new HtmlWebpackPlugin({\n            template: \"./src/index.html\",\n            // 压缩html\n            minify: {\n                collapseWhitespace: true,\n                removeComments: true\n            }\n        })\n    ],\n    mode: \"development\",\n    // devServer\n    devServer: {\n        disableHostCheck: true,\n        contentBase: resolve(__dirname, \"build\"),\n        compress: true,\n        port: 8080,\n        open: true,\n        // 开启HMR功能，并重启服务\n        hot: true\n    },\n    // source-map:一种提供源代码到构建后代码映射技术（如果构建后代码出错了，通过映射关系可以追踪到源代码错误）\n    devtool: \"inline-source-map\"\n};\n```\n\n## 4.5 tree shaking\n\n目的：去掉无用的代码\n\nwebpack.config.js\n\n```js\n/**\n * tree shaking：去除无用代码\n *  前提：1. 必须使用es6模块化 2. 开启production环境\n *  作用：减少代码体积\n * \n *  在package.json中配置\"sideEffects\":false，表示所有代码都没有副作用，都可以进行treeshaking\n *  问题：可能会把css/@babel/polyfill干掉，因为没有使用\n *  可以进行标记\n *  \"sideEffects\":[\"*.css\",\"*.less\"]\n */\n\nconst { resolve } = require(\"path\");\nconst miniCssExtractPlugin = require(\"mini-css-extract-plugin\");\nconst optimizeCssAssetsWebpackPlugin = require(\"optimize-css-assets-webpack-plugin\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\n\n//设置nodejs的环境变量，此处是用来设置package.json中browserlist以什么模式来兼容\nprocess.env.NODE_ENV = \"production\";\n\n// 复用loader\nconst commonCssLoader = [\n    miniCssExtractPlugin.loader,\n    \"css-loader\",\n    // 兼容性处理\n    {\n        // 在package.json中需要配置browserslist\n        loader: \"postcss-loader\",\n        options: {\n            ident: \"postcss\",\n            plugins: () => [\n                require(\"postcss-preset-env\")()\n            ]\n        }\n    }\n];\n\nmodule.exports = {\n    entry: [\"./src/js/index.js\", \"./src/index.html\"],\n    output: {\n        filename: 'js/built.[contenthash:10].js',\n        path: resolve(__dirname, \"build\")\n    },\n    module: {\n        rules: [\n            // js语法检查\n            /**\n             * 正常来讲，一个文件只能被一个loader处理\n             * 当一个文件要被多个loader处理时，那么一定要指定loader执行的先后顺序\n             * 先执行eslint，再执行babel\n             */\n            {\n                // 在package.json中需要配置eslintConfig->airbnb\n                test: /\\.js$/,\n                exclude: /node_modules/,\n                loader: \"eslint-loader\",\n                // 自动修复语法\n                options: {\n                    fix: true\n                },\n                // 优先执行\n                enforce: \"pre\"\n            },\n            {\n                //以下loader只会匹配一个，用来优化打包速度\n                //注意：不能有两个配置处理同一种类型文件，所以需要将重复内容提取出来\n                oneOf: [\n                    //提取css文件\n                    // 兼容性处理\n                    {\n                        test: /\\.css$/,\n                        use: [\n                            ...commonCssLoader\n                        ]\n                    },\n                    {\n                        test: /\\.less$/,\n                        use: [\n                            ...commonCssLoader,\n                            \"less-loader\"\n                        ]\n                    },\n                    // js兼容性处理\n                    {\n                        test: /\\.js$/,\n                        exclude: /node_modules/,\n                        loader: \"babel-loader\",\n                        options: {\n                            presets: [\n                                [\n                                    \"@babel/preset-env\",\n                                    {\n                                        useBuiltIns: \"usage\",\n                                        corejs: { version: 3 },\n                                        targets: {\n                                            chrome: \"60\",\n                                            firefox: \"50\",\n                                            ie: \"9\",\n                                            safari: \"10\",\n                                            edge: \"17\"\n                                        }\n                                    }\n                                ],\n                            ],\n                            // 开启babel缓存\n                            cacheDirectory:true\n                        }\n                    },\n                    // 处理图片\n                    {\n                        test: /\\.(jpg|png|gif)$/,\n                        loader: \"url-loader\",\n                        options: {\n                            limit: 8 * 1024,//8kb以下进行base64处理\n                            name: \"[hash:10].[ext]\",\n                            outputPath: \"/imgs\",\n                            esModule: false\n                        }\n                    },\n                    // 处理html中的图片\n                    {\n                        test: /\\.html$/,\n                        loader: \"html-loader\",\n                    },\n                    // 处理其他文件\n                    {\n                        exclude: /\\.(js|css|less|html|jpg|png|gif)$/,\n                        loader: \"file-loader\",\n                        options: {\n                            outputPath: \"/media\"\n                        }\n                    }\n\n                ]\n            }\n        ]\n    },\n    plugins: [\n        new miniCssExtractPlugin({\n            filename: \"css/built.[contenthash:10].css\"\n        }),\n        //压缩css\n        new optimizeCssAssetsWebpackPlugin(),\n        new HtmlWebpackPlugin({\n            template: \"./src/index.html\",\n            // 压缩html\n            minify: {\n                collapseWhitespace: true,\n                removeComments: true\n            }\n        })\n    ],\n    mode: \"production\",\n    // devServer\n    devServer: {\n        disableHostCheck: true,\n        contentBase: resolve(__dirname, \"build\"),\n        compress: true,\n        port: 8080,\n        open: true,\n        // 开启HMR功能，并重启服务\n        hot: true\n    },\n    // source-map:一种提供源代码到构建后代码映射技术（如果构建后代码出错了，通过映射关系可以追踪到源代码错误）\n    devtool: \"inline-source-map\"\n};\n```\n\n## 4.6 code split\n\n1. 单入口、多入口输出。单入口输出一个bundle；多入口输出多个bundle\n2. 通过optimization\n3. 通过js动态导入语法\n\nindex.js\n\n```js\nimport $ from \"jquery\";\nfunction sum(...args) {\n  return args.reduce((p, c) => p + c, 0);\n}\n// eslint-disable-next-line\nconsole.log(sum(1, 2, 3, 4, 5));\n// eslint-disable-next-line\nconsole.log($);\n\n/**\n * 通过js代码，让某个文件被单独打包成一个chunk\n * import动态导入语法：能将某个文件单独打包\n * \n * webpackChunkName:'xxx'设置打包之后的名字，如果不设置，默认是以chunk的id值来命名\n */\nimport(/* webpackChunkName:'js动态导入' */\"./test\")\n  .then(({ mul, count }) => {\n    //文件加载成功\n    // eslint-disable-next-line\n    console.log(mul(2, 3));\n  })\n  .catch(() => {\n    // eslint-disable-next-line\n    console.log(\"文件加载失败\");\n  });\n```\n\ntest.js\n\n```js\nexport function mul(x, y) {\n  return x * y;\n}\nexport function count(x, y) {\n  return x - y;\n}\n```\n\nwebpack.config.js\n\n```js\nconst { resolve } = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\n\n//设置nodejs的环境变量，此处是用来设置package.json中browserlist以什么模式来兼容\nprocess.env.NODE_ENV = \"production\";\n\n\n\nmodule.exports = {\n    // 单入口\n    // entry: \"./src/js/index.js\",\n    // 多入口js:有一个入口，最终输出就有一个bundle；有多个，输出就会有多个\n    entry: { \n        index: \"./src/js/index.js\", \n        test: \"./src/js/test.js\" \n    },\n    output: {\n        // [name]：取文件名\n        filename: 'js/[name].[contenthash:10].js',\n        path: resolve(__dirname, \"build\")\n    },\n    module: {\n        rules: [\n            // loader的配置\n            // 处理less资源\n            {\n                test: /\\.less$/,\n                use: [\n                    'style-loader',\n                    'css-loader',\n                    'less-loader'\n                ]\n            },\n            // 处理css资源\n            {\n                test: /\\.css$/,\n                use: [\n                    'style-loader',\n                    'css-loader'\n                ]\n            },\n            // 处理图片资源\n            {\n                test: /\\.(jpg||png||gif)$/,\n                loader: \"url-loader\",\n                options: {\n                    limit: 8 * 1024,\n                    name: \"[hash:10].[ext]\",\n                    // 设置使用commonjs，不使用es\n                    esModule: false,\n                    //将图片输出到imgs文件夹\n                    outputPath: \"imgs\"\n                }\n            },\n            // 处理html中的img资源\n            {\n                test: /\\.html$/,\n                loader: \"html-loader\",\n            },\n            // 处理其他资源\n            {\n                exclude: /\\.(html|css|js|less|jpg|png|gif)$/,\n                loader: \"file-loader\",\n                options: {\n                    name: \"[hash:10].[ext]\",\n                    // 将其他资源输出到media文件夹\n                    outputPath: \"media\"\n                }\n            }\n        ]\n    },\n    plugins: [\n        new HtmlWebpackPlugin({\n            template: \"./src/index.html\",\n            // 压缩html\n            minify: {\n                collapseWhitespace: true,\n                removeComments: true\n            }\n        })\n    ],\n    /**\n     * 单入口时，可以设置下面代码，将node_modules中代码单独打包成一个chunk最终输出\n     * 多入口时，自动分析多入口chunk中，有没有公共的文件（如果文件太小，还是会打包成一个整的）。如果有，会打包成一个单独的chunk\n     */\n    optimization:{\n        splitChunks:{\n            chunks:\"all\"\n        }\n    },\n    mode: \"production\",\n    // devServer\n    devServer: {\n        disableHostCheck: true,\n        contentBase: resolve(__dirname, \"build\"),\n        compress: true,\n        port: 8080,\n        open: true,\n        // 开启HMR功能，并重启服务\n        hot: true\n    }\n};\n```\n\n## 4.7 js文件懒加载与预加载\n\n关于html的dom加载顺序，可以参照本文最上面的defer与async\n\nwebpack.config.js\n\n```js\nconst { resolve } = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\n\n//设置nodejs的环境变量，此处是用来设置package.json中browserlist以什么模式来兼容\nprocess.env.NODE_ENV = \"production\";\n\nmodule.exports = {\n    entry: \"./src/js/index.js\",\n    output: {\n        // [name]：取文件名\n        filename: 'js/[name].[contenthash:10].js',\n        path: resolve(__dirname, \"build\")\n    },\n    module: {\n        rules: [\n            // loader的配置\n            // 处理less资源\n            {\n                test: /\\.less$/,\n                use: [\n                    'style-loader',\n                    'css-loader',\n                    'less-loader'\n                ]\n            },\n            // 处理css资源\n            {\n                test: /\\.css$/,\n                use: [\n                    'style-loader',\n                    'css-loader'\n                ]\n            },\n            // 处理图片资源\n            {\n                test: /\\.(jpg||png||gif)$/,\n                loader: \"url-loader\",\n                options: {\n                    limit: 8 * 1024,\n                    name: \"[hash:10].[ext]\",\n                    // 设置使用commonjs，不使用es\n                    esModule: false,\n                    //将图片输出到imgs文件夹\n                    outputPath: \"imgs\"\n                }\n            },\n            // 处理html中的img资源\n            {\n                test: /\\.html$/,\n                loader: \"html-loader\",\n            },\n            // 处理其他资源\n            {\n                exclude: /\\.(html|css|js|less|jpg|png|gif)$/,\n                loader: \"file-loader\",\n                options: {\n                    name: \"[hash:10].[ext]\",\n                    // 将其他资源输出到media文件夹\n                    outputPath: \"media\"\n                }\n            }\n        ]\n    },\n    plugins: [\n        new HtmlWebpackPlugin({\n            template: \"./src/index.html\",\n            // 压缩html\n            minify: {\n                collapseWhitespace: true,\n                removeComments: true\n            }\n        })\n    ],\n    /**\n     * 单入口时，可以设置下面代码，将node_modules中代码单独打包成一个chunk最终输出\n     * 多入口时，自动分析多入口chunk中，有没有公共的文件（如果文件太小，还是会打包成一个整的）。如果有，会打包成一个单独的chunk\n     */\n    optimization:{\n        splitChunks:{\n            chunks:\"all\"\n        }\n    },\n    mode: \"production\",\n    // devServer\n    devServer: {\n        disableHostCheck: true,\n        contentBase: resolve(__dirname, \"build\"),\n        compress: true,\n        port: 8080,\n        open: true,\n        // 开启HMR功能，并重启服务\n        hot: true\n    }\n};\n```\n\nindex.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>开发环境配置</title>\n</head>\n<body>\n    <h1 id=\"title\">测试</h1>\n    <button id=\"btn\">按钮</button>\n    <div id=\"box1\"></div>\n    <div id=\"box2\"></div>\n    <img src=\"./media/img3.jpg\" alt=\"\">\n    <a href=\"https://meethigher.obs.cn-north-4.myhuaweicloud.com:443/OBSBrowserPlus-HEC-win64.zip?AccessKeyId=MJXE1SVRAHUR4INU2JVX&Expires=1594782807&Signature=mAW9elrLaTdqoxFk%2BDJDOs42gMg%3D\" download=\"下载.zip\">点击下载</a>\n</body>\n</html>\n```\n\nindex.js\n\n```js\nconsole.log(\"indexjs文件被加载了\");\n// import {mul} from \"./test\";\ndocument.getElementById(\"btn\").onclick = function () {\n    // 懒加载：当文件需要使用时，才加载文件。这个方法不会进行重复加载，第一次加载之后，就会将数据保存到缓存\n    // 预加载：会在使用之前，提前加载js文件\n    /**\n     * 正常加载可以认为是并行加载，同一时间加载多个js文件，文件即使不用，也会加载\n     * 预加载是等其他资源加载完毕，浏览器空闲了，再进行加载。兼容性非常差，目前只适用于pc端主流浏览器\n     */\n    import(/*webpackChunkName:\"test\",webpackPrefetch:true*/\"./test\").then(({ mul }) => {\n        console.log(mul(2, 3));\n    }).catch(() => {\n        console.log(\"失败\");\n    });\n}\n```\n\ntest.js\n\n```js\nconsole.log(\"testjs被加载\")\nexport function mul(x,y){\n    return x*y;\n}\n```\n\n## 4.8 PWA\n\n参考资料：\n\n1. [Hexo博客部署PWA](https://linwhitehat.github.io/Blog/2020/02/09/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2PWA.html)\n2. [Service Workers 实现网站加速和离线缓存](https://diygod.me/2954/)\n\n安装\n\n```powershell\nnpm install workbox-webpack-plugin -D\n```\n\nwebpack.config.js\n\n```js\n/**\n * PWA：渐进式网络开发应用程序（离线可访问）\n *  workbox(google开源)-->workbox-webpack-plugin\n */\nconst { resolve } = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\nconst workboxWebpackPlugin=require(\"workbox-webpack-plugin\");\nconst miniCssExtractPlugin=require(\"mini-css-extract-plugin\");\nconst optimizeCssAssetsWebpackPlugin=require(\"optimize-css-assets-webpack-plugin\");\n\n//设置nodejs的环境变量，此处是用来设置package.json中browserlist以什么模式来兼容\nprocess.env.NODE_ENV = \"production\";\n// 复用loader\nconst commonCssLoader = [\n    miniCssExtractPlugin.loader,\n    \"css-loader\",\n    // 兼容性处理\n    {\n        // 在package.json中需要配置browserslist\n        loader: \"postcss-loader\",\n        options: {\n            ident: \"postcss\",\n            plugins: () => [\n                require(\"postcss-preset-env\")()\n            ]\n        }\n    }\n];\nmodule.exports = {\n    entry: \"./src/js/index.js\",\n    output: {\n        // [name]：取文件名\n        filename: 'js/[name].[contenthash:10].js',\n        path: resolve(__dirname, \"build\")\n    },\n    module: {\n        rules: [\n            //提取css文件\n            // 兼容性处理\n            {\n                test: /\\.css$/,\n                use: [\n                    ...commonCssLoader\n                ]\n            },\n            {\n                test: /\\.less$/,\n                use: [\n                    ...commonCssLoader,\n                    \"less-loader\"\n                ]\n            },\n            // js兼容性处理\n            {\n                test:/\\.js$/,\n                exclude:/node_modules/,\n                loader:\"babel-loader\",\n                options:{\n                    presets:[\n                        [\n                            \"@babel/preset-env\",\n                            {\n                                useBuiltIns:\"usage\",\n                                corejs:{version:3},\n                                targets:{\n                                    chrome:\"60\",\n                                    firefox:\"50\",\n                                    ie:\"9\",\n                                    safari:\"10\",\n                                    edge:\"17\"\n                                }\n                            }\n                        ],\n                    ]\n                }\n            },\n            // 处理图片\n            {\n                test:/\\.(jpg|png|gif)$/,\n                loader:\"url-loader\",\n                options:{\n                    limit:8*1024,//8kb以下进行base64处理\n                    name:\"[hash:10].[ext]\",\n                    outputPath:\"/imgs\",\n                    esModule:false\n                }\n            },\n            // 处理html中的图片\n            {\n                test:/\\.html$/,\n                loader:\"html-loader\", \n            },\n            // 处理其他文件\n            {\n                exclude:/\\.(js|css|less|html|jpg|png|gif)$/,\n                loader:\"file-loader\",\n                options:{\n                    outputPath:\"/media\"\n                }\n            }\n\n        ]\n    },\n    plugins: [\n        new miniCssExtractPlugin({\n            filename: \"css/built.css\"\n        }),\n        //压缩css\n        new optimizeCssAssetsWebpackPlugin(),\n        new HtmlWebpackPlugin({\n            template: \"./src/index.html\",\n            // 压缩html\n            minify: {\n                collapseWhitespace: true,\n                removeComments: true\n            }\n        }),\n        // 使用\n        /**\n         * 1. 帮助ServiceWorker快点启动\n         * 2. 删除旧的ServiceWorker\n         * \n         * 最终生成ServiceWorker的配置文件\n         */\n        new workboxWebpackPlugin.GenerateSW({\n            clientsClaim:true,\n            skipWaiting:true\n        })\n    ],\n    /**\n     * 单入口时，可以设置下面代码，将node_modules中代码单独打包成一个chunk最终输出\n     * 多入口时，自动分析多入口chunk中，有没有公共的文件（如果文件太小，还是会打包成一个整的）。如果有，会打包成一个单独的chunk\n     */\n    optimization:{\n        splitChunks:{\n            chunks:\"all\"\n        }\n    },\n    mode: \"production\",\n    // devServer\n    devServer: {\n        disableHostCheck: true,\n        contentBase: resolve(__dirname, \"build\"),\n        compress: true,\n        port: 8080,\n        open: true,\n        // 开启HMR功能，并重启服务\n        hot: true\n    }\n};\n```\n\nindex.js\n\n```js\nimport \"../css/index.less\";\nconsole.log(\"indexjs文件被加载了\");\n// import {mul} from \"./test\";\ndocument.getElementById(\"btn\").onclick = function () {\n    // 懒加载：当文件需要使用时，才加载文件。这个方法不会进行重复加载，第一次加载之后，就会将数据保存到缓存\n    // 预加载：会在使用之前，提前加载js文件\n    /**\n     * 正常加载可以认为是并行加载，同一时间加载多个js文件，文件即使不用，也会加载\n     * 预加载是等其他资源加载完毕，浏览器空闲了，再进行加载。兼容性非常差，目前只适用于pc端主流浏览器\n     */\n    import(/*webpackChunkName:\"test\",webpackPrefetch:true*/\"./test\").then(({ mul }) => {\n        // eslint-disable-next-line\n        console.log(mul(2, 3));\n    }).catch(() => {\n        // eslint-disable-next-line\n        console.log(\"失败\");\n    });\n}\n// 注册ServiceWorker\n// 处理兼容性问题\n/**\n * 1. exlint不认识window、navigator全局变量\n *   解决：需要package.json中eslintConfig配置\n * \"env\":{\n *      \"browser\":true\n *  }\n * 2. sw必须运行在服务器上\n *  解决：1.nodejs\n *        2.npm i server -g\n *         通过命令server -s build，启动服务器,将build目录下所有资源作为静态资源暴露出去\n */\nif(\"serviceWorker\" in navigator){\n    window.addEventListener(\"load\",()=>{\n        navigator.serviceWorker.register(\"/service-worker.js\").then(()=>{\n            // eslint-disable-next-line\n            alert(\"sw注册成功\");\n        }).catch(()=>{\n            // eslint-disable-next-line\n            alert(\"sw注册失败\");\n        });\n    })\n}\n```\n\n> 问题：\n>\n> 在eslint语法检测时，出现import和export必须放在顶部的错误，该错误暂未解决。\n\n## 4.9 多进程打包\n\n安装\n\n```powershell\nnpm install thread-loader -D\n```\n\n将某个loader放到thread-loader的后面，就会对该loader进行多进程打包\n\n下面，以多进程打包js兼容性处理为例\n\nwebpack.config.js\n\n```js\nconst { resolve } = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\nconst workboxWebpackPlugin = require(\"workbox-webpack-plugin\");\nconst miniCssExtractPlugin = require(\"mini-css-extract-plugin\");\nconst optimizeCssAssetsWebpackPlugin = require(\"optimize-css-assets-webpack-plugin\");\n\n//设置nodejs的环境变量，此处是用来设置package.json中browserlist以什么模式来兼容\nprocess.env.NODE_ENV = \"production\";\n// 复用loader\nconst commonCssLoader = [\n    miniCssExtractPlugin.loader,\n    \"css-loader\",\n    // 兼容性处理\n    {\n        // 在package.json中需要配置browserslist\n        loader: \"postcss-loader\",\n        options: {\n            ident: \"postcss\",\n            plugins: () => [\n                require(\"postcss-preset-env\")()\n            ]\n        }\n    }\n];\nmodule.exports = {\n    entry: \"./src/js/index.js\",\n    output: {\n        // [name]：取文件名\n        filename: 'js/[name].[contenthash:10].js',\n        path: resolve(__dirname, \"build\")\n    },\n    module: {\n        rules: [\n            //提取css文件\n            // 兼容性处理\n            {\n                test: /\\.css$/,\n                use: [\n                    ...commonCssLoader\n                ]\n            },\n            {\n                test: /\\.less$/,\n                use: [\n                    ...commonCssLoader,\n                    \"less-loader\"\n                ]\n            },\n            // js兼容性处理\n            {\n                test: /\\.js$/,\n                exclude: /node_modules/,\n                use: [\n                    /**\n                     * 开启多线程打包\n                     * 进程启动大概为600ms，进程通信也有开销\n                     * 只有工作消耗时间比较长的时候，才需要多进程打包\n                     */\n                    // \"thread-loadaer\",\n                    //也可以进行详细配置\n                    {\n                        loader:\"thread-loader\",\n                        options:{\n                            workers:2 //进程2个\n                        }\n                    },\n                    {\n                        loader: \"babel-loader\",\n                        options: {\n                            presets: [\n                                [\n                                    \"@babel/preset-env\",\n                                    {\n                                        useBuiltIns: \"usage\",\n                                        corejs: { version: 3 },\n                                        targets: {\n                                            chrome: \"60\",\n                                            firefox: \"50\",\n                                            ie: \"9\",\n                                            safari: \"10\",\n                                            edge: \"17\"\n                                        }\n                                    }\n                                ],\n                            ]\n                        }\n                    }\n                ]\n            },\n            // 处理图片\n            {\n                test: /\\.(jpg|png|gif)$/,\n                loader: \"url-loader\",\n                options: {\n                    limit: 8 * 1024,//8kb以下进行base64处理\n                    name: \"[hash:10].[ext]\",\n                    outputPath: \"/imgs\",\n                    esModule: false\n                }\n            },\n            // 处理html中的图片\n            {\n                test: /\\.html$/,\n                loader: \"html-loader\",\n            },\n            // 处理其他文件\n            {\n                exclude: /\\.(js|css|less|html|jpg|png|gif)$/,\n                loader: \"file-loader\",\n                options: {\n                    outputPath: \"/media\"\n                }\n            }\n\n        ]\n    },\n    plugins: [\n        new miniCssExtractPlugin({\n            filename: \"css/built.css\"\n        }),\n        //压缩css\n        new optimizeCssAssetsWebpackPlugin(),\n        new HtmlWebpackPlugin({\n            template: \"./src/index.html\",\n            // 压缩html\n            minify: {\n                collapseWhitespace: true,\n                removeComments: true\n            }\n        }),\n        // 使用\n        /**\n         * 1. 帮助ServiceWorker快点启动\n         * 2. 删除旧的ServiceWorker\n         * \n         * 最终生成ServiceWorker的配置文件\n         */\n        new workboxWebpackPlugin.GenerateSW({\n            clientsClaim: true,\n            skipWaiting: true\n        })\n    ],\n    /**\n     * 单入口时，可以设置下面代码，将node_modules中代码单独打包成一个chunk最终输出\n     * 多入口时，自动分析多入口chunk中，有没有公共的文件（如果文件太小，还是会打包成一个整的）。如果有，会打包成一个单独的chunk\n     */\n    optimization: {\n        splitChunks: {\n            chunks: \"all\"\n        }\n    },\n    mode: \"production\",\n    // devServer\n    devServer: {\n        disableHostCheck: true,\n        contentBase: resolve(__dirname, \"build\"),\n        compress: true,\n        port: 8080,\n        open: true,\n        // 开启HMR功能，并重启服务\n        hot: true\n    }\n};\n```\n\n## 4.10 externals\n\n可以用来拒绝某些库的打包进入（某些情况下，通过cdn来引入库会更快一点）\n\nwebpack.config.js\n\n```js\nconst {resolve}=require(\"path\");\nconst HtmlWebpackPlugin=require(\"html-webpack-plugin\");\nmodule.exports={\n    entry:\"./src/js/index.js\",\n    output:{\n        filename:\"js/build.js\",\n        path:resolve(__dirname,\"build\"),\n\n    },\n    module:{\n        rules:[\n\n        ],\n        \n    },\n    plugins:[\n        // plugins的配置\n        // html-webpack-plugin\n        // 功能：默认会创建一个Html文件，引入打包输出的所有资源（js/css）\n        // 需求：需要有结构的html文件\n        new HtmlWebpackPlugin({\n            // 复制\"./src/index.html\",并自动引入打包输出的所有资源（js/css）\n            template:\"./src/index.html\"\n        })\n    ],\n    mode:\"production\",\n    externals:{\n        // 忽略库名以及对应的npm下载的包名\n        // 拒绝jquery这个包被打包进来\n        jquery:\"jQuery\"\n    }\n}\n```\n\n## 4.11 dll\n\ndll：动态连接库\n\n对某些库进行打包，并自动添加到html中。可以理解成跟externals相反。\n\n安装\n\n```powershell\nnpm install add-asset-html-webpack-plugin -D\n```\n\nwebpack.dll.js\n\n```js\n/**\n * 使用dll技术，对某些库（第三方库，如jquery、react、vue...）进行单独打包\n * 当使用webpack命令时，默认查找webpack.config.js文件 \n * 而我们需要运行webpack.dll.js，所以指令要改成 webpack --config webpack.dll.js\n */\nconst {resolve}=require(\"path\");\nconst webpack=require(\"webpack\");\nmodule.exports={\n    entry:{\n        //最终打包生成的[name]是jquery\n        //[\"jquery\"]->要打包的库是jquery \n        jquery:[\"jquery\"]\n    },\n    output:{\n        filename:\"[name].js\",\n        path:resolve(__dirname,\"dll\"),\n        library:\"[name]_[hash]\",//打包的库向外暴露出的库的名字\n    },\n    plugins:[\n        // 打包生成manifest.json->提供jquery的映射关系\n        new webpack.DllPlugin({\n            name:\"[name]_[hash]\",//映射库的暴露的内容名称\n            path:resolve(__dirname,\"dll/manifest.json\"),//输出文件路径\n        })\n    ],\n    mode:\"production\"\n}\n```\n\n运行命令\n\n```powershell\nwebpack --config webpack.dll.js\n```\n\n## 4.12 总结\n\n* 开发环境性能优化\n  * 优化打包构建速度\n    * HMR：针对css、js文件进行热替换。一个模块发生变化，只会重新打包这一个模块，而不是打包所有\n  * 优化代码调试\n    * source-map：一种提供源代码到构建后代码映射技术（如果构建后代码出错了，通过映射关系可以追踪到源代码错误）\n* 生产环境性能优化\n  * 优化打包构建速度\n    * oneOf：其中loader只会匹配一个，用来优化打包速度。就好比搜索内容时，搜索到第一个内容，后面的就不会再考虑了。所以在oneOf中，重复的内容需要单独提取出去。\n    * babel缓存\n    * 多进程打包\n  * 优化代码运行性能\n    * 文件缓存：hash->chunkhash->contenthash\n    * treeshaking：去除无用代码\n    * code split：代码分割\n    * 懒加载/预加载\n    * pwa：离线可访问技术\n    * externals\n    * dll\n\n# 五、webpack配置详解\n\n## 5.1 entry\n\nwebpack.config.js\n\n```js\nconst { resolve } = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\n/**\n * entry:入口起点\n * 1. string->\"./src/index.js\" 单入口，打包生成一个chunk。输出一个build文件，此时chunk名称默认为main\n * 2. array->[\"./src/index.js\",\"./src/add.js\"] 多入口，所有文件最终只会生成一个chunk，输出出去只有一个bundle文件\n *    作用：只有在HMR中，让html热更新生效\n * 3. object 多入口，有几个入口文件，就形成几个chunk，并输出几个bundle文件，此时chunk的名称是key\n *    特殊用法->看配置\n * \n * 第1种和第3种使用较多\n * \n * \n * \n */\nmodule.exports={\n    // entry:[\"./src/index.js\",\"./src/add.js\"],\n    entry:{\n        // 特殊用法\n        index:[\"./src/index.js\",\"./src/sub.js\"],\n        add:\"./src/add.js\"\n    },\n    output:{\n        filename:\"[name].js\",\n        path:resolve(__dirname,\"build\")\n    },\n    plugins:[\n        new HtmlWebpackPlugin()\n    ],\n    mode:\"development\"\n};\n```\n\n## 5.2 output\n\nwebpack.config.js\n\n```js\nconst { resolve } = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\n\nmodule.exports={\n    entry:\"./src/index.js\",\n    output:{\n        //文件名称（指定名称+目录）\n        filename:\"[name].js\",\n        // 输出文件目录（将来所有资源输出的公共目录）\n        path:resolve(__dirname,\"build\"),\n        // 所有资源引入公共路径前缀，如引入路径是\"imgs/a.jpg\"就会变成\"/imgs/a.jpg\"\n        publicPath:\"/\",\n        // entry中的就是入口chunk，像import这种就是非入口chunk\n        chunkFilename:\"[name]_chunk.js\",//非入口chunk的名称,\n        // 除非使用dll，正常打包一般不用library\n        // library:\"[name]\",//将库以变量名暴露出去\n        // libraryTarget:\"window\",//将变量名添加到browser上\n        // libraryTarget:\"global\",//将变量名添加到node上\n    },\n    plugins:[\n        new HtmlWebpackPlugin()\n    ],\n    mode:\"development\"\n};\n```\n\n## 5.3 module\n\nwebpack.config.js\n\n```js\nconst { resolve } = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\n\nmodule.exports={\n    entry:\"./src/index.js\",\n    output:{\n        filename:\"[name].js\",\n        path:resolve(__dirname,\"build\"),\n    },\n    module:{\n        rules:[\n            // loader配置\n            {\n                test:/\\.css$/,\n                // 多个loader用use\n                use:[\"style-loader\",\"css-loader\"],\n\n            },\n            {\n                test:/\\.js$/,\n                // 排除\n                exclude:/node_modules/,\n                // 包含\n                include:resolve(__dirname,\"src\"),\n                // pre优先执行,post延后执行，不写中间执行\n                enforce:\"pre\",\n                // 单个loader用loader\n                loader:\"eslint-loader\",\n                // 配置，具体看文档\n                options:{}\n            },\n            {\n                // 以下配置只会生效一个\n                oneOf:[]\n            }\n        ]\n    },\n    plugins:[\n        new HtmlWebpackPlugin()\n    ],\n    mode:\"development\"\n};\n```\n\n## 5.4 resolve\n\nwebpack.config.js\n\n```js\nconst { resolve } = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\n\nmodule.exports={\n    entry:\"./src/js/index.js\",\n    output:{\n        filename:\"[name].js\",\n        path:resolve(__dirname,\"build\"),\n    },\n    module:{\n        rules:[\n            {\n                test:/\\.css$/,\n                use:[\"style-loader\",\"css-loader\"],\n\n            },\n        ]\n    },\n    plugins:[\n        new HtmlWebpackPlugin()\n    ],\n    mode:\"development\",\n    // webpack本身是个对象，所以写法顺序无所谓的\n    resolve:{\n        // 配置解析模块路径别名，优点：写路径时，简写路径。缺点：写代码时没有提示\n        alias:{\n            // 配置css的绝对路径\n            $css:resolve(__dirname,\"src/css\"),\n        },\n        // 配置省略文件路径的后缀名\n        extensions:[\".json\",\".css\"],\n        // 告诉webpack解析模块时去找哪个目录，绝对路径，再写一个node_modules是为了防止找不到\n        modules:[resolve(__dirname,\"../../node_modules\"),\"node_modules\"]\n    }\n};\n```\n\n## 5.5 devServer\n\nwebpack.config.js\n\n```js\nconst { resolve } = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\n\nmodule.exports = {\n    entry: \"./src/js/index.js\",\n    output: {\n        filename: \"[name].js\",\n        path: resolve(__dirname, \"build\"),\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.css$/,\n                use: [\"style-loader\", \"css-loader\"],\n\n            },\n        ]\n    },\n    plugins: [\n        new HtmlWebpackPlugin()\n    ],\n    mode: \"development\",\n    resolve: {\n        alias: {\n            $css: resolve(__dirname, \"src/css\"),\n        },\n        extensions: [\".json\", \".css\"],\n        modules: [resolve(__dirname, \"../../node_modules\"), \"node_modules\"]\n    },\n    devServer:{\n        // 运行代码的目录\n        contentBase:resolve(__dirname,\"build\"),\n        // 监视ContentBase目录 目录下的所有文件，一旦文件变化就会reload重载\n        watchContentBase:true,\n        // 配置\n        watchOptions:{\n            // 忽略文件\n            ignored:/node_modules/\n        },\n        // 启动gzip压缩\n        compress:true,\n        // 端口号\n        port:8080,\n        // 域名\n        host:\"localhost\",\n        // 自动打开\n        open:true,\n        // 开启hmr功能\n        hot:true,\n        // 日志，不要显示启动服务器时的日志\n        clientLogLevel:\"none\",\n        // 除了基本启动信息以外，其他内容都不打印\n        quiet:true,\n        // 如果出现错误，不要全屏提示\n        overlay:false,\n        // 服务器代理，解决开发环境跨域问题\n        proxy:{\n            // 一旦服务器8080接收到/api请求，就会自动把请求转发到另一个服务器8000\n            \"/api\":{\n                target:\"http://localhost:8000\",\n                // 发送请求时，请求路径重写：将/api/xxx-->/xxx(去掉/api)\n                pathRewrite:{\n                    \"^/api\":\"\"\n                }\n            }\n        }\n    }\n};\n```\n\n## 5.7 optimization\n\nwebpack.config.js\n\n```js\nconst { resolve } = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\nconst terserWebpackPlugin=require(\"terser-webpack-plugin\");\n\nmodule.exports = {\n    entry: \"./src/js/index.js\",\n    output: {\n        filename: \"js/[name].[contenthash].js\",\n        path: resolve(__dirname, \"build\"),\n        chunkFilename:\"js/[name].[contenthash].chunk.js\"\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.css$/,\n                use: [\"style-loader\", \"css-loader\"],\n\n            },\n        ]\n    },\n    plugins: [\n        new HtmlWebpackPlugin()\n    ],\n    mode: \"development\",\n    resolve: {\n        alias: {\n            $css: resolve(__dirname, \"src/css\"),\n        },\n        extensions: [\".json\", \".css\"],\n        modules: [resolve(__dirname, \"../../node_modules\"), \"node_modules\"]\n    },\n    optimization:{\n        splitChunks:{\n            chunks:\"all\",\n            // 以下这些都是默认值，一般也不会修改。所以也可以不写\n            // 分割的chunk最小是30kb\n            minSize:30*1024,\n            // 0表示最大没有限制\n            maxSize:0,\n            // 要提取的chunk最少被引用一次，如果未被引用，不会提取\n            minChunks:1,\n            // 按需加载时，并行加载的文件最大数量为5\n            maxAsyncRequests:5,\n            // 入口js文件最大并行请求数量为3个\n            maxInitialRequests:3,\n            // 名称连接符是~\n            automaticNameDelimiter:\"~\",\n            // 可以使用命名规则\n            name:true,\n            // 分割chunk的组\n            cacheGroups:{\n                // node_modules中的文件会被打包到vendors这个chunk中。命名-->vendors~xxx.js\n                // 同时，也要满足上面的公共规则\n                vendors:{\n                    test:/[\\\\/]node_modules[\\\\/]/,\n                    // 优先级\n                    priority:-10\n                },\n                default:{\n                    // 要提取的chunk最少被提取两次\n                    minChunks:2,\n                    // 优先级\n                    priority:-20,\n                    // 代码能复用。如果当前要打包的模块和之前已经被提取的模块是同一个，就会复用，而不是重新打包模块\n                    reuseExistingChunk:true\n                }\n            }\n        },\n        /**\n         * index.js中引用a.js，若a.js发生变化，hash就会变，那么引用a.js的index.js也会变化\n         * 下面的代码作用是：将当前模块记录其他模块的hash单独打包成一个文件，叫runtime，这样index.js就不用改了\n         * index.js直接引用runtime中的带有hash的内容即可\n         */\n        runtimeChunk:{\n            name:entrypoint=>`runtime-${entrypoint.name}`\n        },\n        // 配置生产环境的压缩方案:js和css\n        // 将来压缩js就使用这个\n        minimizer:[\n            new terserWebpackPlugin({\n                // 开启缓存\n                cache:true,\n                // 开启多进程打包\n                parallel:true,\n                // 启动source-map\n                sourceMap:true,\n            })\n        ]\n        \n    }\n};\n```\n\n# 六、webpack5\n\n虽然目前还没发布，先了解\n\n```powershell\nnpm init -y # 初始化node_modules，并且使用默认配置，-y代表yes\n```\n\n安装webpack5测试版\n\n```powershell\nnpm install webpack@next webpack-cli -D\n```\n\n此版本重点关注以下内容:\n\n- 通过持久缓存提高构建性能.\n- 使用更好的算法和默认值来改善长期缓存.\n- 通过更好的树摇和代码生成来改善捆绑包大小.\n- 清除处于怪异状态的内部结构，同时在 v4 中实现功能而不引入任何重大更改.\n- 通过引入重大更改来为将来的功能做准备，以使我们能够尽可能长时间地使用 v5.\n\n## 6.1 下载\n\n- npm i webpack@next webpack-cli -D\n\n## 6.2 自动删除 Node.js Polyfills\n\n早期，webpack 的目标是允许在浏览器中运行大多数 node.js 模块，但是模块格局发生了变化，许多模块用途现在主要是为前端目的而编写的。webpack <= 4 附带了许多 node.js 核心模块的 polyfill，一旦模块使用任何核心模块（即 crypto 模块），这些模块就会自动应用。\n\n尽管这使使用为 node.js 编写的模块变得容易，但它会将这些巨大的 polyfill 添加到包中。在许多情况下，这些 polyfill 是不必要的。\n\nwebpack 5 会自动停止填充这些核心模块，并专注于与前端兼容的模块。\n\n迁移：\n\n- 尽可能尝试使用与前端兼容的模块。\n- 可以为 node.js 核心模块手动添加一个 polyfill。错误消息将提示如何实现该目标。\n\n## 6.3 Chunk 和模块 ID\n\n添加了用于长期缓存的新算法。在生产模式下默认情况下启用这些功能。\n\n`chunkIds: \"deterministic\", moduleIds: \"deterministic\"`\n\n## 6.4 Chunk ID\n\n你可以不用使用 `import(/* webpackChunkName: \"name\" */ \"module\")` 在开发环境来为 chunk 命名，生产环境还是有必要的\n\nwebpack 内部有 chunk 命名规则，不再是以 id(0, 1, 2)命名了\n\n## 6.5 Tree Shaking\n\n1. webpack 现在能够处理对嵌套模块的 tree shaking\n\n```js\n// inner.js\nexport const a = 1;\nexport const b = 2;\n\n// module.js\nimport * as inner from './inner';\nexport { inner };\n\n// user.js\nimport * as module from './module';\nconsole.log(module.inner.a);\n```\n\n在生产环境中, inner 模块暴露的 `b` 会被删除\n\n2. webpack 现在能够多个模块之前的关系\n\n```js\nimport { something } from './something';\n\nfunction usingSomething() {\n  return something;\n}\n\nexport function test() {\n  return usingSomething();\n}\n```\n\n当设置了`\"sideEffects\": false`时，一旦发现`test`方法没有使用，不但删除`test`，还会删除`\"./something\"`\n\n3. webpack 现在能处理对 Commonjs 的 tree shaking\n\n## 6.6 Output\n\nwebpack 4 默认只能输出 ES5 代码\n\nwebpack 5 开始新增一个属性 output.ecmaVersion, 可以生成 ES5 和 ES6 / ES2015 代码.\n\n如：`output.ecmaVersion: 2015`\n\n## 6.7 SplitChunk\n\nwebpack4中\n\n```js\n// webpack4\nminSize: 30000;\n```\n\nwebpack5中\n\n```js\n// webpack5\nminSize: {\n  javascript: 30000,\n  style: 50000,\n}\n```\n\n## 6.8 Caching\n\n```js\n// 配置缓存\ncache: {\n  // 磁盘存储\n  type: \"filesystem\",\n  buildDependencies: {\n    // 当配置修改时，缓存失效\n    config: [__filename]\n  }\n}\n```\n\n缓存将存储到 `node_modules/.cache/webpack`\n\n## 6.9 监视输出文件\n\n之前 webpack 总是在第一次构建时输出全部文件，但是监视重新构建时会只更新修改的文件。\n\n此次更新在第一次构建时会找到输出文件看是否有变化，从而决定要不要输出全部文件。\n\n## 6.10 默认值\n\n- `entry: \"./src/index.js`\n- `output.path: path.resolve(__dirname, \"dist\")`\n- `output.filename: \"[name].js\"`\n\n## 6.11 更多内容\n\nhttps://github.com/webpack/changelog-v5\n\n# 七、总结\n\n## 7.1 参考\n\n* [尚硅谷webpack从入门到精通](https://www.bilibili.com/video/BV1e7411j7T5)\n* [webpack从入门到茎痛.pdf](http://cdn.meethigher.top/media/webpack%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%8C%8E%E7%97%9B.pdf)\n* [源码](https://github.com/meethigher/webpack-notes)\n\n> npm打包那些事\n>\n> 我想上传代码到github，但是其中node_modules数据太大了，所以需要在git中忽略掉。\n>\n> [git忽略某个目录或文件不上传](https://blog.csdn.net/sunxiaoju/article/details/86495234)\n\n## 7.2 小结\n\n<video src=\"http://cdn.meethigher.top/media/webpack.mp4\" width=\"100%\" controls>\n\n","tags":["js","web"]}]