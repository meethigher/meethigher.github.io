<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><meta name="keywords" content="Stream流式思想,个人网站，个人博客，meethigher，学习，生活"><meta name="description" content="说到Stream便容易想到I/O Stream，而实际上，谁规定“流”就一定是“IO流”呢？在Java 8中，得益于Lambda所带来的函数式编程，引入了一个全新的Stream概念，用于解决已有集合类库既有的弊端。"><title>Stream流式思想</title><link rel="shortcut icon" href="/blog/images/favicon.ico"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/meethigher/cdn@9.0/css/meethigher-font.css"><link rel="stylesheet" href="/blog/css/index.css"></head><body><header class="header"><div class="header-menu"><span class="fa fa-bars"></span></div><div class="header-search"><span class="fa fa-search"></span></div><div class="header-title"><a href="/">言成言成啊<span class="header-subtitle"> | Kit Chen&#39;s Blog</span></a></div><ul class="header-navbar clearFix"><li><a href="/blog/">主页</a></li><li><a href="/blog/tags">标签</a></li><li><a href="/blog/archives">归档</a></li><li><a href="/blog/about">关于</a></li></ul></header><div id="particles-js"></div><script src="https://cdn.jsdelivr.net/gh/meethigher/cdn@9.0/js/particles.min.js"></script><script src="https://cdn.jsdelivr.net/gh/meethigher/cdn@9.0/js/app.js"></script><div class="search" title="站内搜索"><span class="fa fa-search"></span></div><div class="tool"><div class="up" title="返回顶部"><span class="fa fa-long-arrow-up"></span></div><div class="down" title="返回底部"><span class="fa fa-long-arrow-down"></span></div><a href="/blog/app.apk" class="app" title="下载App" download="app.apk"><span class="fa fa-android"></span></a></div><main class="main"><div class="main-content"><article class="post"><div class="post-title"><h2 class="title">Stream流式思想</h2></div><div class="post-content blog-markdown"><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h2><h3 id="传统集合的多步遍历代码"><a href="#传统集合的多步遍历代码" class="headerlink" title="传统集合的多步遍历代码"></a>传统集合的多步遍历代码</h3><p>几乎所有的集合（如 Collection接口或 Map接口等）都支持直接或间接的遍历操作。而当我们需要对集合中的元素进行操作的时候，除了必需的添加、删除、获取外，最典型的就是集合遍历。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01ForEach</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ArrayList&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		list.add(<span class="string">"小舞"</span>);</span><br><span class="line">		list.add(<span class="string">"胡列娜"</span>);</span><br><span class="line">		list.add(<span class="string">"江厌离"</span>);</span><br><span class="line">		<span class="keyword">for</span>(String s:list) &#123;</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一段非常简单的集合遍历操作：对集合中的每一个字符串都进行打印输出操作。</p><h3 id="循环遍历的弊端"><a href="#循环遍历的弊端" class="headerlink" title="循环遍历的弊端"></a>循环遍历的弊端</h3><p>Java 8的Lambda让我们可以更加专注于做什么（What），而不是怎么做（How），这点此前已经结合内部类进行 了对比说明。现在，我们仔细体会一下上例代码，可以发现：</p><ul><li><p>for循环的语法就是“怎么做”</p></li><li><p>for循环的循环体才是“做什么”</p></li></ul><p>为什么使用循环？因为要进行遍历。但循环是遍历的唯一方式吗？遍历是指每一个元素逐一进行处理，而并不是从 第一个到最后一个顺次处理的循环。前者是目的，后者是方式。</p><p>试想一下，如果希望对集合中的元素进行筛选过滤：</p><ol><li><p>将集合A根据条件一过滤为子集B；</p></li><li><p>然后再根据条件二过滤为子集C。</p></li></ol><p>那怎么办？在Java 8之前的做法可能为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01ForEach</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ArrayList&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		list.add(<span class="string">"小舞"</span>);</span><br><span class="line">		list.add(<span class="string">"胡列娜"</span>);</span><br><span class="line">		list.add(<span class="string">"江厌离"</span>);</span><br><span class="line">		list.add(<span class="string">"江澄"</span>);</span><br><span class="line">		list.add(<span class="string">"江枫眠"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//对list中的元素进行过滤，将以江开头的元素，存储到一个新的集合中</span></span><br><span class="line">		ArrayList&lt;String&gt; listJiang=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		<span class="keyword">for</span>(String s:list) &#123;</span><br><span class="line">			<span class="keyword">if</span>(s.startsWith(<span class="string">"江"</span>))</span><br><span class="line">				listJiang.add(s);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//对listJiang中元素进行过滤，将长度为3的，存储到新的集合中</span></span><br><span class="line">		ArrayList&lt;String&gt; list3=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		<span class="keyword">for</span>(String s:listJiang) &#123;</span><br><span class="line">			<span class="keyword">if</span>(s.length()==<span class="number">3</span>)</span><br><span class="line">				list3.add(s);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//遍历list3</span></span><br><span class="line">		<span class="keyword">for</span>(String s:list3) &#123;</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中含有三个循环，每一个作用不同：</p><ol><li><p>首先筛选所有姓江的人；</p></li><li><p>然后筛选名字有三个字的人；</p></li><li><p>最后进行对结果进行打印输出。</p></li></ol><p>每当我们需要对集合中的元素进行操作的时候，总是需要进行循环、循环、再循环。这是理所当然的么？不是。循 环是做事情的方式，而不是目的。另一方面，使用线性循环就意味着只能遍历一次。如果希望再次遍历，只能再使 用另一个循环从头开始。</p><p>那，Lambda的衍生物Stream能给我们带来怎样更加优雅的写法呢？</p><h3 id="Stream的更优写法"><a href="#Stream的更优写法" class="headerlink" title="Stream的更优写法"></a>Stream的更优写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Stream</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		list.add(<span class="string">"小舞"</span>);</span><br><span class="line">		list.add(<span class="string">"胡列娜"</span>);</span><br><span class="line">		list.add(<span class="string">"江厌离"</span>);</span><br><span class="line">		list.add(<span class="string">"江澄"</span>);</span><br><span class="line">		list.add(<span class="string">"江枫眠"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 对list中的元素进行过滤，将以江开头的元素，存储到一个新的集合中</span></span><br><span class="line">		<span class="comment">// 对listJiang中元素进行过滤，将长度为3的，存储到新的集合中</span></span><br><span class="line">		<span class="comment">// 遍历list3</span></span><br><span class="line">		list.stream().filter(<span class="keyword">new</span> Predicate&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> s.startsWith(<span class="string">"江"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).filter(<span class="keyword">new</span> Predicate&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> s.length() == <span class="number">3</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).forEach(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String t)</span> </span>&#123;</span><br><span class="line">				System.out.println(t);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 升级为Lambda写法，优雅不？艺术不？</span></span><br><span class="line">		list.stream()</span><br><span class="line">		.filter(s -&gt; s.startsWith(<span class="string">"江"</span>))</span><br><span class="line">		.filter(s -&gt; s.length() == <span class="number">3</span>)</span><br><span class="line">		.forEach(s -&gt; System.out.println(s));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：获取流、过滤出姓江、过滤出长度为3、逐一打印。代码中并没有体现使用线性循环或是其他任何算法进行遍历，我们真正要做的事情内容被更好地体现在代码中。</p><h2 id="2-流式思想概述"><a href="#2-流式思想概述" class="headerlink" title="2 流式思想概述"></a>2 流式思想概述</h2><p><strong>注意：请暂时忘记对传统IO流的固有印象！</strong></p><p>整体来看，流式思想类似于工厂车间的“生产流水线”。</p><p>当需要对多个元素进行操作（特别是多步操作）的时候，考虑到性能及便利性，我们应该首先拼好一个“模型”步骤 方案，然后再按照方案去执行它。</p><p>这张图中展示了过滤、映射、跳过、计数等多步操作，这是一种集合元素的处理方案，而方案就是一种“函数模型”。图中的每一个方框都是一个“流”，调用指定的方法，可以从一个流模型转换为另一个流模型。而最右侧的数字3是最终结果。</p><p>这里的 filter 、 map 、 skip 都是在对函数模型进行操作，集合元素并没有真正被处理。</p><p>只有当终结方法 count 执行的时候，整个模型才会按照指定策略执行操作。而这得益于Lambda的延迟执行特性。</p><blockquote><p>备注：<strong>Stream流</strong>其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何 元素（或其地址值）。</p></blockquote><p>Stream（流）是一个来自数据源的元素队列，</p><ul><li><p>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</p></li><li><p><strong>数据源</strong> 流的来源。 可以是集合，数组等。</p></li></ul><p>和以前的Collection操作不同， Stream操作还有两个基础的特征：</p><ul><li><p><strong>Pipelining：</strong> 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</p></li><li><p><strong>内部迭代：</strong> 以前对集合遍历都是通过Iterator或者增强for的方式, 显式的在集合外部进行迭代， 这叫做外部迭 代。 Stream提供了内部迭代的方式，流可以直接调用遍历方法。</p></li></ul><p>当使用一个流的时候，<strong>通常包括三个基本步骤：获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象</strong>（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道。</p><h2 id="3-获取流"><a href="#3-获取流" class="headerlink" title="3 获取流"></a>3 获取流</h2><p><code>java.util.stream.Stream</code> 是<code>Java 8</code>新加入的最常用的流接口（这并不是一个函数式接口）</p><p>获取一个流非常简单，有以下几种常用的方式：</p><ul><li>所有的 <code>Collection</code> 集合都可以通过 <code>stream</code> 默认方法获取流；</li><li><code>Stream</code> 接口的静态方法 <code>of</code> 可以获取数组对应的流。</li></ul><h3 id="根据Collection获取流"><a href="#根据Collection获取流" class="headerlink" title="根据Collection获取流"></a>根据Collection获取流</h3><p>首先， <code>java.util.Collection</code> 接口中加入了<code>default</code>方法 <code>stream</code> 用来获取流，所以其所有实现类均可获取流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把集合List转换为Stream</span></span><br><span class="line">List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">Stream&lt;String&gt; stream1=list.stream();</span><br><span class="line">		</span><br><span class="line">Set&lt;String&gt; set=<span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">Stream&lt;String&gt; stream2=set.stream();</span><br></pre></td></tr></table></figure><h3 id="根据Map获取流"><a href="#根据Map获取流" class="headerlink" title="根据Map获取流"></a>根据Map获取流</h3><p><code>java.util.Map</code> 接口不是 <code>Collection</code> 的子接口，且其K-V数据结构不符合流元素的单一特征，所以获取对应的流 需要分key（键）、value（值）或entry（键与值的映射关系）等情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map=<span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"><span class="comment">//获取键，存储到Set集合中</span></span><br><span class="line">Set&lt;String&gt; keyset=map.keySet();</span><br><span class="line">Stream&lt;String&gt; stream3=keyset.stream();</span><br><span class="line">		</span><br><span class="line"><span class="comment">//或者获取值，存到Collection中，然后再通过Collection集合中的stream默认方法获取流</span></span><br><span class="line">Stream&lt;String&gt; stream4=map.values().stream();</span><br><span class="line">		</span><br><span class="line"><span class="comment">//或者获取键与值的映射关系 entrySet</span></span><br><span class="line">Set&lt;Map.Entry&lt;String, String&gt;&gt; entries=map.entrySet();</span><br><span class="line">Stream&lt;Map.Entry&lt;String, String&gt;&gt; stream5=entries.stream();</span><br></pre></td></tr></table></figure><h3 id="根据数组获取流"><a href="#根据数组获取流" class="headerlink" title="根据数组获取流"></a>根据数组获取流</h3><p>如果使用的不是集合或映射而是数组，由于数组对象不可能添加默认方法，所以 Stream 接口中提供了静态方法 of ，使用很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把数组转换为Stream</span></span><br><span class="line">Stream&lt;Integer&gt; stram6=Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//可变参数可以传递数组</span></span><br><span class="line">Integer[] arr= &#123;</span><br><span class="line">	<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span></span><br><span class="line">&#125;;</span><br><span class="line">Stream&lt;Integer&gt; stream7=Stream.of(arr);</span><br></pre></td></tr></table></figure><blockquote><p>备注： of 方法的参数其实是一个可变参数，所以支持数组</p></blockquote><h2 id="4-常用方法"><a href="#4-常用方法" class="headerlink" title="4 常用方法"></a>4 常用方法</h2><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" data-original="/blog/2020/streaming-thought/common-methods.png" title="常用方法"><p>流模型的操作很丰富，这里介绍一些常用的API。这些方法可以被分成两种：</p><ul><li>延迟方法：返回值类型仍然是 Stream 接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方 法均为延迟方法。）</li><li>终结方法：返回值类型不再是 Stream 接口自身类型的方法，因此不再支持类似 StringBuilder 那样的链式调用。本小节中，终结方法包括 count 和 forEach 方法。</li></ul><blockquote><p>流的特点：Stream流属于管道流，只能被消费（使用）一次。第一个Stream流调用完毕方法，数据就会流转到下一个Stream流， 而这时第一个Stream流已经使用完毕，就会关闭了。所以第一个Stream流就不能再调用方法了。</p></blockquote><h3 id="逐一处理：forEach"><a href="#逐一处理：forEach" class="headerlink" title="逐一处理：forEach"></a>逐一处理：forEach</h3><p>虽然方法名字叫 <code>forEach</code> ，但是与for循环中的“for-each”昵称不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br></pre></td></tr></table></figure><p>该方法接收一个 <code>Consumer</code> 接口函数，会将每一个流元素交给该函数进行处理。</p><p><strong>复习Consumer接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.util.function.Consumer&lt;T&gt;接口是一个消费型接口。</span><br><span class="line"><span class="comment">//Consumer接口中包含抽象方法void accept(T t)，意为消费一个指定泛型的数据。</span></span><br></pre></td></tr></table></figure><p><strong>基本使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04StreamForEach</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//获取一个Stream流</span></span><br><span class="line">		Stream&lt;String&gt; stream=Stream.of(<span class="string">"小舞"</span>,<span class="string">"朱竹清"</span>,<span class="string">"水冰儿"</span>,<span class="string">"胡列娜"</span>,<span class="string">"邱若水"</span>);</span><br><span class="line">		<span class="comment">//使用Stream中的forEach方法，对Stream流中的数据进行遍历</span></span><br><span class="line"><span class="comment">//		stream.forEach(new Consumer&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//			@Override</span></span><br><span class="line"><span class="comment">//			public void accept(String t) &#123;</span></span><br><span class="line"><span class="comment">//				System.out.println(t);</span></span><br><span class="line"><span class="comment">//				</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//		&#125;);</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//改用Lambda优化</span></span><br><span class="line">		stream.forEach(name-&gt;System.out.println(name));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤：filter"><a href="#过滤：filter" class="headerlink" title="过滤：filter"></a>过滤：filter</h3><p>可以通过 <code>filter</code> 方法将一个流转换成另一个子集流。方法签名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br></pre></td></tr></table></figure><p>该接口接收一个 <code>Predicate</code> 函数式接口参数（可以是一个<code>Lambda</code>或方法引用）作为筛选条件。</p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" data-original="/blog/2020/streaming-thought/filter.png" title="filter"><p><strong>复习Predicate接口</strong></p><p>此前我们已经学习过 <code>java.util.stream.Predicate</code> 函数式接口，其中唯一的抽象方法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br></pre></td></tr></table></figure><p>该方法将会产生一个boolean值结果，代表指定的条件是否满足。如果结果为true，那么<code>Stream流</code>的 <code>filter</code> 方法 将会留用元素；如果结果为false，那么 <code>filter</code> 方法将会舍弃元素。</p><p><strong>基本使用</strong></p><p>Stream流中的 filter 方法基本使用的代码如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05StreamFilter</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建一个Stream流</span></span><br><span class="line">		Stream&lt;String&gt; stream=Stream.of(<span class="string">"朱竹清"</span>,<span class="string">"宁荣荣"</span>,<span class="string">"江厌离"</span>,<span class="string">"胡列娜"</span>,<span class="string">"火舞"</span>,<span class="string">"水冰儿"</span>,<span class="string">"邱若水"</span>,<span class="string">"水月儿"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//对Stream流中的元素进行过滤，只要姓水的人</span></span><br><span class="line"><span class="comment">//		stream.filter(new Predicate&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//			@Override</span></span><br><span class="line"><span class="comment">//			public boolean test(String t) &#123;</span></span><br><span class="line"><span class="comment">//				// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//				return t.startsWith("水");</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//		&#125;).forEach(name-&gt;System.out.println(name));</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//Lambda优化</span></span><br><span class="line">		stream.filter(t-&gt;t.startsWith(<span class="string">"水"</span>)).forEach(name-&gt;System.out.println(name));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里通过Lambda表达式来指定了筛选的条件：必须姓水。</p><h3 id="映射：map"><a href="#映射：map" class="headerlink" title="映射：map"></a>映射：map</h3><p>如果需要将流中的元素映射到另一个流中，可以使用 <code>map</code> 方法。方法签名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span></span>;</span><br></pre></td></tr></table></figure><p>该接口需要一个 <code>Function</code> 函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。</p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" data-original="/blog/2020/streaming-thought/map.png" title="map"><p><strong>复习Function接口</strong></p><p>此前我们已经学习过 <code>java.util.stream.Function</code> 函数式接口，其中唯一的抽象方法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br></pre></td></tr></table></figure><p>这可以将一种T类型转换成为R类型，而这种转换的动作，就称为<strong>映射</strong>。</p><p><strong>基本使用</strong></p><p>Stream流中的 map 方法基本使用的代码如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06StreamMap</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Stream&lt;String&gt; stream=Stream.of(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>);</span><br><span class="line">		<span class="comment">//使用map方法，将字符串类型的整数，转换（映射）为Integer类型的整数</span></span><br><span class="line"><span class="comment">//		stream.map(new Function&lt;String, Integer&gt;() &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//			@Override</span></span><br><span class="line"><span class="comment">//			public Integer apply(String t) &#123;</span></span><br><span class="line"><span class="comment">//				// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//				return Integer.parseInt(t);</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//		&#125;).forEach(num-&gt;System.out.println(num));</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//优化</span></span><br><span class="line">		stream.map(t-&gt;Integer.parseInt(t)).forEach(num-&gt;System.out.println(num));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中， map 方法的参数通过方法引用，将字符串类型转换成为了int类型（并自动装箱为 Integer 类对 象）。</p><h3 id="统计个数：count"><a href="#统计个数：count" class="headerlink" title="统计个数：count"></a>统计个数：count</h3><p>正如旧集合 <code>Collection</code> 当中的 <code>size</code> 方法一样，流提供 <code>count</code> 方法来数一数其中的元素个数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>该方法返回一个long值代表元素个数（不再像旧集合那样是int值）。基本使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo07StreamCount</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">		list.add(<span class="number">1</span>);</span><br><span class="line">		list.add(<span class="number">2</span>);</span><br><span class="line">		list.add(<span class="number">2</span>);</span><br><span class="line">		list.add(<span class="number">2</span>);</span><br><span class="line">		list.add(<span class="number">2</span>);</span><br><span class="line">		list.add(<span class="number">2</span>);</span><br><span class="line">		list.add(<span class="number">2</span>);</span><br><span class="line">		Stream&lt;Integer&gt; stream=list.stream();</span><br><span class="line">		<span class="keyword">long</span> count=stream.count();</span><br><span class="line">		System.out.println(count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="取用前几个：limit"><a href="#取用前几个：limit" class="headerlink" title="取用前几个：limit"></a>取用前几个：limit</h3><p><code>limit</code> 方法可以对流进行截取，只取用前n个。方法签名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">limit</span><span class="params">(<span class="keyword">long</span> maxSize)</span></span>;</span><br></pre></td></tr></table></figure><p>参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。基本使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo08StreamLimit</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String[] girls= &#123;</span><br><span class="line">				<span class="string">"胡列娜"</span>,<span class="string">"江厌离"</span>,<span class="string">"邱若水"</span>,<span class="string">"朱竹清"</span>,<span class="string">"宁荣荣"</span>,<span class="string">"火舞"</span>,<span class="string">"水冰儿"</span>,<span class="string">"水月儿"</span></span><br><span class="line">		&#125;;</span><br><span class="line">		Stream&lt;String&gt; stream=Stream.of(girls);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//使用limit对Stream流中的元素进行截取，只要前三个元素</span></span><br><span class="line">		Stream&lt;String&gt; stream2=stream.limit(<span class="number">3</span>);</span><br><span class="line">		stream2.forEach(name-&gt;System.out.println(name));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>limit方法是一个延迟方法，跟filter、map一样，只是对流中的元素进行截取，返回的是一个新流，所以可以继续调用Stream</p></blockquote><h3 id="跳过前几个：skip"><a href="#跳过前几个：skip" class="headerlink" title="跳过前几个：skip"></a>跳过前几个：skip</h3><p>如果希望跳过前几个元素，可以使用 <code>skip</code> 方法获取一个截取之后的新流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。基本使用：</p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" data-original="/blog/2020/streaming-thought/skip.png" title="skip"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo09StreamSkip</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String[] girls= &#123;</span><br><span class="line">				<span class="string">"胡列娜"</span>,<span class="string">"江厌离"</span>,<span class="string">"邱若水"</span>,<span class="string">"朱竹清"</span>,<span class="string">"宁荣荣"</span>,<span class="string">"火舞"</span>,<span class="string">"水冰儿"</span>,<span class="string">"水月儿"</span></span><br><span class="line">		&#125;;</span><br><span class="line">		Stream&lt;String&gt; stream=Stream.of(girls);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//使用skip方法跳过前3个元素</span></span><br><span class="line">		stream.skip(<span class="number">3</span>).forEach(name-&gt;System.out.println(name));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合：concat"><a href="#组合：concat" class="headerlink" title="组合：concat"></a>组合：concat</h3><p>如果有两个流，希望合并成为一个流，那么可以使用 Stream 接口的静态方法 concat ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">concat</span><span class="params">(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>备注：这是一个静态方法，与 java.lang.String 当中的 concat 方法是不同的。</p></blockquote><p>该方法的基本使用代码如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo10StreamConcat</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Stream&lt;String&gt; boys=Stream.of(<span class="string">"唐三"</span>,<span class="string">"戴沐白"</span>,<span class="string">"魏无羡"</span>);</span><br><span class="line">		Stream&lt;String&gt; girls=Stream.of(<span class="string">"胡列娜"</span>,<span class="string">"水冰儿"</span>,<span class="string">"江厌离"</span>);</span><br><span class="line">		Stream&lt;String&gt; stream=Stream.concat(boys, girls);</span><br><span class="line">		stream.forEach(name-&gt;System.out.println(name));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-练习：集合元素处理（传统方式）"><a href="#5-练习：集合元素处理（传统方式）" class="headerlink" title="5 练习：集合元素处理（传统方式）"></a>5 练习：集合元素处理（传统方式）</h2><p><strong>题目</strong></p><p>现在有两个 ArrayList 集合存储队伍当中的多个成员姓名，要求使用传统的for循环（或增强for循环）依次进行以 下若干操作步骤：</p><ol><li>第一个队伍只要名字小于3个字的成员姓名；存储到一个新集合中。</li><li>第一个队伍筛选之后只要前3个人；存储到一个新集合中。</li><li>第二个队伍包含水字的成员姓名；存储到一个新集合中。</li><li>第二个队伍筛选之后不要前2个人；存储到一个新集合中。</li><li>将两个队伍合并为一个队伍；存储到一个新集合中。</li><li>根据姓名创建 Person 对象；存储到一个新集合中。</li><li>打印整个队伍的Person对象信息。</li></ol><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Person&#123;name='"</span>+name+<span class="string">"' &#125;"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo11Practice</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ArrayList&lt;String&gt; men=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		men.add(<span class="string">"唐三"</span>);</span><br><span class="line">		men.add(<span class="string">"邪月"</span>);</span><br><span class="line">		men.add(<span class="string">"焱"</span>);</span><br><span class="line">		men.add(<span class="string">"江澄"</span>);</span><br><span class="line">		men.add(<span class="string">"江枫眠"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//存储名字长度小于3</span></span><br><span class="line">		ArrayList&lt;String&gt; men1=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		<span class="keyword">for</span>(String s:men) &#123;</span><br><span class="line">			<span class="keyword">if</span>(s.length()&lt;<span class="number">3</span>) &#123;</span><br><span class="line">				men1.add(s);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//存储前三个</span></span><br><span class="line">		ArrayList&lt;String&gt; men2=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) &#123;</span><br><span class="line">			men2.add(men1.get(i));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		ArrayList&lt;String&gt; women=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		women.add(<span class="string">"胡列娜"</span>);</span><br><span class="line">		women.add(<span class="string">"水冰儿"</span>);</span><br><span class="line">		women.add(<span class="string">"火舞"</span>);</span><br><span class="line">		women.add(<span class="string">"水月儿"</span>);</span><br><span class="line">		women.add(<span class="string">"邱若水"</span>);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//存储包含水的</span></span><br><span class="line">		ArrayList&lt;String&gt; women1=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		<span class="keyword">for</span>(String s:women) &#123;</span><br><span class="line">			<span class="keyword">if</span>(s.contains(<span class="string">"水"</span>))</span><br><span class="line">				women1.add(s);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//存储除前两个以外的</span></span><br><span class="line">		ArrayList&lt;String&gt; women2=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;women1.size();i++) &#123;</span><br><span class="line">			women2.add(women1.get(i));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//添加两个集合</span></span><br><span class="line">		ArrayList&lt;String&gt; all=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		all.addAll(men2);</span><br><span class="line">		all.addAll(women2);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//根据姓名创建Person对象，存储到集合中</span></span><br><span class="line">		ArrayList&lt;Person&gt; people=<span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">		<span class="keyword">for</span>(String s:all) &#123;</span><br><span class="line">			people.add(<span class="keyword">new</span> Person(s));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//打印Person集合信息</span></span><br><span class="line">		<span class="keyword">for</span>(Person p:people) &#123;</span><br><span class="line">			System.out.println(p);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看，这代码写得，麻烦不？代码的艺术呢？我们做了这一系列工作，只是为了最后遍历一下结果而已，循环只是方式，而不是我们的目的。所以，直接采用Stream方式会更加方便</p><h2 id="6-练习：集合元素处理（Stream方式）"><a href="#6-练习：集合元素处理（Stream方式）" class="headerlink" title="6 练习：集合元素处理（Stream方式）"></a>6 练习：集合元素处理（Stream方式）</h2><p><strong>题目</strong></p><p>把上一题当中的传统for循环改为Stream流式处理方式，两个集合的初值保持不变，Person类的定义也不变</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo12Practice</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ArrayList&lt;String&gt; men = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		men.add(<span class="string">"唐三"</span>);</span><br><span class="line">		men.add(<span class="string">"邪月"</span>);</span><br><span class="line">		men.add(<span class="string">"焱"</span>);</span><br><span class="line">		men.add(<span class="string">"江澄"</span>);</span><br><span class="line">		men.add(<span class="string">"江枫眠"</span>);</span><br><span class="line"></span><br><span class="line">		ArrayList&lt;String&gt; women = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		women.add(<span class="string">"胡列娜"</span>);</span><br><span class="line">		women.add(<span class="string">"水冰儿"</span>);</span><br><span class="line">		women.add(<span class="string">"火舞"</span>);</span><br><span class="line">		women.add(<span class="string">"水月儿"</span>);</span><br><span class="line">		women.add(<span class="string">"邱若水"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 对men,存储名字长度小于3且前3个</span></span><br><span class="line">		Stream&lt;String&gt; men1=men.stream().filter(name-&gt;name.length()&lt;<span class="number">3</span>).limit(<span class="number">3</span>);</span><br><span class="line">		<span class="comment">// 对women,存储名字包含水且不包含前2个</span></span><br><span class="line">		Stream&lt;String&gt; women1=women.stream().filter(name-&gt;name.contains(<span class="string">"水"</span>)).skip(<span class="number">2</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//连接两个，并转存为Person类型，然后遍历</span></span><br><span class="line">		Stream.concat(men1, women1).map(name-&gt;<span class="keyword">new</span> Person(name)).forEach(person-&gt;System.out.println(person));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="post-detail">发布：2020-04-12 00:19:40<br>修改：2020-06-15 11:45:27<br>链接：<span class="shareUrl">https://meethigher.top/blog/2020/streaming-thought/</span><br>标签：<span><a href="/blog/tags/java/">java</a>&nbsp;</span></div><div class="post-btn"><img no-lazy src="/blog/images/alipay.png" style="display:none" alt="付款码"> <span class="post-donation-btn">捐助</span> <span class="post-share-btn">分享</span></div><div class="busuanzi"><span id="busuanzi_container_page_pv">阅读量<span id="busuanzi_value_page_pv"></span>次</span><script defer src="/blog/js/busuanzi.js"></script></div></article><div class="outline" title="目录"><span class="fa fa-list-alt"></span></div></div></main><script src="https://cdn.jsdelivr.net/gh/meethigher/cdn@9.0/js/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/gh/meethigher/cdn@11/js/layer/layer.js"></script><script src="https://cdn.jsdelivr.net/gh/meethigher/cdn@13/js/instantpage.js"></script><script src="/blog/js/meethigher.js"></script><script>let imgs = $(".post-content.blog-markdown img");imgs.css("width", "100%");</script><script>window.imageLazyLoadSetting={isSPA:!1,processImages:null}</script><script>window.addEventListener("load",function(){var a=/\.(gif|jpg|jpeg|tiff|png)$/i,e=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll(".blog-markdown img[data-original]")).forEach(function(t){var r=t.parentNode;"A"===r.tagName&&(r.href.match(a)||r.href.match(e))&&(r.href=t.dataset.original)})})</script><script>!function(t){function e(){n&&(o=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var e,i,r=0;r<o.length;r++)e=o[r],0<=(i=e.getBoundingClientRect()).bottom&&0<=i.left&&i.top<=(t.innerHeight||document.documentElement.clientHeight)&&function(){var t,e,n,i,a=o[r];t=a,e=function(){o=o.filter(function(t){return a===t&&t.removeAttribute("style"),a!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},n.src=i}()}t.imageLazyLoadSetting.processImages=e;var n=t.imageLazyLoadSetting.isSPA,o=Array.prototype.slice.call(document.querySelectorAll(".blog-markdown img[data-original]"));e(),t.addEventListener("scroll",function(){var n,o;n=e,o=t,clearTimeout(n.tId),n.tId=setTimeout(function(){n.call(o)},500)})}(this)</script></body></html>