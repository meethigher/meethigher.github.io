<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><meta name="keywords" content="方法引用,个人网站，个人博客，meethigher，学习，生活"><meta name="description" content="在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿什么参数做什么操作。那么考虑一种情况：如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑？"><title>方法引用</title><link rel="shortcut icon" href="/blog/images/favicon.ico"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/meethigher/cdn@9.0/css/meethigher-font.css"><link rel="stylesheet" href="/blog/css/index.css"></head><body><header class="header"><div class="header-menu"><span class="fa fa-bars"></span></div><div class="header-search"><span class="fa fa-search"></span></div><div class="header-title"><a href="/">言成言成啊<span class="header-subtitle"> | Kit Chen&#39;s Blog</span></a></div><ul class="header-navbar clearFix"><li><a href="/blog/">主页</a></li><li><a href="/blog/tags">标签</a></li><li><a href="/blog/archives">归档</a></li><li><a href="/blog/about">关于</a></li></ul></header><div id="particles-js"></div><script src="https://cdn.jsdelivr.net/gh/meethigher/cdn@9.0/js/particles.min.js"></script><script src="https://cdn.jsdelivr.net/gh/meethigher/cdn@9.0/js/app.js"></script><div class="search" title="站内搜索"><span class="fa fa-search"></span></div><div class="tool"><div class="up" title="返回顶部"><span class="fa fa-long-arrow-up"></span></div><div class="down" title="返回底部"><span class="fa fa-long-arrow-down"></span></div><a href="/blog/app.apk" class="app" title="下载App" download="app.apk"><span class="fa fa-android"></span></a></div><main class="main"><div class="main-content"><article class="post"><div class="post-title"><h2 class="title">方法引用</h2></div><div class="post-content blog-markdown"><h2 id="1-冗余的Lambda场景"><a href="#1-冗余的Lambda场景" class="headerlink" title="1 冗余的Lambda场景"></a>1 冗余的Lambda场景</h2><p>来看一个简单的函数式接口以应用<code>Lambda</code>表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Printable</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义字符串的抽象方法</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Printable</code> 接口当中唯一的抽象方法 <code>print</code> 接收一个字符串参数，目的就是为了打印显示它。那么通过<code>Lambda</code> 来使用它的代码很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Printable</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 定义一个方法，参数传递Printable接口，对字符串进行打印</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printString</span><span class="params">(Printable p)</span> </span>&#123;</span><br><span class="line">		p.print(<span class="string">"Hello World"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//调用printString方法，方法的参数Printable是一个函数式接口，所以可以传递Lambda表达式</span></span><br><span class="line">		printString(s-&gt;System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>printString</code>方法只管调用 <code>Printable</code> 接口的 <code>print</code> 方法，而并不管 <code>print</code> 方法的具体实现逻辑会将字符串打印到什么地方去。而 <code>main</code> 方法通过<code>Lambda</code>表达式指定了函数式接口<code>Printable</code>的具体操作方案为：拿到 <code>String</code>（类型可推导，所以可省略）数据后，在控制台中输出它。</p><h2 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2 问题分析"></a>2 问题分析</h2><p>这段代码的问题在于，对字符串进行控制台打印输出的操作方案，明明已经有了现成的实现，那就是 <code>System.out</code> 对象中的 <code>println(String)</code> 方法。既然<code>Lambda</code>希望做的事情就是调用 <code>println(String)</code> 方法，那何必自己手动调用呢？</p><h2 id="3-用方法引用改进代码"><a href="#3-用方法引用改进代码" class="headerlink" title="3 用方法引用改进代码"></a>3 用方法引用改进代码</h2><p>能否省去<code>Lambda</code>的语法格式（尽管它已经相当简洁）呢？只要“引用”过去就好了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Printable</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 定义一个方法，参数传递Printable接口，对字符串进行打印</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printString</span><span class="params">(Printable p)</span> </span>&#123;</span><br><span class="line">		p.print(<span class="string">"Hello World"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//调用printString方法，方法的参数Printable是一个函数式接口，所以可以传递Lambda表达式</span></span><br><span class="line">		<span class="comment">//printString(s-&gt;System.out.println(s));</span></span><br><span class="line">        printString(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意其中的双冒号 <code>::</code>写法，这被称为“方法引用”，而双冒号是一种新的语法。</p><blockquote><p>注意：</p><ol><li><code>System.out</code>对象是已经存在的</li><li><code>println</code>方法也是已经存在的</li></ol><p>所以我们可以使用方法引用来优化<code>Lambda</code>表达式，可以使用<code>System.out</code>方法直接调用<code>println</code>方法</p></blockquote><h2 id="4-方法引用符"><a href="#4-方法引用符" class="headerlink" title="4 方法引用符"></a>4 方法引用符</h2><p>双冒号<code>::</code>为引用运算符，而它所在的表达式被称为方法引用。</p><p>如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者。</p><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a><strong>语义分析</strong></h3><p>例如上例中， <code>System.out</code> 对象中有一个重载的 <code>println(String)</code> 方法恰好就是我们所需要的。那么对于 <code>printString</code> 方法的函数式接口参数，对比下面两种写法，完全等效：</p><ul><li>Lambda表达式写法：<code>s -&gt; System.out.println(s);</code></li><li>方法引用写法： <code>System.out::println</code></li></ul><p>第一种语义是指：拿到参数之后经<code>Lambda</code>之手，继而传递给 <code>System.out.println</code> 方法去处理。</p><p>第二种等效写法的语义是指：直接让 <code>System.out</code> 中的 <code>println</code> 方法来取代<code>Lambda</code>。两种写法的执行效果完全一样，而第二种方法引用的写法复用了已有方案，更加简洁。</p><blockquote><p>注:Lambda 中，传递的参数一定是方法引用的那个方法可以接收的类型，否则会抛出异常</p></blockquote><h3 id="推导与省略"><a href="#推导与省略" class="headerlink" title="推导与省略"></a><strong>推导与省略</strong></h3><p>如果使用<code>Lambda</code>，那么根据“可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载形式——它们都将被自动推导。</p><p>而如果使用方法引用，也是同样可以根据上下文进行推导。</p><p>函数式接口是<code>Lambda</code>的基础，而方法引用是<code>Lambda</code>的孪生兄弟。</p><p>下面这段代码将会调用 <code>println</code> 方法的不同重载形式，将函数式接口改为<code>String</code>类型的参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Printable</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义字符串的抽象方法</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于上下文变了之后可以自动推导出唯一对应的匹配重载，所以方法引用没有任何变化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Printable</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 定义一个方法，参数传递Printable接口，对字符串进行打印</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printString</span><span class="params">(Printable p)</span> </span>&#123;</span><br><span class="line">		p.print(<span class="string">"Hello World"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//调用printString方法，方法的参数Printable是一个函数式接口，所以可以传递Lambda表达式</span></span><br><span class="line">		printString(s-&gt;System.out.println(s));</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 分析：</span></span><br><span class="line"><span class="comment">		 * Lambda表达式的目的，</span></span><br><span class="line"><span class="comment">		 * 就是打印参数传递的字符串，把参数s传递给了System.out的对象，调用out对象中的方法println对字符串进行输出</span></span><br><span class="line"><span class="comment">		 * 注意：</span></span><br><span class="line"><span class="comment">		 * 1.System.out对象是已经存在的 2.println方法也是已经存在的</span></span><br><span class="line"><span class="comment">		 * 所以我们可以使用方法引用来优化Lambda表达式</span></span><br><span class="line"><span class="comment">		 * 可以使用System.out方法直接调用println方法</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		printString(System.out::println);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次方法引用将会自动匹配到 <code>println(String)</code> 的重载形式。</p><h2 id="5-通过对象名引用成员方法"><a href="#5-通过对象名引用成员方法" class="headerlink" title="5 通过对象名引用成员方法"></a>5 通过对象名引用成员方法</h2><p>这是最常见的一种用法，与上例相同。如果一个类中已经存在了一个成员方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02MethodRerObject</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义一个静态成员方法，传递字符串，把字符串按照大写输出</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printUpperCaseString</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">		System.out.println(str.toUpperCase());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数式接口仍然定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Printable</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义字符串的抽象方法</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么当需要使用这个<code>printUpperCase</code>成员方法来替代<code>Printable</code>接口的Lambda的时候，已经具有了<code>Demo02MethodRefObject</code>类的对象实例，则可以通过对象名引用成员方法，代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03ObjectMethodReference</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义一个方法，方法的参数传递Printable接口</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printString</span><span class="params">(Printable p)</span> </span>&#123;</span><br><span class="line">		p.print(<span class="string">"hello"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//调用printString方法，方法的参数Printable是一个函数式接口，所以可以传递Lambda表达式</span></span><br><span class="line">		printString(s-&gt;<span class="keyword">new</span> Demo02MethodRerObject().printUpperCaseString(s));</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//使用方法引用来优化</span></span><br><span class="line">		printString(<span class="keyword">new</span> Demo02MethodRerObject()::printUpperCaseString);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果里面的方法不是静态的话，则需要对象名::方法，这样使用；如果是静态方法，则可以直接使用类名::方法，这就是所谓的“可推导就是可省略”</p></blockquote><h2 id="6-通过类名称引用静态方法"><a href="#6-通过类名称引用静态方法" class="headerlink" title="6 通过类名称引用静态方法"></a>6 通过类名称引用静态方法</h2><p>由于在<code>java.lang.Math</code>类中已经存在了静态方法<code>abs</code>，所以当我们需要通过Lambda来调用该方法时，有两种写 法。首先是函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calcable</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义一个抽象方法，传递一个整数，对整数进行绝对值计算</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">calcAbs</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Lambda表达式和方法引用来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04StaticMethodReference</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义一个方法，传递计算绝对值的整数，和函数式接口Calcable</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> num,Calcable c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> c.calcAbs(num);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//调用method方法，传递计算绝对值的整数，和Lambda表达式</span></span><br><span class="line">		System.out.println(method(-<span class="number">10</span>,num-&gt;Math.abs(num)));</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 使用方法引用</span></span><br><span class="line"><span class="comment">		 * 1.Math类是存在的</span></span><br><span class="line"><span class="comment">		 * 2.abs方法是静态的</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		System.out.println(method(-<span class="number">10</span>,Math::abs));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，下面两种写法是等效的：</p><ul><li>Lambda表达式： <code>n -&gt; Math.abs(n)</code></li><li>方法引用： <code>Math::abs</code></li></ul><h2 id="7-通过super方法引用成员方法"><a href="#7-通过super方法引用成员方法" class="headerlink" title="7 通过super方法引用成员方法"></a>7 通过super方法引用成员方法</h2><p>如果存在继承关系，当Lambda中需要出现super调用时，也可以使用方法引用进行替代。首先是函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Greetable</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义一个见面的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是父类<code>Human</code>的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义一个说你好的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"hello 我是Human!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是子类<code>Man</code>的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Hello 我是Man!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//定义一个方法参数传递Greetable</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Greetable g)</span> </span>&#123;</span><br><span class="line">		g.greet();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//调用method方法，方法的参数Greetable是一个函数式接口，所以可以传递Lambda表达式</span></span><br><span class="line"><span class="comment">//		method(()-&gt;&#123;</span></span><br><span class="line"><span class="comment">//			//创建父类Human对象</span></span><br><span class="line"><span class="comment">//			Human h=new Human();</span></span><br><span class="line"><span class="comment">//			//调用父类的sayHello</span></span><br><span class="line"><span class="comment">//			h.sayHello();</span></span><br><span class="line"><span class="comment">//		&#125;);</span></span><br><span class="line">		<span class="comment">//因为有子父类关系，所以存在一个关键字super，代表父类，所以我们可以直接使用super调用父类的成员方法</span></span><br><span class="line"><span class="comment">//		method(()-&gt;super.sayHello());</span></span><br><span class="line">		<span class="comment">//使用方法引用 </span></span><br><span class="line">		method(<span class="keyword">super</span>::sayHello);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是主方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05SuperMethodReference</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Man().show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，下面两种写法是等效的：</p><ul><li>Lambda表达式： <code>() -&gt; super.sayHello()</code></li><li>方法引用： <code>super::sayHello</code></li></ul><h2 id="8-通过this引用成员方法"><a href="#8-通过this引用成员方法" class="headerlink" title="8 通过this引用成员方法"></a>8 通过this引用成员方法</h2><p>this代表当前对象，如果需要引用的方法就是当前类中的成员方法，那么可以使用<code>this::成员方法</code>的格式来使用方 法引用。首先是简单的函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Richable</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义一个想买啥就买啥的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个丈夫 <code>Husband</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Husband</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义一个买房子的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyHouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"北京二环内买一套四合院"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//定义一个结婚的方法，参数传递Richable接口</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">marry</span><span class="params">(Richable r)</span> </span>&#123;</span><br><span class="line">		r.buy();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//定义一个非常高兴的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">soHappy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//		marry(()-&gt;&#123;</span></span><br><span class="line"><span class="comment">//			this.buyHouse();</span></span><br><span class="line"><span class="comment">//		&#125;);</span></span><br><span class="line">		marry(<span class="keyword">this</span>::buyHouse);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开心方法 <code>beHappy</code> 调用了结婚方法 <code>marry</code> ，后者的参数为函数式接口 <code>Richable</code> ，所以需要一个Lambda表达式。 但是如果这个Lambda表达式的内容已经在本类当中存在了，则可以对 <code>Husband</code> 丈夫类进行修改：</p><p>主方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06ThisMethodReference</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Husband().soHappy();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，下面两种写法是等效的：</p><ul><li>Lambda表达式： <code>() -&gt; this.buyHouse()</code></li><li>方法引用：<code>this::buyHouse</code></li></ul><h2 id="9-类的构造器引用"><a href="#9-类的构造器引用" class="headerlink" title="9 类的构造器引用"></a>9 类的构造器引用</h2><p>由于构造器的名称与类名完全一样，并不固定。所以构造器引用使用 <code>类名称::new</code> 的格式表示。首先是一个简单的 <code>Person</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是用来创建 <code>Person</code> 对象的函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonBuilder</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义一个方法，根据传递的姓名传递Person对象返回</span></span><br><span class="line">	<span class="function">Person <span class="title">builderPerson</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要使用这个函数式接口，可以通过Lambda表达式，但是通过构造器引用，有更好的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo07ClassConstructor</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义一个方法，参数传递姓名和PersonBuilder接口，方法中通过姓名创建Person对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">(String name,PersonBuilder pb)</span> </span>&#123;</span><br><span class="line">		Person person=pb.builderPerson(name);</span><br><span class="line">		System.out.println(person.getName());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//调用printName方法，方法的参数PersonBuilder接口是一个函数式接口，所以可以传递Lambda表达式</span></span><br><span class="line"><span class="comment">//		printName("胡列娜",name-&gt;new Person(name));</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//使用方法引用，构造方法new Person(String name)已知，创建对象方式new已知</span></span><br><span class="line">		<span class="comment">//就可以使用Person引用new创建对象</span></span><br><span class="line">		printName(<span class="string">"胡列娜最美"</span>,Person::<span class="keyword">new</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，下面两种写法是等效的：</p><ul><li>Lambda表达式： <code>name -&gt; new Person(name)</code></li><li>方法引用： <code>Person::new</code></li></ul><h2 id="10-数组的构造器引用"><a href="#10-数组的构造器引用" class="headerlink" title="10 数组的构造器引用"></a>10 数组的构造器引用</h2><p>数组也是 <code>Object</code> 的子类对象，所以同样具有构造器，只是语法稍有不同。如果对应到Lambda的使用场景中时， 需要一个函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ArrayBuilder</span> </span>&#123;</span><br><span class="line">	<span class="comment">//创建一个int类型数组的方法，参数传递数组的长度，返回创建好的int类型数组</span></span><br><span class="line">	<span class="keyword">int</span>[] builderArray(<span class="keyword">int</span> length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在应用该接口的时候，可以通过Lambda表达式，但是更好的写法是使用数组的构造器引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo08ArrayConstructor</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 定义一个方法，方法的参数传递一个创建数组的长度和ArrayBuilder接口</span></span><br><span class="line"><span class="comment">	 * 方法内部根据传递的长度，使用ArrayBuilder中的方法创建数组并且返回 </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] createArray(<span class="keyword">int</span> length,ArrayBuilder ab) &#123;</span><br><span class="line">		<span class="keyword">return</span> ab.builderArray(length);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//调用createArray方法，传递数组的长度和Lambda表达式</span></span><br><span class="line"><span class="comment">//		System.out.println(createArray(10,length-&gt;new int[length]).length);</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 使用方法引用</span></span><br><span class="line"><span class="comment">		 * 已知创建的数组就是int[]数组</span></span><br><span class="line"><span class="comment">		 * 已知数组的长度是length</span></span><br><span class="line"><span class="comment">		 * 就可以使用方法引用</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		System.out.println(createArray(<span class="number">10</span>,<span class="keyword">int</span>[]::<span class="keyword">new</span>).length);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，下面两种写法是等效的：</p><ul><li>Lambda表达式： <code>length -&gt; new int[length]</code></li><li>方法引用： <code>int[]::new</code></li></ul></div><div class="post-detail">发布：2020-04-16 02:23:07<br>修改：2020-06-15 11:46:32<br>链接：<span class="shareUrl">https://meethigher.top/blog/2020/method-reference/</span><br>标签：<span><a href="/blog/tags/java/">java</a>&nbsp;</span></div><div class="post-btn"><img no-lazy src="/blog/images/alipay.png" style="display:none" alt="付款码"> <span class="post-donation-btn">捐助</span> <span class="post-share-btn">分享</span></div><div class="busuanzi"><span id="busuanzi_container_page_pv">阅读量<span id="busuanzi_value_page_pv"></span>次</span><script defer src="/blog/js/busuanzi.js"></script></div></article><div class="outline" title="目录"><span class="fa fa-list-alt"></span></div></div></main><script src="https://cdn.jsdelivr.net/gh/meethigher/cdn@9.0/js/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/gh/meethigher/cdn@11/js/layer/layer.js"></script><script src="https://cdn.jsdelivr.net/gh/meethigher/cdn@13/js/instantpage.js"></script><script src="/blog/js/meethigher.js"></script><script>let imgs = $(".post-content.blog-markdown img");imgs.css("width", "100%");</script><script>window.imageLazyLoadSetting={isSPA:!1,processImages:null}</script><script>window.addEventListener("load",function(){var a=/\.(gif|jpg|jpeg|tiff|png)$/i,e=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll(".blog-markdown img[data-original]")).forEach(function(t){var r=t.parentNode;"A"===r.tagName&&(r.href.match(a)||r.href.match(e))&&(r.href=t.dataset.original)})})</script><script>!function(t){function e(){n&&(o=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var e,i,r=0;r<o.length;r++)e=o[r],0<=(i=e.getBoundingClientRect()).bottom&&0<=i.left&&i.top<=(t.innerHeight||document.documentElement.clientHeight)&&function(){var t,e,n,i,a=o[r];t=a,e=function(){o=o.filter(function(t){return a===t&&t.removeAttribute("style"),a!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},n.src=i}()}t.imageLazyLoadSetting.processImages=e;var n=t.imageLazyLoadSetting.isSPA,o=Array.prototype.slice.call(document.querySelectorAll(".blog-markdown img[data-original]"));e(),t.addEventListener("scroll",function(){var n,o;n=e,o=t,clearTimeout(n.tId),n.tId=setTimeout(function(){n.call(o)},500)})}(this)</script></body></html>