<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><meta name="keywords" content="java中的反射与注解,个人网站，个人博客，meethigher，学习，生活"><meta name="description" content="简单了解一下反射跟注解"><title>java中的反射与注解</title><link rel="shortcut icon" href="/blog/images/favicon.ico"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/meethigher/cdn@9.0/css/meethigher-font.css"><link rel="stylesheet" href="/blog/css/index.css"></head><body><header class="header"><div class="header-menu"><span class="fa fa-bars"></span></div><div class="header-search"><span class="fa fa-search"></span></div><div class="header-title"><a href="/">言成言成啊<span class="header-subtitle"> | Kit Chen&#39;s Blog</span></a></div><ul class="header-navbar clearFix"><li><a href="/blog/">主页</a></li><li><a href="/blog/tags">标签</a></li><li><a href="/blog/archives">归档</a></li><li><a href="/blog/about">关于</a></li></ul></header><div id="particles-js"></div><script src="https://cdn.jsdelivr.net/gh/meethigher/cdn@9.0/js/particles.min.js"></script><script src="https://cdn.jsdelivr.net/gh/meethigher/cdn@9.0/js/app.js"></script><div class="search" title="站内搜索"><span class="fa fa-search"></span></div><div class="tool"><div class="up" title="返回顶部"><span class="fa fa-long-arrow-up"></span></div><div class="down" title="返回底部"><span class="fa fa-long-arrow-down"></span></div><a href="/blog/app.apk" class="app" title="下载App" download="app.apk"><span class="fa fa-android"></span></a></div><main class="main"><div class="main-content"><article class="post"><div class="post-title"><h2 class="title">java中的反射与注解</h2></div><div class="post-content blog-markdown"><p>先附上java14的官方<a href="https://docs.oracle.com/en/java/javase/14/docs/api/index.html" target="_blank" rel="noopener">最新文档</a>，不懂就查，方便快捷，一步到位。</p><h1 id="一、反射"><a href="#一、反射" class="headerlink" title="一、反射"></a>一、反射</h1><p>反射：框架设计的灵魂。</p><p>框架：半成品软件。可以在框架的基础上进行软件开发，简化编码。</p><p>在使用框架的时候，不会反射，没有问题；但如果要开发一个框架，就需要用到反射。</p><h2 id="1-1-反射的概念"><a href="#1-1-反射的概念" class="headerlink" title="1.1 反射的概念"></a>1.1 反射的概念</h2><p>java代码在计算机中经历三个阶段：源代码阶段、类对象阶段、运行时阶段</p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" data-original="/blog/2020/reflection-and-annotation/1.png" title="理解反射"><p>上图中，在类对象阶段，将成员方法，封装成Constructor[]数组这种过程，这就是反射。</p><p>举个例子，就比如写代码时，定义的一个String变量，可以通过快捷键将其所有方法显示出来，这就是通过反射完成的。</p><p><strong>概念：</strong>将类的各个组成部分封装为其他对象，这个过程叫做<code>反射</code>，也就是反射机制。</p><p>好处：</p><ol><li>可以在程序运行过程中，操作这些对象。</li><li>可以解耦，提高程序的可扩展性。</li></ol><p>很抽象，一会上案例。</p><h2 id="1-2-获取Class对象"><a href="#1-2-获取Class对象" class="headerlink" title="1.2 获取Class对象"></a>1.2 获取Class对象</h2><h3 id="通过Class-forName-“全类名”"><a href="#通过Class-forName-“全类名”" class="headerlink" title="通过Class.forName(“全类名”)"></a>通过Class.forName(“全类名”)</h3><p>如果此时处于<code>源代码阶段</code>，那我们可以通过<code>Class.forName(&quot;全类名&quot;)</code>这种方式，是将字节码文件加载进内存，返回<code>class</code>对象。</p><blockquote><p>全类名：包名.类名</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Reflect</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">		<span class="comment">//Class.forName("全类名")，全类名指包名.类名，即使是同一个包的，也不能省略包名</span></span><br><span class="line">		Class cls=Class.forName(<span class="string">"demo44.Person"</span>);</span><br><span class="line">		System.out.println(cls);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>适用场景：</p><p>多用于配置文件，将类名定义在配置文件中。读取文件，加载类</p></blockquote><h3 id="通过类名-class"><a href="#通过类名-class" class="headerlink" title="通过类名.class"></a>通过类名.class</h3><p>如果此时处于<code>类对象阶段</code>，那我们可以通过类名的属性<code>类名.class</code>获取class对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Reflect</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">		<span class="comment">//类名.class</span></span><br><span class="line">		Class cls2=Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">		System.out.println(cls2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>适用场景：</p><p>多用于参数的传递</p></blockquote><h3 id="通过对象-getClass"><a href="#通过对象-getClass" class="headerlink" title="通过对象.getClass()"></a>通过对象.getClass()</h3><p>如果此时处于<code>运行时阶段</code>，那我们可以通过<code>对象名.getClass</code>来获取class对象。</p><p>getClass()是在Object类中定义的，所以所有的类，都有这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Reflect</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">		<span class="comment">//对象名.getClass</span></span><br><span class="line">		Person p=<span class="keyword">new</span> Person();</span><br><span class="line">		Class cls3=p.getClass();</span><br><span class="line">		System.out.println(cls3);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>适用场景：</p><p>多用于对象获取字节码的方式</p></blockquote><h3 id="一次运行只会加载一次字节码文件"><a href="#一次运行只会加载一次字节码文件" class="headerlink" title="一次运行只会加载一次字节码文件"></a>一次运行只会加载一次字节码文件</h3><p>将三个不同过程中，获取到的对象，进行地址值的比较，会发现都是同一个地址。</p><p>由此，我们可以得出结论：<u>同一字节码文件(.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的class对象，都是同一个</u></p><h2 id="1-3-使用Class对象的获取功能"><a href="#1-3-使用Class对象的获取功能" class="headerlink" title="1.3 使用Class对象的获取功能"></a>1.3 使用Class对象的获取功能</h2><p>以下面这个<code>Person类</code>为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> sex;</span><br><span class="line">	<span class="keyword">protected</span> String intro;</span><br><span class="line">	String education;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">", sex="</span> + sex + <span class="string">", intro="</span> + intro + <span class="string">", education="</span></span><br><span class="line">				+ education + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(name + <span class="string">"最美！我爱"</span> + name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取成员变量"><a href="#获取成员变量" class="headerlink" title="获取成员变量"></a>获取成员变量</h3><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li>Field getField(String name) 返回一个Field对象，它反映此 Class对象所表示的类或接口的指定<strong>公共成员字段</strong>。</li><li>Field[] getFields() 返回一个包含某些 Field 对象的数组，这些对象反映此 Class 对象所表示的类或接口的所有可访问<strong>公共字段</strong>。</li><li>Field getDeclaredField(String name) 返回一个 Field 对象，该对象反映此 Class 对象所表示的类或接口的指定<strong>已声明字段</strong>。</li><li>Field[] getDeclaredFields() 返回 Field 对象的一个数组，这些对象反映此 Class 对象所表示的类或接口所声明的<strong>所有字段</strong>。</li></ul><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ul><li>获取值：Object get(Object obj) 返回指定对象上此 Field 表示的字段的值。</li><li>设置值：void set(Object obj, Object value) 将指定对象变量上此 Field 对象表示的字段设置为指定的新值。</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Reflect</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//获取Person的class对象</span></span><br><span class="line">		Class personClass=Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//获取成员变量</span></span><br><span class="line">		<span class="comment">//getFields()，获取所有public修饰的成员变量</span></span><br><span class="line">		Field[] fields=personClass.getFields();</span><br><span class="line">		<span class="keyword">for</span>(Field field:fields) &#123;</span><br><span class="line">			System.out.println(field);<span class="comment">//只能获取到public修饰的成员变量</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//getField(String)同样是获取指定public修饰的成员变量</span></span><br><span class="line">		Field sex=personClass.getField(<span class="string">"sex"</span>);</span><br><span class="line">		<span class="comment">//获取成员变量sex的值</span></span><br><span class="line">		Person p=<span class="keyword">new</span> Person();</span><br><span class="line">		Object value=sex.get(p);</span><br><span class="line">		System.out.println(value);<span class="comment">//因为没有给他赋值，所以获取的是默认的值0</span></span><br><span class="line">		<span class="comment">//设置sex的值</span></span><br><span class="line">		sex.set(p, <span class="number">1</span>);</span><br><span class="line">		System.out.println(p);<span class="comment">//Person&#123;name='null',age=0,sex=1,intro='null',education='null'&#125;</span></span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"==============="</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//getDeclaredFields()，获取所以的成员变量，不考虑修饰符</span></span><br><span class="line">		<span class="comment">//连私有的都可以获取，这就很牛逼，不用反射时，私有的属性是不能在类外面进行访问或设置的;</span></span><br><span class="line">		<span class="comment">//但是在反射里面，不存在私有。我的就是我的，你的还是我的</span></span><br><span class="line">		Field[] declaredFields=personClass.getDeclaredFields();</span><br><span class="line">		<span class="keyword">for</span>(Field declaredField:declaredFields) &#123;</span><br><span class="line">			System.out.println(declaredField);</span><br><span class="line">		&#125;</span><br><span class="line">		Field name=personClass.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line"><span class="comment">//		Object value2=name.get(p);</span></span><br><span class="line"><span class="comment">//		System.out.println(value2);//java.lang.IllegalAccessException，会报错。虽然私有的可以访问，但不能直接访问。</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//在访问非public的成员变量的时候，需要忽略访问权限修饰符的安全性检查</span></span><br><span class="line">		name.setAccessible(<span class="keyword">true</span>);<span class="comment">//暴力反射</span></span><br><span class="line">		Object value2=name.get(p);</span><br><span class="line">		System.out.println(value2);<span class="comment">//null</span></span><br><span class="line">		name.set(p, <span class="string">"胡列娜"</span>);</span><br><span class="line">		System.out.println(p);<span class="comment">//Person&#123;name='胡列娜',age=0,sex=1,intro='null',education='null'&#125;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意点：</p><ol><li>一般地，私有的成员变量不能在类外面进行访问或设置；但是在反射中，私有成员变量就可以获取和设置。这就是反射一个很牛逼的点。</li><li>在访问非public的成员变量的时候，会抛异常<code>IllegalAccessException</code>。这就需要忽略访问权限修饰符的安全性检查<code>setAccessible(boolean flag)</code>，<code>true</code>表示忽略，这也叫做<code>暴力反射</code></li></ol></blockquote><h3 id="获取构造方法"><a href="#获取构造方法" class="headerlink" title="获取构造方法"></a>获取构造方法</h3><h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li>Constructor<t>getConstructor(Class&lt;?&gt;… parameterTypes) 返回一个 Constructor 对象，它反映此 Class 对象所表示的类的指定公共构造方法。</t></li><li>Constructor&lt;?&gt;[] getConstructors() 返回一个包含某些 Constructor 对象的数组，这些对象反映此 Class 对象所表示的类的所有公共构造方法。</li><li>Constructor<t>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes) 返回一个 Constructor 对象，该对象反映此 Class 对象所表示的类或接口的指定构造方法。</t></li><li>Constructor&lt;?&gt;[] getDeclaredConstructors() 返回 Constructor 对象的一个数组，这些对象反映此 Class 对象表示的类声明的所有构造方法。</li></ul><h4 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h4><ul><li>创建对象：T newInstance(Object… initargs) Uses the constructor represented by this Constructor object to create and initialize a new instance of the constructor’s declaring class, with the specified initialization parameters.</li></ul><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03Reflect</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 获取Person的class对象</span></span><br><span class="line">		Class personClass = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//获取构造方法</span></span><br><span class="line">		<span class="comment">//Constructor&lt;T&gt;  getConstructor(Class&lt;?&gt;... parameterTypes)  参数是一个可变参数</span></span><br><span class="line">		<span class="comment">//参数列表，表示名称和性别</span></span><br><span class="line">		Constructor c=personClass.getConstructor(String<span class="class">.<span class="keyword">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;<span class="comment">//注意Integer.class!=int.class</span></span><br><span class="line">		System.out.println(c);</span><br><span class="line">		<span class="comment">//T newInstance(Object... initargs)通过这个来创建对象</span></span><br><span class="line">		Object person=c.newInstance(<span class="string">"胡列娜"</span>,<span class="number">22</span>);</span><br><span class="line">		System.out.println(person);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"======================"</span>);</span><br><span class="line">		<span class="comment">//也可以通过空参来获取构造方法</span></span><br><span class="line">		Constructor c2=personClass.getConstructor();</span><br><span class="line">		System.out.println(c2);</span><br><span class="line">		Object person2=c2.newInstance();</span><br><span class="line">		System.out.println(person2);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//如果想使用空参构造方法创建对象，操作可以简化：Class对象的newInstance()</span></span><br><span class="line">		<span class="comment">//但是，这个方法在java9以后，就已经过时了，不推荐使用。</span></span><br><span class="line">		System.out.println(personClass.newInstance());</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>私有的构造方法，也是需要通过暴力反射来解决。同理，获取成员方法时也一样。</p></blockquote><h3 id="获取成员方法"><a href="#获取成员方法" class="headerlink" title="获取成员方法"></a>获取成员方法</h3><h4 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li>Method getMethod(String name, Class&lt;?&gt;… parameterTypes) 返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。</li><li>Method[] getMethods() 返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。</li><li>Method getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes) 返回一个 Method 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。</li><li>Method[] getDeclaredMethods() 返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</li></ul><h4 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h4><ul><li>执行方法：Object invoke(Object obj, Object… args) 在具有指定参数的指定对象上，调用此Method对象表示的基础方法</li><li>获取方法名：String getName() 以String形式返回此Method对象表示的方法的名称。</li></ul><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04Reflect</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 获取Person的class对象</span></span><br><span class="line">		Class personClass = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//获取成员方法</span></span><br><span class="line">		<span class="comment">//Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</span></span><br><span class="line">		Method m=personClass.getMethod(<span class="string">"say"</span>);</span><br><span class="line">		<span class="comment">//Object invoke(Object obj, Object... args)</span></span><br><span class="line">		<span class="comment">//执行方法</span></span><br><span class="line">		m.invoke(<span class="keyword">new</span> Person(<span class="string">"胡列娜"</span>,<span class="number">20</span>));<span class="comment">//胡列娜最美！我爱胡列娜</span></span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"==========="</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//获取所有public修饰的方法getMethods</span></span><br><span class="line">		Method[] ms=personClass.getMethods();</span><br><span class="line">		<span class="keyword">for</span>(Method method:ms) &#123;</span><br><span class="line">			System.out.println(method.getName());<span class="comment">//包含父类里面的public方法</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面放出一个坑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCircle</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Math.PI*r*r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, SecurityException </span>&#123;</span><br><span class="line">		Class c=TestCircle<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">		Method m=c.getDeclaredMethod(<span class="string">"getArea"</span>, Double<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		System.out.println(m);<span class="comment">//java.lang.NoSuchMethodException</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细一看报错了吧。这是我老师上课写的，结果我下课研究的时候，整了两个小时才整明白，找到错误。</p><p>这个错，就是方法中变量的类型跟反射里面定义的类型不一样。</p><p>通俗点说，就是你的方法的变量类型是int，那么反射中获取方法时，变量的类型是int.class，同理，如果是Integer，那么反射中应是Integer。可以参照<a href="https://www.jianshu.com/p/f7f5cf5e08dd" target="_blank" rel="noopener">这篇文章</a></p><h3 id="获取类名"><a href="#获取类名" class="headerlink" title="获取类名"></a>获取类名</h3><h4 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li>String getName() 以 String 的形式返回此 Class 对象所表示的实体（类、接口、数组类、基本类型或 void）名称。</li></ul><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class personClass = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">System.out.println(personClass.getName());<span class="comment">//输出的是全类名，即包名+类名</span></span><br></pre></td></tr></table></figure><h2 id="1-4-反射案例"><a href="#1-4-反射案例" class="headerlink" title="1.4 反射案例"></a>1.4 反射案例</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>使用反射，写一个框架类，在不改变该类的任何代码的情况下，可以创建任意类的对象，并且执行其中任意的方法</p><p>实现：</p><ol><li>配置文件</li><li>反射</li></ol><p>步骤：</p><ol><li>将需要创建的对象的全类名和需要执行的方法定义在配置文件中</li><li>在程序中加载读取配置文件</li><li>使用反射技术来加载类文件进内存</li><li>创建对象</li><li>执行方法</li></ol><blockquote><p>通过这样，我们以后如果修改的话，就只需要改配置文件，而不需要改代码了</p></blockquote><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 框架类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kitchen</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 使用反射，在不改变任何代码的情况下，可以帮我们创建任意类的对象，并且执行其中任意方法</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 1.加载配置文件</span></span><br><span class="line">        <span class="comment">// 加载文件方法由很多，比方说，可以通过文件io流来进行读取，但是java里面有现成的对象可以处理配置文件</span></span><br><span class="line">		<span class="comment">// 1.1创建Properties对象</span></span><br><span class="line">		Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">		<span class="comment">// 1.2加载配置文件，转换为一个集合</span></span><br><span class="line">		<span class="comment">// 1.2.1获取class目录下的配置文件的方式</span></span><br><span class="line">		ClassLoader classLoader = ReflectTest<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line"><span class="comment">//		pro.load(new FileInputStream("src/demo44/pro.properties"));//这个是读取demo44下的配置文件</span></span><br><span class="line">		InputStream is = classLoader.getResourceAsStream(<span class="string">"pro.properties"</span>);<span class="comment">// 这样读取的话，默认是放到src根目录下的</span></span><br><span class="line">		pro.load(is);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2.获取配置文件中定义的数据</span></span><br><span class="line">		String className = pro.getProperty(<span class="string">"className"</span>);</span><br><span class="line">		String methodName = pro.getProperty(<span class="string">"methodName"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 3.加载该类进内存</span></span><br><span class="line">		Class cls = Class.forName(className);</span><br><span class="line">		<span class="comment">// 4.创建对象</span></span><br><span class="line">		Object obj = cls.newInstance();</span><br><span class="line">		<span class="comment">// 5.获取方法对象</span></span><br><span class="line">		Method met = cls.getMethod(methodName);</span><br><span class="line">		<span class="comment">// 6.执行方法</span></span><br><span class="line">		System.out.println(cls.getName());</span><br><span class="line">		met.invoke(obj);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当类是GirlFriend时，执行marry方法</p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" data-original="/blog/2020/reflection-and-annotation/2.png" title="GirlFriend"><p>当类是Wife时，执行divorce方法</p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" data-original="/blog/2020/reflection-and-annotation/3.png" title="Wife"><p>同样的代码，可以有不同的运行结果，这个过程只需要改配置文件。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># className=demo44.domain.GirlFriend</span></span><br><span class="line"><span class="comment"># methodName=marry</span></span><br><span class="line"></span><br><span class="line"><span class="attr">className</span>=<span class="string">demo44.domain.Wife</span></span><br><span class="line"><span class="attr">methodName</span>=<span class="string">divorce</span></span><br></pre></td></tr></table></figure><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>当项目比较庞大的时候，如果直接改代码，改完之后还需要进行测试，容易出问题。而通过反射，只需要改配置文件就可以了。</p><h1 id="二、注解"><a href="#二、注解" class="headerlink" title="二、注解"></a>二、注解</h1><h2 id="2-1-注解的概念"><a href="#2-1-注解的概念" class="headerlink" title="2.1 注解的概念"></a>2.1 注解的概念</h2><p>注释：<strong>用文字描述程序</strong>。比方说描述程序的功能，程序变量的含义之类的。<strong>注释给开发者看的</strong>。</p><p>注解：<strong>说明程序的</strong>。<strong>注解给计算机看的</strong>。</p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" data-original="/blog/2020/reflection-and-annotation/4.png" title="注解"><p><strong>概念描述</strong></p><ul><li>jdk1.5之后的新特性</li><li>说明程序的</li><li>使用注解：@注解名称</li></ul><p><strong>作用分类</strong></p><ol><li>编写文档：通过代码里标识的注解生成文档（通过<code>javadoc 文件全名</code>生成doc文档）</li><li>代码分析：通过代码里标识的元数据对代码进行分析（使用反射）</li><li>编译检查：通过代码里标识的元数据让编译器能够实现基本的编译检查（Override）</li></ol><h2 id="2-2-jdk的内置注解"><a href="#2-2-jdk的内置注解" class="headerlink" title="2.2 jdk的内置注解"></a>2.2 jdk的内置注解</h2><h3 id="常用内置注解"><a href="#常用内置注解" class="headerlink" title="常用内置注解"></a>常用内置注解</h3><ul><li><p>@Override：检测被该注解标注的方法是否是继承自父类（接口）的</p></li><li><p>@Deprecated：将该注解标注的内容，已过时</p></li><li><p>@SuppressWarnings： 指示编译器去忽略注解中声明的警告。</p></li></ul><p>了解更多的<a href="https://www.runoob.com/w3cnote/java-annotation.html" target="_blank" rel="noopener">java注解</a>，移步到菜鸟教程。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"all"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Annotation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Demo01Annotation []"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Deprecated</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 这个方法后来发现有缺陷，又新增了一个play2方法</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 替代play方法，推荐开发者使用play2，而不使用play。</span></span><br><span class="line">		<span class="comment">// 同时为了保证能够兼容低版本jdk，play方法选择保留，但是要提示开发者不建议使用</span></span><br><span class="line">		ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		play();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>描述一下@SuppressWarning注解的使用。如果代码段报警告，可以通过@SuppressWarnings(“all”)标注在其方法上来忽略警告，不过一般地，会直接将其标注在类上。</p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" data-original="/blog/2020/reflection-and-annotation/5.png" title="忽略警告"><h2 id="2-3-自定义注解"><a href="#2-3-自定义注解" class="headerlink" title="2.3 自定义注解"></a>2.3 自定义注解</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>如何自定义注解？先来看一下内置注解的格式：</p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" data-original="/blog/2020/reflection-and-annotation/6.png" title="内置注解"><p>通过对两个内置注解的观察，我们可以发现，注解是由下面这两个部分组成的。</p><ul><li>元注解</li><li>public @interface 注解名称{}</li></ul><p>举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Demo02Annotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上面这个为例，我们将其进行<code>javac</code>编译，然后再通过<code>javap</code>反编译，得到以下这个代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Demo02Annotation</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">annotation</span>.<span class="title">Annotation</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" data-original="/blog/2020/reflection-and-annotation/7.png" title="编译反编译"><p>注解本质上就是一个接口，该接口默认继承了Annotation。接口里面可以定义什么，注解里面同样可以定义什么</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>注解里的<strong>属性</strong>，可以认为是接口中的<strong>抽象方法</strong>，因为它可以在使用时，跟属性（成员变量）一样用</p><p>要求：</p><ol><li>属性的返回值类型：基本数据类型、String、枚举、注解、以上类型的数组</li><li>定义了属性，在使用时，需要给属性赋值。<ul><li>如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值</li><li>如果只有一个属性需要赋值，并且属性的名称是<strong>value</strong>，则value可以省略（可以参考@SuppressWarnings的源码）</li><li>数组赋值时，用{}包裹。如果其中只有一个值的时候，{}可以省略不写</li></ul></li></ol><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个枚举</span></span><br><span class="line"><span class="keyword">enum</span> Person &#123;</span><br><span class="line">	Male, Female</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个注解</span></span><br><span class="line"><span class="meta">@interface</span> Anno &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Demo02Annotation &#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> "胡列娜"</span>;</span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">()</span></span>;<span class="comment">//这是枚举</span></span><br><span class="line">	<span class="function">Anno <span class="title">a</span><span class="params">()</span></span>;<span class="comment">//这是注解</span></span><br><span class="line">	String[] pers();<span class="comment">//这是String类型数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试使用注解</span></span><br><span class="line"><span class="comment">//@Demo02Annotation(age = 22, name = "江厌离")</span></span><br><span class="line"><span class="comment">//如果我们不想给他赋值，我们可以在定义的时候，默认给他值</span></span><br><span class="line"><span class="comment">//如 String name() default "初值"</span></span><br><span class="line"><span class="meta">@Demo</span>02Annotation(value=<span class="number">22</span>,a = <span class="meta">@Anno</span>, p = Person.Male, pers = &#123; <span class="string">"胡列娜"</span>,<span class="string">"江厌离"</span>,<span class="string">"邱若水"</span> &#125;) </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元注解：用于描述注解的注解</p><p>常用的元注解：</p><ul><li>@Target：描述注解能够作用的位置<ul><li>ElementType取值<ul><li>TYPE：可以作用在类上</li><li>METHOD：可以作用在方法上</li><li>FIELD：可以作用在成员变量上</li></ul></li></ul></li><li>@Retention：描述注解被保留的阶段<ul><li>@Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被jvm读取到。一般也只会用到这个</li></ul></li><li>@Documented：描述注解是否被抽取到api文档中</li><li>@Inherited：描述注解是否被子类继承</li></ul><p>对于@Retention，把源码截图放到这里，其中刚好对应java代码经过的三个阶段</p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" data-original="/blog/2020/reflection-and-annotation/8.png" title="@Retention"><p>像Documented，还有@Inherited就不多赘述了，演示过程也就不放上来了。通过命令<strong>javadoc</strong>生成文档时，会发现区别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示Demo03Annotation注解只能做作用于类、方法和变量上</span></span><br><span class="line"><span class="comment">//注解被保留到Runtime阶段</span></span><br><span class="line"><span class="comment">//同时因为只有一个变量，所以value可以省略</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123; ElementType.TYPE,ElementType.METHOD,ElementType.FIELD &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Demo03Annotation &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Demo</span>03Annotation</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker01</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Demo</span>03Annotation</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-使用（解析）注解"><a href="#2-4-使用（解析）注解" class="headerlink" title="2.4 使用（解析）注解"></a>2.4 使用（解析）注解</h2><p>在程序中使用（解析）注解：<strong>获取注解中定义的属性值</strong></p><p>由此，在大多数时候，注解是<strong>用来替换配置文件</strong>的</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>获取注解定义的位置的对象</li><li>获取指定的注解<ul><li>getAnnotation(Class)</li></ul></li><li>调用注解中的抽象方法，获取配置的属性值</li></ol><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><p>跟<a href="#1-4-反射案例">反射案例</a>一样，实现同样的功能。<strong>用注解替代配置文件</strong>。</p><p><strong>Pro.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Pro &#123;</span><br><span class="line">	<span class="function">String <span class="title">className</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">String <span class="title">methodName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面这个代码，请忽略，只是为了帮助ReflectAnnotationTest.java理解第2步</span></span><br><span class="line"><span class="comment">//相当于实现了注解接口的实现类，具体代码参照ReflectAnnotationTest.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProImpl</span> <span class="keyword">implements</span> <span class="title">Pro</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Class&lt;? extends Annotation&gt; annotationType() &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">className</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">methodName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ReflectAnnotation.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pro</span>(className = <span class="string">"demo44.domain.GirlFriend"</span>, methodName = <span class="string">"marry"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectAnnotationTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 1.解析注解</span></span><br><span class="line">		<span class="comment">// 1.1获取该类的字节码文件对象</span></span><br><span class="line">		Class&lt;ReflectAnnotationTest&gt; c = ReflectAnnotationTest<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">		<span class="comment">// 2.获取上边的注解对象</span></span><br><span class="line">		Pro an = c.getAnnotation(Pro<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">// 其实就是在内存中生成了一个该注解接口的子类实现对象，这个过程我另外写一个代码ProImpl.java</span></span><br><span class="line">		<span class="comment">// 3.调用注解对象中定义的抽象方法，获取返回值。因为该注解接口，已经在上一步中被实现了</span></span><br><span class="line">		String className = an.className();</span><br><span class="line">		String methodName = an.methodName();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 4.加载该类进内存</span></span><br><span class="line">		Class cls = Class.forName(className);</span><br><span class="line">		<span class="comment">// 5.创建对象</span></span><br><span class="line">		Object obj = cls.newInstance();</span><br><span class="line">		<span class="comment">// 6.获取方法对象</span></span><br><span class="line">		Method met = cls.getMethod(methodName);</span><br><span class="line">		<span class="comment">// 7.执行方法</span></span><br><span class="line">		System.out.println(cls.getName());</span><br><span class="line">		met.invoke(obj);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-实现简单的测试框架"><a href="#2-5-实现简单的测试框架" class="headerlink" title="2.5 实现简单的测试框架"></a>2.5 实现简单的测试框架</h2><p><strong>Check.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Check &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Calculator.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加法</span></span><br><span class="line">	<span class="meta">@Check</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String str = <span class="keyword">null</span>;</span><br><span class="line">		str.toString();</span><br><span class="line">		System.out.println(<span class="string">"1 + 0 ="</span> + (<span class="number">1</span> + <span class="number">0</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 减法</span></span><br><span class="line">	<span class="meta">@Check</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(Integer.parseInt(<span class="string">"hahah123"</span>));</span><br><span class="line">		System.out.println(<span class="string">"1 - 0 ="</span> + (<span class="number">1</span> - <span class="number">0</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 乘法</span></span><br><span class="line">	<span class="meta">@Check</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mul</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"1 * 0 ="</span> + (<span class="number">1</span> * <span class="number">0</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 除法</span></span><br><span class="line">	<span class="meta">@Check</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">div</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"1 / 0 ="</span> + (<span class="number">1</span> / <span class="number">0</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"永无bug..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>TestCheck.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单的测试框架</span></span><br><span class="line"><span class="comment"> * 当主方法执行后，会自动去执行被检测的所有方法（加了check注解的方法）</span></span><br><span class="line"><span class="comment"> * 判断是否有异常，然后记录到文件中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kit chen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCheck</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//记录出错的次数</span></span><br><span class="line">		BufferedWriter bw=<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"bug.txt"</span>));</span><br><span class="line">		<span class="comment">//1.创建计算器对象</span></span><br><span class="line">		Calculator c=<span class="keyword">new</span> Calculator();</span><br><span class="line">		<span class="comment">//2.获取字节码文件</span></span><br><span class="line">		Class cls=c.getClass();</span><br><span class="line">		<span class="comment">//3.获取所有方法</span></span><br><span class="line">		Method[] methods=cls.getMethods();</span><br><span class="line">		<span class="comment">//4.判断方法上是否有check注解，有就执行，无就跳过</span></span><br><span class="line">		<span class="keyword">for</span>(Method m:methods) &#123;</span><br><span class="line">			<span class="keyword">if</span>(m.isAnnotationPresent(Check<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					m.invoke(c);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					<span class="comment">//5.捕获异常，记录到文件</span></span><br><span class="line">					count++;</span><br><span class="line">					bw.write(<span class="string">"异常的方法："</span>+m.getName());</span><br><span class="line">					bw.newLine();</span><br><span class="line">					bw.write(<span class="string">"异常的名称："</span>+e.getCause().getClass().getSimpleName());</span><br><span class="line">					bw.newLine();</span><br><span class="line">					bw.write(<span class="string">"异常的原因："</span>+e.getCause().getMessage());</span><br><span class="line">					bw.newLine();</span><br><span class="line">					bw.write(<span class="string">"======================"</span>);</span><br><span class="line">					bw.newLine();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		bw.write(<span class="string">"本次测试一共出现 "</span>+count+<span class="string">" 次异常"</span>);</span><br><span class="line">		bw.flush();</span><br><span class="line">		bw.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" data-original="/blog/2020/reflection-and-annotation/9.png" title="测试结果"><p>这就实现了一个简单的测试框架。</p><p>同样的道理，像原来学过的Junit就算是一个测试框架了，里面的@Test就是注解。</p><blockquote><p>总结：</p><ul><li><p>大多数时候，会使用注解，而不是自定义注解</p></li><li><p>注解为谁服务？</p><ul><li>编译器</li><li>解析程序。像刚才的TestCheck.java就算是一个解析程序了。如果没有程序的存在，注解的存在将毫无意义</li></ul></li><li><p>注解不是程序的一部分，可以将注解理解成一种标签。以刚才例子来说，给方法加上@Check，就表示，这个方法要被检测的意思。</p></li></ul></blockquote><p>PS：今天形式政策考试考了65，老师在群里让同学发成绩单，我的分数是最低的。这也算是我一段时间来学习态度的反映吧。像数学跟线代还有英语，这学期，上网课期间，我不是上课睡觉，就是在玩电脑，一点都没听，我也该收收心好好学学数学了。加油！奥利给！好好学习！</p></div><div class="post-detail">发布：2020-04-22 23:30:09<br>修改：2020-06-15 11:56:38<br>链接：<span class="shareUrl">https://meethigher.top/blog/2020/reflection-and-annotation/</span><br>标签：<span><a href="/blog/tags/java/">java</a>&nbsp;</span></div><div class="post-btn"><img no-lazy src="/blog/images/alipay.png" style="display:none" alt="付款码"> <span class="post-donation-btn">捐助</span> <span class="post-share-btn">分享</span></div><div class="busuanzi"><span id="busuanzi_container_page_pv">阅读量<span id="busuanzi_value_page_pv"></span>次</span><script defer src="/blog/js/busuanzi.js"></script></div></article><div class="outline" title="目录"><span class="fa fa-list-alt"></span></div></div></main><script src="https://cdn.jsdelivr.net/gh/meethigher/cdn@9.0/js/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/gh/meethigher/cdn@11/js/layer/layer.js"></script><script src="https://cdn.jsdelivr.net/gh/meethigher/cdn@13/js/instantpage.js"></script><script src="/blog/js/meethigher.js"></script><script>let imgs = $(".post-content.blog-markdown img");imgs.css("width", "100%");</script><script>window.imageLazyLoadSetting={isSPA:!1,processImages:null}</script><script>window.addEventListener("load",function(){var a=/\.(gif|jpg|jpeg|tiff|png)$/i,e=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll(".blog-markdown img[data-original]")).forEach(function(t){var r=t.parentNode;"A"===r.tagName&&(r.href.match(a)||r.href.match(e))&&(r.href=t.dataset.original)})})</script><script>!function(t){function e(){n&&(o=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var e,i,r=0;r<o.length;r++)e=o[r],0<=(i=e.getBoundingClientRect()).bottom&&0<=i.left&&i.top<=(t.innerHeight||document.documentElement.clientHeight)&&function(){var t,e,n,i,a=o[r];t=a,e=function(){o=o.filter(function(t){return a===t&&t.removeAttribute("style"),a!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},n.src=i}()}t.imageLazyLoadSetting.processImages=e;var n=t.imageLazyLoadSetting.isSPA,o=Array.prototype.slice.call(document.querySelectorAll(".blog-markdown img[data-original]"));e(),t.addEventListener("scroll",function(){var n,o;n=e,o=t,clearTimeout(n.tId),n.tId=setTimeout(function(){n.call(o)},500)})}(this)</script></body></html>